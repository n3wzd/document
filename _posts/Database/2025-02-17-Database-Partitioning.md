---
categories:
- Database
date: '2025-02-17'
title: '[Database] Partitioning'
---

{% raw %}
파티셔닝(Partitioning)은 대규모 데이터베이스에서 **데이터를 여러 개의 부분(파티션)으로 나누어 관리**하는 기법입니다. 각 파티션은 **물리적으로 별도의 저장 공간에 존재하지만, 논리적으로는 하나의 테이블**처럼 동작합니다. 파티셔닝은 데이터의 크기가 커질 때 성능을 최적화하고, 관리의 용이성을 높이기 위해 사용됩니다.

1. **성능 향상**: 파티셔닝된 테이블에서 쿼리가 특정 파티션만 대상으로 실행되므로, 불필요한 데이터를 조회하지 않아 성능이 개선됩니다. 예를 들어, 날짜별로 파티셔닝을 하면 특정 날짜의 데이터만 조회할 수 있습니다.
2. **관리 용이성**: 파티셔닝된 테이블은 관리가 용이합니다. 예를 들어, 오래된 데이터를 아카이빙하거나 삭제할 때, 특정 파티션만 처리하면 됩니다.
3. **병렬 처리**: 각 파티션은 독립적으로 처리되므로, 데이터베이스 시스템이 병렬로 작업을 처리할 수 있어 처리 속도가 빨라집니다.

### 수직 파티셔닝 (Vertical Partitioning)
수직 파티셔닝은 **테이블의 열(컬럼)을 기준**으로 데이터를 분할하는 방법입니다. 즉, **같은 행(row)의 데이터** 중에서 **다른 열을 별도의 테이블로 나누는 방식**입니다.

- 자주 조회되는 열을 하나의 테이블에 두고, 사용 빈도가 적은 열은 다른 테이블에 분리하여 성능을 최적화할 수 있습니다.
- 예를 들어, 고객 테이블에서 `이름`, `이메일`과 같은 기본 정보는 하나의 테이블에, `주소`, `전화번호`와 같은 부가 정보는 다른 테이블에 분리할 수 있습니다.

```sql
-- 원본 테이블
CREATE TABLE users (
    user_id INT,
    name VARCHAR(100),
    email VARCHAR(100),
    address VARCHAR(255),
    phone_number VARCHAR(20)
);

-- 수직 파티셔닝된 테이블
CREATE TABLE users_basic_info (
    user_id INT,
    name VARCHAR(100),
    email VARCHAR(100)
);

CREATE TABLE users_contact_info (
    user_id INT,
    address VARCHAR(255),
    phone_number VARCHAR(20)
);
```

### 수평 파티셔닝 (Horizontal Partitioning)
수평 파티셔닝은 **테이블의 행(row)을 기준**으로 데이터를 분할하는 방법입니다. 즉, **같은 컬럼**의 데이터들 중에서 **행을 나누는 방식**입니다. 데이터를 여러 개의 파티션으로 나누어 각각 독립적으로 저장합니다.

- 수평 파티셔닝은 데이터가 많이 늘어나거나 성능을 최적화해야 하는 경우에 유용합니다.
- 분할 기준에 따라 여러 파티션에 데이터를 분배하여 저장할 수 있습니다. 예를 들어, 날짜, 지역, 사용자 그룹 등을 기준으로 데이터를 나눌 수 있습니다.

#### 범위 기반 파티셔닝 (Range Partitioning)
데이터의 특정 열에 대해 범위(구간)를 정의하고, 그 범위에 맞는 데이터를 파티션에 나눕니다. 예를 들어, 특정 날짜나 ID 범위에 따라 데이터를 분할할 수 있습니다.

- `order_date`가 `2023-01-01`부터 `2023-06-30`까지는 파티션 A, `2023-07-01`부터 `2023-12-31`까지는 파티션 B.
- 범위 기반 검색이 효율적입니다. 예를 들어, 날짜 범위나 ID 범위로 데이터를 조회할 때 유용합니다.
- 특정 범위에 데이터가 몰리게 되면 부하가 집중될 수 있습니다. 예를 들어, 한 날짜에 트랜잭션이 집중되거나 특정 ID 범위에 많은 데이터가 몰리는 경우 성능이 저하될 수 있습니다.

#### 해시 기반 파티셔닝 (Hash Partitioning)
데이터의 특정 열을 해시 함수에 입력하여 결과 값을 바탕으로 데이터를 파티션에 분배합니다. 데이터가 균등하게 분배되도록 해시 값을 사용하기 때문에 파티션이 고르게 나누어집니다.

- `user_id`에 대해 해시 값을 계산하고, 그 결과를 바탕으로 데이터를 4개의 파티션에 분배합니다. 예를 들어, `user_id % 4` 값을 사용하여 4개의 파티션으로 분배합니다.
- 데이터를 고르게 분배할 수 있습니다. 즉, 특정 범위에 데이터가 몰리지 않고 전체적으로 분배되므로 성능이 고르게 유지됩니다.
- 해시 기반 파티셔닝은 범위 검색에 비효율적입니다. 예를 들어, 특정 `user_id` 범위를 검색하려면 모든 파티션을 검색해야 하므로 성능이 저하될 수 있습니다.

#### 리스트 기반 파티셔닝 (List Partitioning)
특정 열에 대해 미리 정의된 값 목록을 기준으로 데이터를 나누는 방식입니다. 이 방식은 데이터가 특정한 그룹에 속할 때 유용합니다.

- `country`가 'USA'인 데이터는 파티션 A, 'Korea'인 데이터는 파티션 B. `status`가 'active'인 데이터는 파티션 A, 'inactive'인 데이터는 파티션 B.
- 데이터가 미리 정의된 그룹에 속할 때 효율적입니다. 예를 들어, 국가별, 상태별로 데이터를 나누는 경우 범위가 분명하므로 검색이 효율적입니다.
- 새로운 값이 추가될 때 관리가 필요하며, 이를 처리하는 로직이 복잡해질 수 있습니다. 또한, 값이 고정된 목록에 포함되지 않는 데이터는 처리하기 어려울 수 있습니다.

### 파티셔닝 자동화
**파티셔닝 자동화**란 데이터베이스에서 데이터를 여러 파티션(구역)으로 자동으로 나누는 과정을 말합니다. 이 과정은 수동으로 데이터를 분리할 필요 없이 데이터베이스 시스템이 자동으로 데이터를 여러 파티션으로 분배하도록 설정하는 방식입니다.

1. **파티셔닝 기준 자동 설정**:
    - 데이터를 특정 기준(예: 날짜, 범위, 해시 값 등)에 따라 자동으로 나누는 방법입니다.
    - 예를 들어, 특정 날짜를 기준으로 데이터가 자동으로 일별 파티션으로 나누어지도록 설정할 수 있습니다.
2. **파티션 크기 조정**:
    - 파티셔닝 시스템이 데이터의 양에 따라 파티션을 자동으로 크기를 조정하거나 새 파티션을 추가하는 기능입니다.
    - 데이터가 증가하면 자동으로 새로운 파티션을 생성하거나 기존 파티션을 분할하여 성능을 유지할 수 있습니다.
3. **데이터 이동 자동화**:
    - 데이터가 특정 기준에 도달하면 자동으로 해당 데이터를 다른 파티션으로 이동시킵니다.
    - 예를 들어, 오래된 데이터를 아카이브 파티션으로 이동시켜 현재 파티션에서 불필요한 데이터를 제거할 수 있습니다.
4. **스케일링**:
    - 시스템이 자동으로 파티션을 나누고 조정하여 성능을 최적화할 수 있게 하며, 더 많은 데이터를 처리할 수 있도록 합니다.
    - 파티셔닝 시스템은 데이터가 많아질수록 수동 개입 없이도 확장이 가능해야 하므로, 데이터베이스의 부하 분산을 자동으로 처리합니다.

MySQL에서 `RANGE` 파티셔닝을 사용하여 `created_at` 필드 기준으로 데이터를 분할:
```sql
CREATE TABLE logs (
    id INT,
    message VARCHAR(255),
    created_at DATETIME
) PARTITION BY RANGE (YEAR(created_at)) (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026)
);
```

위의 테이블은 **시간에 따라** 새로운 파티션이 자동으로 추가됩니다. 예를 들어, 2024년이 시작되면 `p2024` 파티션이 자동으로 활성화되고, 2025년에는 `p2025` 파티션이 생성됩니다.

Bash 스크립트를 사용하여 데이터베이스에 접속하고 SQL 명령을 실행하는 방법도 가능합니다. 이때, Bash에서 SQL 스크립트를 실행할 수 있도록 `psql` (PostgreSQL)이나 `mysql` (MySQL) 커맨드 라인 도구를 사용합니다.

예시 (Bash + PostgreSQL):
```
#!/bin/bash
CURRENT_DATE=$(date +"%Y_%m")
PSQL_CMD="psql -U username -d database_name"

# 새로운 파티션 생성
$PSQL_CMD -c "CREATE TABLE transactions_${CURRENT_DATE} PARTITION OF transactions FOR VALUES FROM ('${CURRENT_DATE}-01') TO ('$(date -d '+1 month' +"%Y-%m-01")');"
```

위 예시에서는 Bash를 통해 현재 날짜에 맞는 파티션을 생성하는 SQL 명령을 데이터베이스에 전달합니다.
{% endraw %}