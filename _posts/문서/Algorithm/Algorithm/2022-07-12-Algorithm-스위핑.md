---
categories:
- Algorithm
date: '2022-07-12'
title: '[Algorithm] 스위핑'
---

{% raw %}
## 스위핑
`스위핑(Sweeping)`은 정렬된 요소를 1번만 쓸고 가서(Sweep) 답을 구하는 기법이다. 이 과정을 시각화하면, 수직선 레이저로 요소들을 한 방향으로 스캔하는 것과 비슷하다.

스위핑 기법을 활용하면 일반적으로 나이브한 방법보다 1단계 빠른 시간 복잡도로 해결할 수 있다.

주로 스위핑은 좌표 문제에서 활용된다.

## 설계
탐색하기 전에 요소들을 적당한 기준으로 정렬하고, 정렬된 요소들을 순차적으로 스캔해서 최종 답을 구한다. 대략적으로 표현하자면,
```
> 입력 요소<br>
B C A

> 정렬<br>
A B C

> 스캔<br>
|             |               |
A B C       A B C         A B C
|             |               |
sum = a    sum = a+b     sum = a+b+c
```

### 구성 요소
스위핑 탐색할 때는 일반적으로 다음 구성 요소을 정한다.
- 스위핑 대상? 
	- 탐색하면서 현재 위치에 들어오는 입력에 따라 변화하는 대상이다. 위의 레이저 스캔에서, 어떤 한 시점에서 레이저가 이 대상의 현재 상태라고 보면 된다.
- 스위핑 방향?
	- 레이저의 이동 방향으로, 어떤 요소/변수를 정렬하고 해당 요소/변수의 처음과 끝 방향으로 순차 탐색한다. 주로 입력 요소를 정렬하거나, x/y 좌표 중에서 1개를 선택해 오름차순으로 탐색하는 것이 일반적이다.
- 스위핑 결과?
	- 스위핑 대상을 탐색할 때, 매 위치마다 연산을 통해 얻는 결과. 이 결과를 누적하면 탐색의 최종 답이 된다.

탐색에서 매 위치마다 스위핑 대상에 변화를 가하거나 결과를 구할 때, 일반적으로 다음 연산을 사용한다.
- 현재 위치에서 변화량
	- 레이저로 움직이면서 만나는 입력 요소들, 즉 현재 위치에 해당하는 입력 요소를 가져와 연산에 활용한다. 현재 위치에서 무언가가 추가되면 변화량을 더하고, 제외되면 변화량을 빼는 것이 일반적이다. 단일 값만 사용하면 O(1) 시간이 걸리지만, 아래와 같은 구간 쿼리를 동원하면 O(log N) 시간이 걸린다.
- [x의 현재 위치, x의 끝], [(x, y1), (x, y2)] 등 구간 쿼리
	- 구간 합, 구간 최대 등에 대한 반환/업데이트가 필요한 경우가 있다. 주로 `세그먼트 트리`, `Lazy Propagation`가 활용되며, O(log N) 시간이 걸린다.

일반적으로 스위핑 탐색의 전체적인 구성은 다음과 같다.
```
x에 대해 [0, max] 스위핑 탐색 => 현재 위치 = x<br>
	1. 현재 대상을 변화하는 연산 수행 (변화량, 구간 쿼리...)
	2. 현재 위치 x의 결과 구하기
		- 최종 답에 취합
```

좌표를 스위핑할 때는, 좌표 범위 최대가 입력 요소 개수보다 커서 탐색이 오래 걸릴 수 있다. 일반적으로 `좌표 압축`을 사용해서 불필요한 위치를 정리하면 해결할 수 있다.

## 예시
### 1차원 탐색
수직선을 스캔해서 답을 구하는 유형. 좌표 왼쪽부터 오른쪽 한 방향으로 탐색한다.

선분의 합집합 길이를 구하는 `BOJ - 2170 - 선 긋기` 문제가 대표적이다. 입력 선분의 시작점에 대해 오름차순 정렬하고, 다음 선분에 대한 위치 관계에 따라 case work해서 탐색한다.
- 스위핑 대상 = 현재 선 (수직선에서 [시작, 끝] 구간으로, `투 포인터`로 표현된다)
- 스위핑 방향 = 입력 선 [시작, 끝]에서, 시작 오름차순으로 정렬
- 스위핑 결과 = 현재 선의 길이
```
- 현재 선 [lo, hi]
- 스위핑 탐색 => 입력 선 [newLo, newHi]<br>
	- newLo > hi<br>
		- 전체 합 += 현재 선 길이 // 결과 구하기
		- lo = newLo, hi = newHi // 현재 선 업데이트
	- newHi > hi<br>
		- hi = newHi // 현재 선의 끝 업데이트
```

### 2차원 탐색
2개의 변수로 구성된 요소를 탐색할 때 사용되는 유형. 변수 하나를 스위핑 방향 요소로 선택하고 정렬한 다음, 해당 변수를 따라 탐색한다.

2차원 좌표계에서 점(x, y)들에 대한 일방통행 순서쌍 경우의 수를 구하는 `BOJ - 5419 - 북서풍` 문제가 대표적이다.  두 변수를 정렬하고 한쪽 변수를 따라 스위핑을 수행하면 답을 구할 수 있다.
- 스위핑 대상 = 구간 배열 (인덱스 = y, 값 = y에서 점의 개수)
- 스위핑 방향 = 입력 점(x, y)을 다음 기준에 대해 정렬하고, 끝 → 시작 방향으로 탐색
> 1. x좌표가 증가하는 순서대로 정렬<br>
> 2. x좌표가 같다면, y좌표가 감소하는 순서대로 정렬<br>
- 스위핑 결과 = 현재 점에서 연결 가능한 왼쪽 점의 개수
	- 점은 x에 대해 오름차순 정렬되어 있으므로, 탐색할 때는 y만 고려하면 된다.
	- 구간 연산이 필요하므로 `세그먼트 트리`가 활용된다.

```
- 구간 배열 [0, N - 1] // N - 1 = 좌표 최댓값
- 스위핑 탐색 => 현재 점 = (x, y)<br>
	1. 전체 합 += [0, y]의 구간 합 // 결과 구하기
	2. 구간 배열에서 y 위치에 1을 더한다.
```

### 직사각형 합집합 (구간 합집합)
위의 2차원 탐색의 한 유형으로, 스위핑을 적용해서 직사각형의 합집합 영역을 빠르게 탐색한다. (한 위치에서 겹치는 직사각형들은 1개로 취급해서 답을 구해야 한다) 스위핑 탐색에서 직사각형의 존재 여부를 바꾸는 모서리를 주목하는 것이 핵심 아이디어다. 위의 유형과 차이점이 있다면, 스위핑 이동 기준이 입력 요소에서 변수로 옮겨갔다는 점이다.

대표적으로 직사각형 합집합의 면적을 구하는 `BOJ - 3392 - 화성 지도`가 있다.

- 스위핑 대상 = 구간 배열 (인덱스 - y, 값 - y에서 사각형의 개수)
- 스위핑 방향 = x좌표 오름차순 순서로 탐색한다.
	- 입력 요소인 직사각형(x1, y1, x2, y2)은 x에 대해 저장한다. (MAX = x, y의 최댓값)
	- rectLeft[MAX] = 현재 x가 x1인 사각형 구간 [y1, y2] 저장
	- rectRight[MAX] = 현재 x가 x2인 사각형 구간 [y1, y2] 저장
- 스위핑 결과 = [0, MAX] 구간에서 양수의 개수
	- 현재 x에서 사각형이 있는 y의 개수를 세는 것과 같다.
	- 구간 연산/업데이트가 필요하므로 `세그먼트 트리`, `Lazy Propagation`가 활용된다.

스위핑 대상은 매 위치마다 다음 연산에 따라 변화한다.
> x1을 가지는 직사각형을 만나면 [y1, y2] 구간에 1을 더한다.<br>
> x2을 가지는 직사각형을 만나면 [y1, y2] 구간에 1을 뺀다.<br>

```
- 구간 배열 [0, MAX]
- 스위핑 탐색 => 현재 위치 = x<br>
	1. rectLeft[x]의 모든 사각형을 반영한다. => 현재 사각형 [y1, y2]<br>
		- [y1, y2] 구간에 1을 더한다.
	2. rectRight[x]의 모든 사각형을 반영한다. => 현재 사각형 [y1, y2]<br>
		- [y1, y2] 구간에 1을 뺀다.
	3. 최종 답 += [0, MAX] 구간에서 양수의 개수
```

※ 스위핑 결과를 구하는 쿼리에 대한 내용은 해당 문제의 설명을 참고하길 바란다.

직사각형 외에도, 범위의 시작점과 끝점을 구간에 +1/-1로 기록하는 아이디어는 구간 합집합을 다룰 때 유용하니 알아두면 좋다.

## 관련 문제
### 1차원 탐색
https://www.acmicpc.net/problem/2170<br>
https://www.acmicpc.net/problem/2836<br>
https://www.acmicpc.net/problem/16357<br>

### 2차원 탐색
https://www.acmicpc.net/problem/5419<br>
https://www.acmicpc.net/problem/17131<br>
https://www.acmicpc.net/problem/10534<br>
https://www.acmicpc.net/problem/10167<br>

### 직사각형 합집합 (구간 합집합)
https://www.acmicpc.net/problem/3392<br>
https://www.acmicpc.net/problem/11012<br>
https://www.acmicpc.net/problem/2809<br>

## 참고
https://byeo.tistory.com/entry/%EC%8A%A4%EC%9C%84%ED%95%91-Sweeping<br>
https://blogshine.tistory.com/120<br>
{% endraw %}