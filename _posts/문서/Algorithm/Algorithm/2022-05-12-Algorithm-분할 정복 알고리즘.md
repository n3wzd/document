---
categories:
- Algorithm
date: '2022-05-12'
title: '[Algorithm] 분할 정복 알고리즘'
---

{% raw %}
## 분할 정복
분할 정복(Divide and Conquer)은 전체 문제를 동일한 유형의 여러 부분 문제로 나눠서 해결하고, 부분 문제의 해답을 취합해 전체 해답을 구하는 방법이다. 

- 분할: 문제를 동일한 유형의 여러 부분 문제로 나눈다.
- 정복: 최소 단위의 하위 문제를 해결하여 정복한다.
- 조합: 부분 문제의 해답을 취합해 전체 해답을 구한다.

여러 알고리즘이 분할 정복을 기반으로 하며(ex. `DP`), 분할 정복 방법만으로도 문제 해결에 활용될 수 있다. (ex. 합병 정렬(merge sort))

## 접근법
※ 이하 설명은 `DP`에도 적용된다. 또한 부분 문제들은 트리로 표현 가능하므로 `그래프`하고 관련이 있다.

이 방법의 가장 중요한 부분은 **분할 정복 함수(점화식)** 설계이다. 부분 문제를 식별하는 현재 상태를 정의하고, 문제를 **동일 유형의 세부 문제**로 나눌 수 있어야 하며, 이 문제의 답을 적절히 취합해서 전체 답을 구할 수 있어야 한다.

즉, 현재 문제의 입력과 출력, 다시 말해 **현재 상태, 계산 결과**를 명확하게 정의하는 것이 중요하다.
```
Problem(A, B, C ...)
	...
	return result
```

현재 상태를 정의할 때 핵심 기준은 **1-모든 현재 문제에 대해 계산에 필수인 인자인가(=현재 문제의 계산에 영향을 주는가), 2-기존 인자로 유도할 수 없는 생략이 불가능한 인자인가**이다. 현재 상태가 (A, B)일 때, B의 값에 따라 계산 값이 달라질 수 있는 현재 문제가 존재한다면 B는 현재 상태에 포함되어야 한다. 반대로, B의 값과 관계없이 항상 모든 현재 문제의 결과가 동일하면 B를 현재 상태에 제외해도 된다.

만약 현재 상태가 동일하면 결과가 동일하므로 같은 문제라고 볼 수 있다. 이 점을 활용해서 중복 계산을 피하는 기법이 `DP`이다.

예를 들어 부분 문제의 현재 상태를 (현재 도시, 이전에 방문한 도시 목록), 계산 결과는 경로의 최소 비용이라고 하자. 현재 도시가 같아도, 이전에 방문한 도시에 따라 현재 문제의 출력이 달라질 수 있다면, 이전 도시들의 방문도 현재 상태에 포함되어야 한다. (역으로 이전 도시 방문 목록이 같으면, 같은 문제라고 볼 수 있다.) 그러나 이전 도시를 방문하는 순서는 현재 문제 탐색에 영향을 주지 않으므로, 이전 도시 방문 순서는 기록하지 않아도 된다.

점화식을 발견하기 위해 여러 가지를 시도해볼 수 있다.
- 초항을 포함해 일일이 전개해서 규칙성을 발견해본다. (ex. F(0), F(1), F(2) ... )
	- 완전탐색 관점으로 가능한 모든 경우를 나열해본다.
	- 부분 문제들을 트리 구조로 전개해본다.
- 수식(recursive formula) 관점으로, 현재 문제와 이전 문제간의 관계를 생각해본다.
	- 이전 문제의 답으로 현재 문제의 답을 구할 수 있는 방법? => F(n-1), F(n-2) ... 를 어떤 방법으로 조합하면 F(n)를 구할 수 있을까?
	- 현재 상태에서 가능한 모든 분기를 조사한다.
		- ex. n번째 동전을 선택했을 때, 그리고 선택하지 않았을 때 => F(n-1, k-1) + F(n-1, k)
		- 파스칼 삼각형도 현재 원소 선택 vs 선택 안함 관점으로 볼 수 있다.
- 순차 탐색 대상을 현재 상태로 정의한다. => 현재 정점, 아이템의 번호(=지금까지 살펴본 아이템의 개수)
- 현재 비용, 최대 한도 등 어떠한 한계치 자체도 현재 탐색에 영향을 주므로 현재 상태가 될 수 있다.
	- ex. 냅색 문제(Knapsack Problem), 벨만-포드 알고리즘
- 탐색 범위를 부분 문제의 상태로 할 수 있다. => 대상 목록의 처음과 끝을 `투 포인터`로 하고, 탐색 범위를 분할해서 동일한 세부 문제로 나눈다.
	- ex. 파일 1, 2 ... N개를 조사할 때, 1<sub>mid, mid+1</sub>N을 조사하는 2개 문제로 분할
- 2개의 대상을 탐색할 때, 각 대상의 현재 위치를 가리키는 `투 포인터`를 현재 상태로 정의하는 경우
	- ex. LCS 문제: 2개의 문자열의 현재 탐색 위치를 현재 상태로 한다.

ex. 피보나치 수열
> 1 1 2 3 5 8 13 ...<br>
> F(N) = F(N-1) + F(N-2)<br>

현재 문제를 동일한 유형의 이전 문제 2개로 분할한다. 그리고 이 세부 문제에서 계산한 해를 합해서 현재 문제의 답을 구할 수 있다.

ex. 경우의 수
일직선 배열에서 이웃하지 않는 원소를 선택하는 경우의 수는?
> F(n-2, k-1) + F(n-1, k)<br>

현재 상태는 (원소 번호, 선택 가능 개수)이고, 계산 결과는 경우의 수다. 현재 원소의 선택 유무 분기로 문제를 분할하며, 이 방법으로 백트래킹으로 일일이 조사하는 것보다 빠르게 경우의 수를 구할 수 있다.

Tip.
분할 함수의 인자는 부분 문제의 현재 상태를 포함해야 한다. 따라서 대부분 분할 함수의 인자는 현재 상태와 일치한다. 그러나 계산 단축 및 편의를 위해 현재 상태로 유도 가능한 값을 분할 함수의 인자로 추가하기도 한다.

ex. 현재 상태가 (배치한 사람 목록)이고, 현재 문제에서 일의 번호가 계산에 사용된다. 일의 번호는 배치한 사람 목록에서 1의 개수로 구할 수 있어 생략 가능하나, 구하려면 선형 탐색 시간 비용이 있는 등 불편한 면이 있다. 이때 일의 번호를 분할 함수의 인자로 추가해두면 계산 과정이 단축되므로 편리하다. (현재 상태에 추가된 것이 아니므로 캐시에는 일의 번호 인덱스를 추가하지 않아도 된다)

Tip2.
문제 분할을 그래프로 표현했을 때, **유한한 트리 구조** 일 때, DP를 사용할 수 있다. 자세한 내용은 `DFS/BFS` 외전 참고.

## 연관 문제
<br>https://www.acmicpc.net/problem/1992
<br>https://www.acmicpc.net/problem/1629

`DP` 편도 참고하면 좋다.

## 참고
<br>https://namu.wiki/w/%EB%B6%84%ED%95%A0%20%EC%A0%95%EB%B3%B5%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98
{% endraw %}