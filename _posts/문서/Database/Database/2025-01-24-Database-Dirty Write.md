---
categories:
- Database
date: '2025-01-24'
title: '[Database] Dirty Write'
---

{% raw %}
티 쓰기(Dirty Write)는 데이터베이스나 객체 관계 매핑(ORM)에서 변경된 데이터가 저장되었을 때, 실제로 변경된 내용만 반영하는 것이 아니라 불필요한 데이터까지 저장되는 현상을 의미합니다. 즉, 객체의 상태가 변경되면 그 객체가 연결된 데이터베이스 테이블의 모든 필드가 업데이트되는 방식입니다.

1. **객체의 상태 변경 추적**:
    - ORM은 객체를 데이터베이스 테이블과 매핑하여 객체의 상태를 추적합니다. 객체의 상태가 변경되면, ORM은 해당 객체를 "더티(Dirty)" 상태로 표시하고, 이를 저장할 때 모든 변경된 필드를 데이터베이스에 반영합니다.
2. **불필요한 업데이트**:
    - 객체의 일부 필드만 변경되었더라도, ORM은 객체 전체를 저장하려고 할 수 있습니다. 예를 들어, 객체의 일부 필드만 수정되었는데, ORM은 해당 객체의 모든 필드를 업데이트하려고 할 수 있습니다.
3. **자동으로 처리되는 경우**:
    - JPA와 같은 ORM에서는 객체의 상태가 변경되면 이를 자동으로 추적하고, `save()`, `flush()` 등을 호출하면 변경된 내용을 자동으로 데이터베이스에 반영합니다. 이때 객체의 상태가 "더티"로 표시되며, 해당 객체의 모든 변경 사항이 데이터베이스에 반영됩니다.

예를 들어, `User` 객체가 있고 이 객체의 `name`과 `email` 필드가 있습니다. 만약 `name`만 수정되었다면, `email`은 변경되지 않았지만 ORM은 객체를 저장할 때 `name`과 `email` 모두를 업데이트하려고 할 수 있습니다. 이렇게 되면 `email` 필드는 실제로 변경되지 않았음에도 불구하고 불필요하게 데이터베이스에 저장됩니다. 이 현상이 바로 더티 쓰기니다.

**장점**:
- **간편함**: ORM이 객체의 상태를 자동으로 추적하고, 변경된 내용을 데이터베이스에 반영하므로 개발자가 일일이 SQL을 작성할 필요가 없습니다.
- **자동화**: 객체의 상태가 변경되면 ORM이 이를 자동으로 반영하므로 개발자가 수동으로 업데이트 쿼리를 작성할 필요가 없습니다.

**단점**:
- **불필요한 업데이트**: 객체의 일부 필드만 변경되었는데, 전체 객체가 업데이트되므로 불필요한 데이터베이스 쓰기 작업이 발생할 수 있습니다. 이는 성능 저하를 초래할 수 있습니다.
- **성능 문제**: 객체가 매우 크거나, 많은 필드를 가지고 있는 경우, 불필요한 필드까지 업데이트되면 성능에 부정적인 영향을 미칠 수 있습니다.
{% endraw %}