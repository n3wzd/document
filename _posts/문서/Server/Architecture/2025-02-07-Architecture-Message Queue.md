---
categories:
- Architecture
date: '2025-02-07'
title: '[Architecture] Message Queue'
---

{% raw %}
메시지 큐는 **비동기적 메시지 전달 시스템**으로, 여러 시스템이나 컴포넌트 간의 **메시지를 저장하고 전달하는 역할**을 합니다. 이를 통해 프로세스 간 통신(IPC)을 간소화하고, 시스템 간의 **비동기적 상호작용**을 가능하게 합니다.

메시지 큐는 큐(queue)라는 자료구조를 사용합니다. 큐는 **선입선출(FIFO, First-In-First-Out)** 방식을 따르기 때문에, 먼저 들어온 메시지가 먼저 처리됩니다.

- **Producer (생산자)**는 메시지를 큐에 전송하고,
- **Consumer (소비자)**는 큐에서 메시지를 받아 처리합니다.

이 과정은 **비동기적**이므로, 생산자는 큐에 메시지를 보내고 즉시 작업을 종료할 수 있으며, 소비자는 그 후에 메시지를 비동기적으로 처리합니다.

### 동작
5. **Producer**는 메시지를 큐에 넣습니다.
6. 큐에 들어온 메시지는 **Consumer**가 처리할 때까지 대기합니다.
7. **Consumer**는 큐에서 메시지를 가져와 처리하고, 처리가 끝나면 큐에서 메시지를 제거합니다.

### 특성
8. **비동기 처리**
    - 생산자와 소비자는 독립적으로 동작합니다. 소비자가 메시지를 처리하는 동안 생산자는 다른 작업을 할 수 있습니다.
9. **내구성(Persistence)**
    - 큐에 저장된 메시지는 시스템 장애가 발생하더라도 안전하게 보존될 수 있습니다. 이를 통해 **메시지 손실을 방지**합니다.
10. **스케일링**
    - 메시지 큐는 다수의 소비자(Consumer)를 추가해 **수평 확장**할 수 있어, 많은 메시지를 동시에 처리할 수 있습니다.
11. **응답 시간 개선**
    - 생산자는 메시지를 큐에 전송한 후 즉시 응답할 수 있으므로 **응답 시간을 단축**할 수 있습니다.
12. **비동기적 통신**
    - 프로세스 간 직접적인 연결을 피하고 **비동기적으로 메시지를 전달**하므로, 시스템 간 결합도가 낮아집니다.

### 활용 예시
#### 전자상거래
전자상거래 플랫폼은 트랜잭션과 사용자 요청을 효율적으로 처리하기 위해 메시지 큐를 사용합니다. 특히 주문 처리 시스템에서 **메시지 큐**는 주문을 비동기적으로 처리하고, 상품 재고를 관리하는 데 중요한 역할을 합니다.

- **Amazon**, **eBay**와 같은 대형 전자상거래 플랫폼은 주문 처리와 결제 시스템에서 **SQS**(Amazon Simple Queue Service)를 사용하여 트래픽을 분산시키고 주문을 안정적으로 처리합니다.
- 사용자 요청이 많아질 때, 메시지 큐를 사용해 주문을 대기열에 넣고, 순차적으로 처리합니다.

#### 금융 서비스
금융 서비스에서는 실시간 거래 처리와 이벤트 기반 시스템을 운영하기 위해 메시지 큐를 사용합니다. 이를 통해 거래 정보나 알림을 비동기적으로 처리하고, 시스템 간의 통합을 원활하게 유지합니다.

- **PayPal**이나 **Stripe**와 같은 결제 서비스는 거래 이벤트를 메시지 큐를 통해 처리하여, 실시간 트랜잭션을 안정적으로 관리합니다.
- 메시지 큐는 비동기적으로 결제 처리, 트랜잭션 기록 업데이트 등을 수행하여 트래픽이 몰리는 상황에서의 성능을 보장합니다.

#### 클라우드 서비스와 마이크로서비스 아키텍처
마이크로서비스 아키텍처에서는 서비스 간 통신을 메시지 큐로 처리하는 것이 일반적입니다. 각 서비스가 독립적으로 동작하고, 서로 간에 메시지를 주고받을 수 있도록 설계됩니다.

- **Netflix**와 **Spotify**는 마이크로서비스 아키텍처를 기반으로 서비스를 운영하며, **Kafka**를 활용하여 서비스 간의 데이터 전송과 이벤트 처리를 관리합니다.
- **Uber**는 **Kafka**와 **Redis**를 사용하여 사용자 요청을 비동기적으로 처리하고, 실시간 데이터를 수집 및 분석합니다.

### 활용 예제: 게임 서버에서 유저 경험치 처리
멀티플레이 게임에서 유저가 몬스터를 처치하면 경험치(EXP)를 획득합니다. 하지만, **경험치 처리를 API 요청마다 즉시 수행하면 서버 부하가 증가**할 수 있습니다. 따라서, **메시지 큐를 사용하여 비동기적으로 경험치를 처리**하면 성능을 최적화할 수 있습니다.

- **서버 A (유저 활동 집계 서버)**: 유저의 게임 이벤트를 감지하고 메시지를 메시지 큐로 보냄.
- **메시지 큐 (Kafka or RabbitMQ)**: 경험치 증가 요청을 큐에 저장하고, 소비자(Consumer)에게 전달.
- **서버 B (게임 서버)**: 큐에서 메시지를 받아 경험치를 계산하고, DB 업데이트.

#### 흐름도
13. 유저가 몬스터를 처치하면 유저 활동 집계 서버(서버 A)는 `EXP 증가 요청`을 메시지 큐에 보냄.
14. 메시지 큐는 해당 요청을 대기열에 저장.
15. 게임 서버(서버 B)가 큐에서 메시지를 가져와 경험치를 계산 후 DB에 반영.
16. 필요할 경우, 경험치 증가 결과를 서버 A로 전송하여 클라이언트에게 UI 업데이트.

#### 구조
17. **서버 A와 B의 역할 분담**:
    - **서버 A**는 클라이언트와의 상호작용을 담당하며, 경험치와 같은 이벤트를 처리합니다. 하지만 실제 유저 데이터는 서버 A에 저장되지 않고, **서버 B**에 저장됩니다.
    - **서버 B**는 유저 데이터와 관련된 모든 작업을 처리하고, **데이터베이스**와 연결되어 유저의 경험치와 같은 데이터를 업데이트합니다.
18. **Kafka의 역할**:
    - Kafka는 서버 간 **메시지 큐** 역할을 하며, 서버 A에서 발생한 이벤트를 서버 B로 전달하는 데 사용됩니다. 클라이언트는 Kafka와 직접적으로 통신하지 않으며, Kafka는 서버 A와 서버 B 간의 **비동기 통신**을 가능하게 합니다.
    - Kafka를 통해 경험치와 같은 데이터 변경 사항을 **비동기적으로 처리**하며, 서버 간 독립적으로 데이터를 처리할 수 있습니다.
19. **비동기 처리 및 Lazy 업데이트**:
    - **비동기 처리** 덕분에 서버 A는 클라이언트의 요청을 즉시 처리하고, 서버 B는 Kafka를 통해 받은 이벤트를 백그라운드에서 처리하여 서버의 부하를 줄입니다.
    - 데이터 업데이트가 즉시 이루어지지 않지만, **Lazy 업데이트** 방식으로 클라이언트가 데이터를 요청할 때 최신 데이터로 갱신됩니다.
20. **데이터 안정성**:
    - Kafka를 통해 **메시지의 안정적인 전송**이 이루어지므로, 데이터가 손실되지 않도록 보장됩니다. 또한, 서버 A에서 클라이언트의 요청에 대한 빠른 응답을 보낸 후에도 Kafka를 통해 데이터를 비동기적으로 처리하여, 최종적으로 서버 B에서 업데이트됩니다.
21. **DB 통합**:
    - 서버 A가 유저 데이터를 별도로 관리하지 않고 서버 B와 DB를 통합하여, **서버 B**에서 모든 유저 데이터를 관리합니다. 이는 DB 분리를 통해 발생할 수 있는 불편함을 해소하고, 데이터 일관성을 보장합니다.

이 구조는 게임 서버와 같은 높은 트래픽을 처리해야 하는 시스템에서 성능을 최적화하고, 확장성과 안정성을 높이기 위한 좋은 접근 방식입니다.

#### 코드 예시
**서버 A (유저 활동 집계 서버) – 경험치 메시지 전송**
```java
@RestController
@RequestMapping("/game")
public class GameController {

    private final KafkaTemplate<String, String> kafkaTemplate;<br>

    public GameController(KafkaTemplate<String, String> kafkaTemplate) {<br>
        this.kafkaTemplate = kafkaTemplate;
    }

    @PostMapping("/gain-exp")
    public ResponseEntity<String> gainExp(@RequestBody ExpEvent event) {<br>
        String message = new ObjectMapper().writeValueAsString(event);
        kafkaTemplate.send("exp-topic", message); // Kafka로 메시지 전송
        return ResponseEntity.ok("EXP 증가 이벤트 전송 완료");
    }
}
```

- 유저가 몬스터를 처치하면 **`/game/gain-exp` API**를 호출.
- 경험치 증가 이벤트(`ExpEvent`)를 Kafka의 **`exp-topic`**에 메시지로 전송.

---

 **서버 B (게임 서버) – 경험치 메시지 소비 및 DB 업데이트**

```java
@Service
public class ExpConsumer {

    private final UserExpService userExpService;

    public ExpConsumer(UserExpService userExpService) {
        this.userExpService = userExpService;
    }

    @KafkaListener(topics = "exp-topic", groupId = "exp-group")
    public void consumeExp(String message) {
        ExpEvent event = new ObjectMapper().readValue(message, ExpEvent.class);
        userExpService.updateUserExp(event.getUserId(), event.getExp());
    }
}
```

- `exp-topic`에 저장된 경험치 메시지를 **실시간으로 소비(consume)**.
- `userExpService.updateUserExp()`를 호출하여 DB의 유저 경험치를 업데이트.
{% endraw %}