---
categories:
- Kafka
date: '2025-02-08'
title: '[Kafka] 2. Basic'
---

{% raw %}
## 구성
Kafka는 분산 메시징 시스템으로, **대용량의 데이터 스트리밍**과 **실시간 데이터 처리**를 지원하는 시스템입니다.

### Producer (생산자)
- **Producer**는 Kafka에 메시지를 보내는 클라이언트입니다. 생산자는 Kafka의 특정 **토픽(Topic)**에 데이터를 전송합니다.
- Producer는 메시지를 보낼 때 메시지가 **어떤 파티션**에 저장될지 결정하는데, 기본적으로 Kafka는 메시지를 **파티션 단위**로 분배합니다.
- 메시지 전송 시, **키**가 있으면 Kafka는 동일한 키를 가진 메시지를 동일한 파티션으로 보냅니다.

### Consumer (소비자)
- **Consumer**는 Kafka에서 메시지를 소비하는 클라이언트입니다. 소비자는 특정 **토픽**에 대한 데이터를 읽습니다.

### Consumer Group (소비자 그룹)
- **Consumer Group**은 Kafka에서 메시지를 **동시 처리하는 여러 개의 컨슈머(Consumer)들**을 그룹화한 단위입니다.
- 이 그룹은 **하나의 논리적 소비자**처럼 동작하여, 같은 메시지를 여러 컨슈머가 중복해서 처리하지 않도록 합니다. 즉, 여러 개의 컨슈머가 있을 때 **메시지를 나누어 처리**하는 방식입니다.
- 컨슈머 그룹은 **병렬 처리를 최적화**하는 용도로, **토픽**과 **독립적인 개념**입니다. 따라서 하나의 컨슈머 그룹이 여러 토픽을 구독하고 처리하는 것이 가능합니다. (단, 권장되는 방식은 아닙니다. 각 토픽마다 별도의 컨슈머 그룹을 사용하는 방법이 관리와 확장성 측면에서 유리합니다.)

### Topic (토픽)
- **Topic**은 Kafka에서 메시지를 저장하는 **논리적** 카테고리입니다.
- 각 토픽은 **여러 파티션**을 가질 수 있습니다. 파티션을 통해 데이터를 분산하여 저장하고, **병렬 처리**할 수 있게 됩니다.

### Partition (파티션)
- **Partition**은 **토픽의 물리적 분할 단위**로, 여러 메시지를 저장합니다.
- 각 파티션은 **순차적인 로그**를 가지고 있으며,  **메시지는 파티션 내에서 순차적**으로 처리됩니다.
- Kafka는 파티션을 여러 개의 **브로커**에 분산시켜 저장하여 **확장성**과 **고가용성**을 제공합니다.

예시:
- **Topic: "orders"**
	- **Partition 0**:
	    - 메시지 1: 주문 1 (Offset 0)
	    - 메시지 2: 주문 2 (Offset 1)
	    - 메시지 3: 주문 3 (Offset 2)
	    - 메시지 4: 주문 4 (Offset 3)
	- **Partition 1**:
		- 메시지 1: 주문 5 (Offset 0)
		- 메시지 2: 주문 6 (Offset 1)

### Message (메시지)
- **Message**는 **Producer가 생성하고 Consumer가 처리하는 데이터 단위**입니다.
- Kafka에서 메시지는 **불변**하며, 한번 저장된 메시지는 변경되지 않습니다.
- 메시지는 **로그**처럼 저장되어, 이후 시간에 따라 **다시 읽히거나** 다른 시스템에서 처리될 수 있습니다.

Kafka에서 **메시지**는 주로 다음과 같은 구조로 구성됩니다:
1. **Key** (선택적)
    - 메시지의 **식별자** 또는 **구분자**로 사용될 수 있습니다. 또한 메시지끼리 **순서를 보장**하려면 Key가 필수입니다.
    - 같은 **Key**를 가진 메시지는 항상 같은 파티션에 저장됩니다. Kafka에서 **Key**가 있는 메시지가 **어느 파티션**에 저장될지는 Kafka의 **파티셔너**에 의해 결정됩니다.
	- **기본 파티셔너**는 메시지의 **Key**를 해시값으로 변환하여 해당 파티션에 메시지를 할당합니다. 예를 들어, 메시지의 Key가 "user_id"라면, 이 **Key** 값을 해시한 결과에 따라 특정 파티션으로 메시지가 보내집니다.
2. **Value**
    - 메시지의 실제 **데이터** 부분입니다. 예를 들어, **주문 정보**, **채팅 메시지**, **로그 데이터** 등 실제 처리하려는 데이터가 포함됩니다.
3. **Timestamp**
    - 메시지가 생성된 시간을 나타냅니다. 이 정보는 주로 데이터 처리 시간에 중요한 역할을 합니다.
4. **Headers** (선택적)
    - 메시지에 추가적인 **메타데이터**를 포함할 수 있습니다. 예를 들어, 메시지의 **발송처**, **우선순위**, **분류 정보** 등을 포함할 수 있습니다.

예시(주문 정보 메시지):
- **Key**: "user123"
- **Value**: `{ "order_id": "001", "product": "Laptop", "amount": 1200 }`
- **Timestamp**: `2025-02-09T12:00:00Z`
- **Headers**: `{ "priority": "high", "source": "website" }`

### Offset (오프셋)
- 메시지를 읽을 때 **Offset**을 기록하여, 소비자는 **마지막으로 읽은 메시지의 위치를 추적**하고, 재시작 시 같은 위치에서 메시지를 읽을 수 있습니다.
- 오프셋은 **소비자 그룹 단위로 구별**됩니다. 즉, 소비자 그룹 별로 오프셋이 다릅니다.

### Commit (커밋)
- **Commit**은 **오프셋을 저장**하는 작업을 의미합니다.
- 커밋을 통해 소비자는 **어떤 메시지까지 읽었는지** Kafka에 기록하게 되어, 다음에 다시 메시지를 읽을 때 마지막으로 처리한 메시지 이후의 메시지부터 읽을 수 있도록 합니다.
- 커밋되지 않은 메시지는 다시 처리될 수 있습니다. 메시지 처리 실패시 커밋하지 않음으로써 재처리를 유도할 수 있습니다.

커밋 종류:
- **자동 커밋 (Auto Commit)**:
    - **메시지 처리 후에 커밋을 자동으로 수행**하는 방식입니다.
    - 메시지가 처리된 후 **소비자 메서드 실행이 정상적으로 끝날 때** 커밋이 발생합니다.
    - Kafka 내부적으로 실패하거나 소비자 메서드에서 예외가 발생하면 커밋이 되지 않습니다.
- **수동 커밋 (Manual Commit)**:
    - 소비자가 메시지를 처리한 후에 명시적으로 오프셋을 커밋할 수 있습니다.

### Broker (브로커)
- **Broker**는 Kafka 클러스터의 서버입니다. **하나의 Kafka 클러스터는 여러 개의 브로커**로 구성됩니다.
- 각 브로커는 토픽의 일부 파티션을 관리하며, 여러 브로커가 서로 협력하여 메시지를 분산하고 복제합니다.

### Zookeeper
- **Zookeeper**는 Kafka 클러스터의 **메타데이터 관리**와 **클러스터 상태**를 관리하는 역할을 합니다. Zookeeper는 Kafka의 **클러스터 관리**, **파티션 리더 선출**, **브로커의 상태 확인** 등을 담당합니다.

## 동작
### 1. 메시지 전송 (Producer → Kafka Broker)
- **Producer**는 Kafka의 **토픽**에 메시지를 보냅니다. 메시지는 각 **파티션**에 분배되어 저장됩니다.
- 메시지가 파티션에 어떻게 배분될지는 **키**와 **파티션 수**에 따라 결정됩니다. 기본적으로 Kafka는 **키를 해시하여** 동일한 키를 가진 메시지를 같은 파티션에 배분하려고 합니다.

### 2. 메시지 저장 (Kafka Broker)
- 각 Kafka 브로커는 **디스크에 메시지를 저장**합니다. 메시지는 **순차적인 로그**로 기록되며, **시간 순서대로 저장**됩니다.
- Kafka는 메시지를 **디스크에 영속적으로 저장**하는 방식으로, **내구성**과 **고가용성**을 보장합니다.
- 메시지는 일정 시간이 지나거나 특정 조건에 따라 **삭제되거나 압축**될 수 있습니다.

### 3. 메시지 복제 (Replication)
- Kafka는 **내구성**과 **고가용성**을 보장하기 위해 **메시지 복제**를 사용합니다. 각 파티션은 여러 **복제**를 가질 수 있으며, 레플리카는 다른 브로커에 분산됩니다.
- Kafka는 **리더-팔로워 모델**을 사용합니다. 하나의 파티션은 **리더**를 가지고 있으며, 다른 브로커들은 이 리더의 복사본인 **팔로워** 역할을 합니다. 만약 리더 브로커가 실패하면, 팔로워 중 하나가 자동으로 리더 역할을 맡습니다.

### 4. 메시지 소비 (Kafka Consumer)
- **Consumer**는 Kafka의 **토픽**에서 메시지를 읽습니다. 메시지는 파티션을 따라 **순차적**으로 처리되며, **오프셋**을 기준으로 읽습니다.
- Kafka에서는 각 **Consumer Group**이 각각의 파티션을 읽을 수 있도록 분배합니다. 이렇게 하면 **파티션**이 여러 소비자에게 분배되어 병렬로 데이터를 처리할 수 있습니다.

### 5. 메시지 삭제
- 메시지는 **소비된 후에도 설정된 retention 정책에 의해 삭제되지 않으며**, 지정된 **보존 기간**이나 **크기 조건**이 충족될 때 삭제됩니다. 이 시점이 지나기 전까지는 다른 클라이언트가 여전히 메시지를 읽을 수 있습니다.
- Kafka에서 **파티션 데이터가 삭제**되면, **그 파티션의 복제본**도 **모든 브로커에서 동시에 삭제**됩니다.
{% endraw %}