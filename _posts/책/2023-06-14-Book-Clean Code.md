---
categories:
- Book
date: '2023-06-14'
title: '[Book] Clean Code'
---

{% raw %}
## 1. 깨끗한 코드
### 나쁜 코드의 특징
코드는 요구사항을 명시한 결과물이며, 나쁜 코드의 특징은 다음과 같습니다.

- 새로운 요구사항을 반영하기 어렵거나 변경이 어렵습니다.
- 시간이 지날수록 생산성이 떨어집니다.
- 나쁜 코드는 전파되어 다른 코드에도 영향을 미칩니다.

나쁜 코드를 작성하는 이유는 주로 현재 단계를 빨리 완료하기 위함이지만, 다음 단계부터는 작업 속도가 느려지게 됩니다.

### 깨끗한 코드의 특징
깨끗한 코드의 특징은 다음과 같습니다.

- 낮은 의존성, 명확한 오류처리, 간결하고 명확한 기능 단위로 작성됩니다.
- 가독성이 뛰어나며 다음 동작을 예측할 수 있게 단순하고 명확합니다.
- 변경이 용이하고 충분한 테스트 케이스를 가지고 있습니다.
- 세부 사항까지 고려되었고 더 이상 수정할 부분이 없습니다.
- 간결하고 단순한 추상화를 제공하며, 예상치 못한 동작이 없습니다.

코드가 명확하면 새로운 코드 작성이 용이해집니다. 따라서 코드를 작성할 때도 코드를 읽는 것은 중요합니다.

### 보이스카우트 규칙
> 캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나야 합니다.<br>

- 코드에 접근할 때마다 더 깨끗한 코드로 업그레이드 합니다.
- 시간이 지날수록 코드가 지속적으로 깨끗해집니다.

## 2. 의미 있는 이름
> 대상을 가장 잘 설명하는 최소 길이의 이름을 생각합니다.<br>

- 의도를 분명하고 오해 없이 설명해야 합니다.
- 구현보다 추상적인 이름을 사용합니다.
- 넓은 범위를 커버할수록 긴 이름을 사용합니다.
- 이름은 특정 언어에 종속적이지 않아야 합니다.
- 변수와 클래스명은 명사, 메소드 명은 동사나 형용사가 적합합니다.
- 이름마다 일관성이 있어야 합니다. (예: 차 클래스를 ACar, BCar 사용시 CMobile 사용은 피합니다.)

## 3. 함수
>함수는 최소의 크기로 1가지 일만 수행합니다.

- 함수는 1가지 일만 해야 합니다.
	- 일이 1개인 것은 더 이상 분할할 필요성이 없음을 의미합니다. (최소의 추상 단위)
	- 정해진 일 외의 작업은 하지 않습니다.
	- 반복되는 내용이 보이면 분리 가능성을 의심합니다.
- 함수의 크기는 작을수록 좋습니다.
	- 크기가 작을수록 분리 가능성이 낮아지고 이해하기도 쉽습니다.
- 인수는 적을수록 좋습니다.
	- 출력 인수는 사용하지 않습니다. (출력 인수: 인수로 출력 대상을 제공)

## 4. 주석
> 주석은 코드를 부연설명하는 최후의 수단입니다.<br>

- 주석도 유지보수 대상에 포함됩니다.

### 좋은 주석
- 명료하고 요약된 정보를 표시하며, 의도를 정확히 설명하는 주석
- 강조 용도 주석
- TODO 주석 (앞으로 할일)

### 나쁜 주석
- 설명이 불충분하고 오해의 소지가 있는 주석
- 중복된 정보를 표시하는 주석
- 주석으로 처리된 코드
	- 되도록 버전 관리 시스템을 이용합니다.

## 5. 형식 맞추기
> 코드 자체만으로 깔끔하고 일관된 인상을 제공해야 합니다.<br>

- 모든 코드가 일정한 스타일을 유지해야 합니다. (형식적 일관성)
- 한 파일에서 코드의 길이는 작을수록 좋습니다.
- 빈 행으로 작업 단위를 시각적으로 분할합니다.
- 공백으로 개념의 밀집도를 구분합니다.
- 들여쓰기로 범위 계층을 구분합니다.
- 코드의 가로 길이는 작을수록 좋습니다.
- 서로 연관된 코드는 수직 거리가 가까워야 합니다. (세로 밀집도 높음)
	- 변수는 사용 위치의 근처에서 선언합니다.
	- 연관된 함수는 가까이 배치합니다.

## 6. 객체와 자료구조
> 새로운 자료 타입이 필요하면 객체, 새로운 동작이 필요하면 자료 구조를 선택합니다.<br>

- 객체와 자료 구조는 상반된 개념입니다.
- 새로운 클래스 추가가 필요하면 객체 지향, 새로운 함수가 필요하면 자료 구조가 적합합니다.

### 객체
- 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개합니다. (객체 지향)
- 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽습니다.
- 새로운 함수를 추가하기 어렵습니다.
- 구현이 숨겨져 있습니다.
- 사용자는 주어진 API로 자료를 조작합니다.

```
public class Point {
	double getX();
	double getY();
	void setCartesian(double x, double y);
	double getR();
	double getTheta();
	void setPolar(double r, double theta)
}
```

### 자료 구조
- 자료를 그대로 공개하며 별다른 함수는 제공하지 않습니다. (절차 지향)
- 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽습니다.
- 새로운 자료 타입을 추가하기 어렵습니다.
- 구현을 외부에서 확인 가능합니다.
- 사용자는 자료를 자유롭게 조작할 수 있습니다.

```
public class Point {
	public double x;
	public double y;
}
```

## 7. 오류 처리
> 예외 처리 구문과 예외 클래스를 사용합니다.<br>

- 오류 처리는 예외 처리 구문(try-catch-fianlly)을 사용합니다.
- 예외를 전문으로 처리하는 예외 클래스를 정의합니다.
	- 각 모듈마다 중복된 예외 처리를 예외 클래스로 묶습니다.
- 설계 논리에서 발생하는 특수 상황은 예외 처리보단 설계 내에서 정의합니다.

```
LocalPort port = new LocalPort(12);
try {
	port.open();
} catch (PortDeviceFailure e) {
	reportError(e);
} finally {
	...
}
```

```
public class LocalPort {
	private ACMEPort innerPort;

	public LocalPort(int portNumber) {
		innerPort = new ACMEPort(portNumber);
	}

	public void open() {
		try {
			innerPort.open();
		} catch (DeviceResponseException e) {
			throw new PortDeviceFailure(e);
		} catch (ATM1212UnlockedException e) {
			throw new PortDeviceFailure(e);
		} catch (GMXError e) {
			throw new PortDeviceFailure(e);
		}
		...
	}
}
```

## 8. 경계
> 경계에 위치하는 코드는 인터페이스를 통해 분리합니다.<br>

- 외부 코드의 내부는 모른다고 가정합니다.
- 테스트를 통해 외부 코드의 사용법을 분석합니다.
- 경계 인터페이스를 만들어 외부 코드 API를 분리합니다.
	- 외부 코드 사용을 한곳에 분리했기에 외부 코드가 변경되면 경계 부분만 수정하면 됩니다.

```
Data BoundaryInterface(data1) {
	Data data2= ExternalAPI(data1);
	...
	return data2;
}
```

## 9. 단위 테스트
> 테스트 코드도 깨끗하게 유지합니다.<br>

- 테스트 코드도 중요하며, 깨끗하게 유지합니다.
- 테스트 코드가 있다면 실제 코드 변경도 쉬워집니다.
- 실제 코드가 변경되면 테스트 코드도 변경되어야 합니다.
- 테스트 코드의 표준과 실제 코드의 표준은 다릅니다.
	- 테스트 코드는 실제 코드만큼 효율적이지 않아도 됩니다.
- 테스트 함수마다 한 개념만 테스트합니다.
- 경계 조건과 버그 주변을 집중 테스트합니다.

### F.I.R.S.T.
- **Fast**: 테스트는 빨라야 합니다.
- **Independent**: 각 테스트는 서로 독립적입니다.
- **Repeatable**: 테스트는 환경 무관하게 반복 가능해야 합니다.
- **Self-Validating**: 테스트 코드가 스스로 결과를 분석해서 통과 여부를 판정해야 합니다.
- **Timely**: 테스트 코드는 적시에 작성되어야 합니다.

## 10. 클래스
> 클래스도 최소의 크기로 1가지 일만 잘해야 합니다.<br>

- 클래스의 크기는 작을수록 좋습니다.
	- 큰 클래스보단 작은 클래스 여럿으로 이뤄진 체계가 좋습니다.
- 클래스는 1개의 책임만을 가집니다. (단일 책임 원칙(SRP))
- 결합도는 낮게 유지합니다. (각 요소가 독립적이며 변경으로부터 잘 격리되어 있음)
- 응집도는 높게 유지합니다. (메서드와 변수가 서로 의존하며 논리적인 단위로 묶임)
	- 응집도가 낮으면 특정 메서드가 특정 프로퍼티만 사용하는 현상이 늘어납니다.
	- 응집도가 낮을수록 분리가 쉬워지며, 분리된 클래스는 이전 것보다 응집도가 높아집니다.
- 구현 클래스와 추상 클래스를 분리해 구현의 영향을 격리합니다.

## 11. 시스템
> 변경이 쉬운 깨끗한 시스템을 구축합니다.<br>

- 생성(설정) 영역과 사용(실행) 영역을 분리합니다.
	- 사용 영역에선 사용할 요소가 모두 생성 및 설정되었고 사용 외에는 모른다고 가정합니다.
	- 예: 사용 영역에서 생성 시점을 결정할 필요가 있다면 시점만 결정할 수 있게 합니다.
- 각 영역의 관심사를 분리합니다.
	- 최선의 시스템 구조는 객체들로 구성된 관심사 영역으로 구성됩니다. (관심사ex. UI, 보안, DB 등)
	- 서로 다른 관심사 영역은 최소의 영향을 주면서 연결됩니다.
- 처음부터 완벽한 시스템을 설계하지 않아도 됩니다.
	- SW 시스템은 극적인 변화가 가능합니다.
	- 단, 변경 가능성을 고려해 시스템은 변경 능력이 있어야 합니다.

```
Enemy getEnemy() {
	if(enemy == null)
		enemy = new Eneny(); // 생성 코드
	return enemy;
}
```

## 12. 창발성
> 깨끗하고 단순한 코드 규칙<br>

1. **모든 테스트 통과**: 목표한 대로 동작해야 합니다.
2. **중복 제거**: 중복은 추가적인 작업, 위험, 복잡도를 높입니다.
3. **의도 표현**: 이해하기 쉬운 코드로 작성합니다.
4. **통합 및 압축**: 클래스와 메서드 수는 최소로 줄입니다.

## 13. 동시성
> 동시성은 복잡하고 어렵습니다.<br>

### 동시성의 어려움
- 동시성은 성능을 항상 높여주진 않으며, 때로는 부하가 걸릴 수 있습니다.
- 동시성을 구현하면 설계가 크게 달라집니다.
- 동시성은 무엇(what)과 언제(when)를 분리하는 과정입니다.
- 동시성 버그는 확률적이며 찾기 어렵습니다.

### 동시성 방어 원칙
- 동시성 코드는 다른 코드와 분리합니다.
- 공유 자료를 최대한 줄입니다.
	- 자료의 복사본 사용을 고려해볼 수 있습니다.
- 스레드간 독립성을 유지합니다.
- 공유 객체는 메서드 1개만 사용합니다.
- 임계 영역은 최대한 줄입니다.
- 올바른 종료 코드를 구현합니다.

### 스레드 테스트
- 말이 안 되는 오류는 잠정적인 스레드 문제로 취급합니다.
- 다양한 환경, OS에서 테스트해봅니다.
- 스레드 개수를 조절해봅니다.
- 보조 코드를 추가해서 오류 가능성을 높여봅니다.
	- 일정 시간 대기 등 코드를 추가해 코드 실행 순서에 변동을 줍니다.

## 14. 기타
- 알고리즘을 이해하고 구현합니다.
- 논리적, 시간적 의존성은 명시적으로 드러냅니다.
- 코드를 적절한 곳에 배치합니다.
- 널리 알려진 자명한 상수는 숫자로 표기해도 됩니다.
- 부정 조건보다 긍정 조건을 채택합니다.
- 경계 조건(코너 케이스)을 캡슐화합니다.
	- 경계 조건은 놓히기 쉽습니다. (예: nextLevel = level + 1)
- 설정 정보는 최상위에 배치합니다.
{% endraw %}