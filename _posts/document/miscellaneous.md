# miscellaneous
## Container vs Wrapper
`Container(컨테이너)`와 `Wrapper(래퍼)`는 프로그래밍 및 소프트웨어 개발에서 사용되는 용어입니다.

이 두 용어는 모두 다른 요소들을 묶거나 감싸는 데 사용되지만, 컨테이너는 일반적으로 **여러 요소를 포함하고 있는 구조**를 가리키는 데 비해, 래퍼는 보통 **특정 요소를 감싸거나 추가적인 기능을 제공**하는 데 초점을 맞추고 있습니다.

### Container
컨테이너는 일반적으로 데이터나 객체 등을 포함하고 있는 개념으로, 다른 요소들을 담는 데 사용됩니다. 주로 데이터 구조, 클래스, 또는 관련된 기능들을 하나로 묶는 데 활용됩니다. 예를 들어, 컨테이너는 배열, 리스트, 맵, 스택 등과 같은 자료구조를 지칭할 수 있습니다.

또한, 컨테이너는 컨테이너화 기술의 컨텍스트에서도 사용됩니다. 이는 애플리케이션을 실행할 때 필요한 모든 것(코드, 라이브러리, 환경 설정 등)을 패키지로 묶어 독립적으로 실행할 수 있게 해주는 기술을 의미합니다. 가령, Docker와 같은 컨테이너 기반 가상화 기술이 이에 해당합니다.
    
### Wrapper
래퍼는 다른 것을 감싸거나 덮는 데 사용되는 개념입니다. 주로 코드나 함수를 감싸거나, 인터페이스를 더 편리하게 사용할 수 있도록 하는 데 활용됩니다. 예를 들어, 함수 래퍼는 기존 함수를 감싸서 그 함수가 호출될 때 추가적인 로직을 수행하도록 할 수 있습니다.

또한, 프로그래밍에서는 객체나 자료구조를 감싸서 해당 요소들을 다른 방식으로 사용하거나 조작할 수 있는 방법을 제공하는 데 사용될 수 있습니다.

## Log
### Level
로그 레벨은 소프트웨어 개발 및 운영에서 로그 메시지의 중요도를 분류하기 위해 표준화된 방식으로 사용됩니다.

1. **TRACE**: 가장 세부적인 로그로, 프로그램의 실행 흐름을 상세히 기록합니다. 매우 세부적인 디버깅이 필요할 때 사용합니다.
2. **DEBUG**: 디버깅 목적으로 사용되며, 개발 중에 주로 활성화합니다. 개발 중에 시스템의 동작을 확인할 때 사용합니다.
3. **INFO**: 시스템의 정상적인 동작과 관련된 주요 이벤트를 기록합니다. 시스템 상태를 모니터링할 때 사용합니다.
4. **WARN**: 문제를 일으킬 가능성이 있는 상황을 나타냅니다. 비정상적이지만 치명적이지 않은 문제를 기록할 때 사용합니다.
5. **ERROR**: 심각한 문제를 나타내며, 예외 상황을 기록합니다. 복구가 필요한 치명적인 문제를 기록할 때 사용합니다.
6. **FATAL** : 치명적인 오류를 기록하며, 프로그램이 종료될 수 있는 상황을 나타냅니다.

## SSH
`SSH(Secure Shell)`는 네트워크 상에서 두 컴퓨터 간에 안전하게 통신할 수 있도록 해주는 **보안 프로토콜**입니다. 주로 원격 서버에 접속하여 명령을 실행하거나 파일을 전송할 때 사용되며, 암호화를 통해 데이터를 안전하게 보호합니다. SSH는 서버 관리와 유지보수에 중요한 역할을 하며, 서버에 대한 원격 접속을 가능하게 해줍니다.

- **원격 로그인**: 로컬 컴퓨터에서 원격 서버로 안전하게 접속해 명령어를 실행할 수 있습니다. 예를 들어, 웹 서버나 데이터베이스 서버의 설정을 수정할 때 사용됩니다.
- **파일 전송**: SSH를 사용해 파일을 안전하게 전송할 수 있습니다. 이때 많이 사용되는 도구로는 `scp` (secure copy)나 `rsync`가 있습니다.
- **포트 포워딩**: SSH를 통해 특정 포트를 터널링하여 외부 네트워크와의 안전한 통신을 할 수 있습니다. 이를 **SSH 터널링**이라고 부르며, 보안이 필요한 상황에서 많이 사용됩니다.
- **암호화된 통신**: SSH는 암호화를 사용해 데이터가 중간에 도청당하거나 변조되지 않도록 보호합니다. 대칭 키와 비대칭 키 암호화를 결합하여 통신을 안전하게 유지합니다.
- **키 기반 인증**: SSH는 암호 대신 공개 키 기반의 인증 방식을 제공합니다. 이는 비밀번호보다 보안성이 높으며, 공개 키와 개인 키 쌍을 사용해 사용자를 인증합니다.

## UUID 
UUID (Universally Unique Identifier)는 전 세계에서 고유한 값을 생성하기 위한 표준 형식입니다. UUID는 주로 데이터베이스, 분산 시스템, 네트워크, 파일 시스템 등에서 고유한 식별자가 필요할 때 사용됩니다. UUID는 128비트 크기를 가지며, 이를 16진수로 표현한 32개의 문자로 구성됩니다.

1. **고유성 (Uniqueness)**: UUID는 매우 높은 확률로 고유한 값을 생성합니다. 이를 통해 다른 시스템 간에 충돌 없이 고유한 식별자를 생성할 수 있습니다.
2. **전 세계적으로 고유**: UUID는 시간, 머신 정보, 랜덤 값 등을 기반으로 생성되기 때문에, 서로 다른 시스템에서 생성된 UUID도 충돌하지 않습니다.
3. **표준화**: UUID는 RFC 4122에 의해 정의된 표준 형식으로, 다양한 언어나 시스템에서 동일한 방식으로 생성됩니다.

UUID는 일반적으로 32개의 16진수 숫자와 4개의 하이픈으로 구분된 5개의 부분으로 이루어져 있습니다:

```
123e4567-e89b-12d3-a456-426614174000
```

**사용 사례**:
1. **데이터베이스의 기본 키**: UUID는 고유한 식별자가 필요할 때, 특히 분산 시스템에서 유용합니다.
2. **세션 식별자**: 웹 애플리케이션에서 사용자 세션을 추적할 때 UUID를 사용하여 고유한 세션 ID를 생성합니다.
3. **파일 식별자**: 파일 시스템에서 파일 이름을 고유하게 생성하거나, 분산 파일 시스템에서 파일을 식별하는 데 사용됩니다.
4. **API 키 및 토큰**: 인증 및 권한 부여 시스템에서 고유한 API 키나 인증 토큰을 생성할 때 UUID를 사용합니다.

## 환경 변수
환경 변수는 **운영 체제에서 실행 중인 프로세스가 사용할 수 있는 동적인 값**입니다. 시스템 설정, 애플리케이션 구성, 또는 실행 환경에 대한 정보를 저장하는 데 사용됩니다.

환경 변수는 키-값(Key-Value) 쌍으로 구성되며, 운영 체제에서 전역적으로 접근하거나 특정 프로세스에서만 사용할 수 있습니다.

1. **전역 접근 가능**: 환경 변수는 시스템 전역적으로 설정되며, 해당 값을 모든 프로세스에서 사용할 수 있습니다.
2. **키-값 쌍**: 각 환경 변수는 고유한 이름(키)과 값으로 구성됩니다.
3. **동적 변경 가능**: 시스템 실행 중에도 값을 변경하거나 추가할 수 있습니다.
4. **보안**: 민감한 정보를 코드 대신 환경 변수에 저장하여 보안을 강화할 수 있습니다.

**환경 변수의 주요 용도**
1. **시스템 구성**:
    - 운영 체제에서 사용하는 기본 디렉토리, 실행 경로, 언어 설정 등을 정의.
    - 예: `PATH`, `HOME`, `TEMP`.
2. **애플리케이션 설정**:
    - 데이터베이스 URL, API 키, 포트 번호와 같은 설정 정보를 저장.
    - 예: `DB_URL`, `API_KEY`, `PORT`.
3. **환경 분리**:
    - 개발, 테스트, 프로덕션 환경에서 다른 설정 값을 사용할 수 있도록 지원.
    - 예: `ENV=development` 또는 `ENV=production`.
4. **비밀 정보 관리**:
    - 비밀번호, 토큰, 인증 키와 같은 민감한 정보를 코드에서 분리.

## 서버 렌더링
**서버 렌더링(Server-Side Rendering, SSR)**은 웹 애플리케이션에서 HTML 콘텐츠를 서버에서 생성하여 클라이언트(브라우저)로 전송하는 방식을 말합니다. 서버가 요청을 받으면 필요한 데이터를 기반으로 HTML 페이지를 완성하고, 브라우저는 이를 받아 사용자에게 표시합니다.

서버 렌더링은 **SEO 최적화**와 **빠른 초기 로드**가 중요한 프로젝트에 적합하며, 클라이언트 렌더링과 함께 사용해 하이브리드 구조를 구현할 수도 있습니다.

1. **SEO(검색 엔진 최적화)**
    - 검색 엔진은 서버에서 생성된 HTML 콘텐츠를 쉽게 크롤링할 수 있습니다.
    - 클라이언트 렌더링보다 SEO에 유리합니다.
2. **빠른 초기 로드**
    - 브라우저가 완성된 HTML을 받아 즉시 렌더링할 수 있으므로 초기 로드 시간이 빠릅니다.
3. **간단한 구현**
    - JavaScript 프레임워크를 사용하지 않고도 서버에서 HTML을 생성할 수 있어 구현이 간단합니다.
4. **일관된 데이터 처리**
    -   서버에서 모든 데이터를 처리하므로 보안이 강화되고, 클라이언트에서의 데이터 누락 가능성이 줄어듭니다.

**과정**
1. **클라이언트 요청**
    -   사용자가 브라우저에서 URL에 접근하거나 특정 요청을 보냅니다.
2. **서버 처리**
    -   서버는 요청을 받아 필요한 데이터를 데이터베이스나 외부 API에서 가져옵니다.
    -   데이터를 템플릿 엔진(예: Thymeleaf, JSP, Handlebars)을 사용해 HTML 페이지에 삽입합니다.
3. **완성된 HTML 반환**
    - 서버는 완성된 HTML을 클라이언트로 전송합니다.
4. **클라이언트 표시**
    - 브라우저는 받은 HTML을 렌더링하여 사용자에게 페이지를 보여줍니다.

서버 렌더링(Server-Side Rendering, SSR)은 전통적으로 **백엔드의 영역**에 속하지만, 프론트엔드와 밀접하게 관련된 작업입니다. SSR이 브라우저에서 렌더링될 HTML을 생성하고, 사용자가 보는 UI를 결정하기 때문입니다. **어떤 기술 스택을 사용하는지**에 따라 프론트엔드와 백엔드 중 누가 더 많은 책임을 가지는지가 달라집니다.
- 전통적인 서버 렌더링(Java + Thymeleaf, Django 등): 백엔드 주도.
- 현대적인 SSR(Next.js, Nuxt.js 등): 프론트엔드 개발자가 주도.

## 더티 쓰기
**더티 쓰기(Dirty Write)**는 데이터베이스나 객체 관계 매핑(ORM)에서 **변경된 데이터가 저장되었을 때, 실제로 변경된 내용만 반영하는 것이 아니라 불필요한 데이터까지 저장되는 현상**을 의미합니다. 즉, 객체의 상태가 변경되면 그 객체가 연결된 데이터베이스 테이블의 모든 필드가 업데이트되는 방식입니다. 더티 쓰기는 **ORM의 편리함을 제공하지만, 성능에 영향을 미칠 수 있습니다**.

1. **객체의 상태 변경 추적**:
    - ORM은 객체를 데이터베이스 테이블과 매핑하여 객체의 상태를 추적합니다. 객체의 상태가 변경되면, ORM은 해당 객체를 "더티(Dirty)" 상태로 표시하고, 이를 저장할 때 모든 변경된 필드를 데이터베이스에 반영합니다.
2. **불필요한 업데이트**:
    - 객체의 일부 필드만 변경되었더라도, ORM은 객체 전체를 저장하려고 할 수 있습니다. 예를 들어, 객체의 일부 필드만 수정되었는데, ORM은 해당 객체의 모든 필드를 업데이트하려고 할 수 있습니다.
3. **자동으로 처리되는 경우**:
    - JPA와 같은 ORM에서는 객체의 상태가 변경되면 이를 자동으로 추적하고, `save()`, `flush()` 등을 호출하면 변경된 내용을 자동으로 데이터베이스에 반영합니다. 이때 객체의 상태가 "더티"로 표시되며, 해당 객체의 모든 변경 사항이 데이터베이스에 반영됩니다.

예를 들어, `User` 객체가 있고 이 객체의 `name`과 `email` 필드가 있습니다. 만약 `name`만 수정되었다면, `email`은 변경되지 않았지만 ORM은 객체를 저장할 때 `name`과 `email` 모두를 업데이트하려고 할 수 있습니다. 이렇게 되면 `email` 필드는 실제로 변경되지 않았음에도 불구하고 불필요하게 데이터베이스에 저장됩니다. 이 현상이 바로 **더티 쓰기**입니다.

**더티 쓰기의 장점**:
- **간편함**: ORM이 객체의 상태를 자동으로 추적하고, 변경된 내용을 데이터베이스에 반영하므로 개발자가 일일이 SQL을 작성할 필요가 없습니다.
- **자동화**: 객체의 상태가 변경되면 ORM이 이를 자동으로 반영하므로 개발자가 수동으로 업데이트 쿼리를 작성할 필요가 없습니다.

**더티 쓰기의 단점**:
- **불필요한 업데이트**: 객체의 일부 필드만 변경되었는데, 전체 객체가 업데이트되므로 불필요한 데이터베이스 쓰기 작업이 발생할 수 있습니다. 이는 성능 저하를 초래할 수 있습니다.
- **성능 문제**: 객체가 매우 크거나, 많은 필드를 가지고 있는 경우, 불필요한 필드까지 업데이트되면 성능에 부정적인 영향을 미칠 수 있습니다.

## ORM
**ORM(Object-Relational Mapping)**은 **객체**와 **관계형 데이터베이스** 사이의 **매핑**을 의미합니다. 쉽게 말해, 객체 지향 프로그래밍에서 사용하는 객체를 관계형 데이터베이스의 테이블과 연결하여 관리하는 기술입니다.

- **객체-관계 매핑:** 객체와 데이터베이스 테이블 간의 매핑 관계를 설정합니다.
- **쿼리 생성:** 객체 지향적인 방법으로 SQL 쿼리를 자동 생성합니다.
- **데이터베이스 연동:** 다양한 종류의 데이터베이스와 연결하여 사용할 수 있습니다.
- **트랜잭션 관리:** 데이터베이스 트랜잭션을 관리하여 데이터 무결성을 보장합니다.
- **캐싱:** 데이터를 메모리에 캐싱하여 성능을 향상시킵니다.

**장점**:
- **개발 생산성 향상:** SQL 쿼리를 직접 작성하는 대신 객체 지향적인 방법으로 데이터베이스를 조작할 수 있어 개발 생산성을 높입니다.
- **코드 가독성 향상:** 객체 지향적인 코드를 사용하여 데이터베이스와 상호작용하기 때문에 코드 가독성이 좋아지고 유지보수가 용이합니다.
- **데이터베이스 독립성:** 데이터베이스 종류에 상관없이 동일한 인터페이스를 사용하여 데이터에 접근할 수 있어 데이터베이스를 변경하더라도 코드 변경량을 최소화할 수 있습니다.
- **추상화:** 데이터베이스의 복잡한 구조를 추상화하여 개발자가 데이터베이스에 대한 깊은 이해 없이도 개발할 수 있도록 도와줍니다.

**단점**:
- **성능 저하:** ORM을 사용하면 SQL 쿼리가 자동 생성되면서 성능이 저하될 수 있습니다.
- **학습 곡선:** ORM을 사용하려면 ORM 프레임워크를 학습해야 하는 시간이 필요합니다.
- **복잡한 쿼리 작성의 어려움:** 매우 복잡한 쿼리를 작성해야 할 경우 ORM으로는 한계가 있을 수 있습니다.

**적합한 사례**:
- **복잡한 데이터 모델:** 다양한 테이블 간의 복잡한 관계를 관리해야 할 경우 ORM이 유용합니다.
- **트랜잭션 처리:** 여러 테이블에 대한 변경 작업을 하나의 트랜잭션으로 처리해야 할 경우 ORM이 편리합니다.
- **객체 지향적인 데이터 모델링:** 객체 지향적인 방식으로 데이터를 모델링하고 싶을 때 ORM을 사용하면 효과적입니다.
- **대규모 프로젝트:** 많은 개발자가 참여하는 대규모 프로젝트에서는 ORM을 사용하여 코드의 일관성과 유지보수성을 높일 수 있습니다.

ORM을 사용할지 여부는 프로젝트의 특성과 요구사항에 따라 결정해야 합니다. 간단한 요청 처리 시스템에서는 ORM 없이도 충분히 구현할 수 있으며, 오히려 성능 저하를 야기할 수 있습니다. 하지만 복잡한 데이터 모델이나 트랜잭션 처리가 필요한 경우에는 ORM을 사용하여 개발 생산성을 높일 수 있습니다.

**대표적인 ORM**:
- **Sequelize (Node.js):** Node.js에서 가장 많이 사용되는 ORM 중 하나입니다.
- **Hibernate (Java):** Java 환경에서 가장 많이 사용되는 ORM입니다.
- **SQLAlchemy (Python):** Python에서 사용되는 강력한 ORM입니다.

## Pool
**풀(Pool)은 미리 할당해 놓은 자원들의 집합체**를 의미합니다. 이 자원들은 필요에 따라 사용하고 반납될 수 있으며, 새로운 자원을 생성하는 것보다 풀에서 이미 존재하는 자원을 재활용하는 것이 더 효율적이기 때문에 널리 사용됩니다.

풀은 컴퓨터 시스템에서 자원을 효율적으로 관리하고 성능을 향상시키기 위한 중요한 기법입니다. 다양한 분야에서 널리 사용되고 있으며, 시스템 설계 시 풀을 적절하게 활용하면 시스템의 성능과 안정성을 크게 향상시킬 수 있습니다.

- **성능 향상:** 자원 생성/해제에 드는 오버헤드를 줄여 시스템 성능을 향상시킵니다.
- **자원 효율성:** 자원을 미리 할당해 놓음으로써 자원 낭비를 줄이고 효율적으로 사용할 수 있습니다.
- **응답 시간 단축:** 풀에 미리 생성된 자원을 사용하기 때문에 응답 시간을 단축할 수 있습니다.

### 종류
- **메모리 풀 (Memory Pool):** 메모리를 미리 할당해 놓고 필요할 때마다 작은 블록 단위로 나누어 사용하는 기법입니다. 메모리 할당/해제에 드는 오버헤드를 줄여 시스템 성능을 향상시킵니다.
- **쓰레드 풀 (Thread Pool):** 미리 생성해 놓은 스레드들을 모아 놓은 것으로, 작업 요청이 들어올 때마다 새로운 스레드를 생성하는 대신 풀에 있는 스레드를 재활용합니다.
- **커넥션 풀 (Connection Pool):** 데이터베이스와 같은 외부 시스템과의 연결을 미리 생성해 놓고, 필요할 때마다 풀에서 연결을 가져다 사용하고 반납합니다. 연결 생성에 따른 오버헤드를 줄이고 시스템 성능을 향상시킵니다.
- **객체 풀 (Object Pool):** 자주 사용되는 객체를 미리 생성하여 풀에 저장해 놓고, 필요할 때마다 풀에서 가져다 사용합니다. 객체 생성 비용을 줄이고 성능을 향상시킵니다.

### 주의사항
- **풀 크기:** 풀 크기를 적절하게 설정해야 합니다. 너무 작으면 자원 부족으로 인해 성능이 저하될 수 있고, 너무 크면 메모리 낭비가 발생할 수 있습니다.
- **자원 관리:** 풀에 있는 자원을 효율적으로 관리해야 합니다. 사용 후 반납되지 않은 자원이나 손상된 자원은 시스템 성능에 악영향을 미칠 수 있습니다.
- **동기화:** 여러 스레드가 동시에 풀에 접근할 경우 동기화 문제가 발생할 수 있으므로 적절한 동기화 메커니즘을 사용해야 합니다.

## Method Chaining
**메서드 체이닝**이란 객체의 메서드를 연속적으로 호출하여 코드를 더욱 간결하고 가독성 있게 만드는 프로그래밍 기법으로, 각 메서드의 결과값이 다음 메서드의 입력값으로 연결되는 방식입니다.

메서드 체이닝은 코드를 더욱 간결하고 효율적으로 작성할 수 있는 강력한 도구입니다. 하지만 과도한 사용은 오히려 코드를 복잡하게 만들 수 있으므로, 적절하게 사용하는 것이 중요합니다.

```JavaScript
const result = [1, 2, 3, 4, 5]
  .filter(num => num > 2)
  .map(num => num * 2)
  .reduce((acc, num) => acc + num, 0);
```

위 코드는 배열에서 2보다 큰 숫자만 필터링하고, 각 숫자에 2를 곱한 후, 모든 값을 더하는 과정을 한 줄로 표현합니다.

**장점**:
- **코드 가독성 향상:** 한 줄에 여러 작업을 표현하여 코드를 간결하게 만들고, 코드의 흐름을 파악하기 쉽습니다.
- **생산성 향상:** 반복적인 코드를 줄이고, 개발 속도를 향상시킵니다.
- **객체 지향 프로그래밍과의 조화:** 객체 지향 프로그래밍의 장점을 극대화하여 객체 지향적인 코드를 작성할 수 있습니다.

**단점:**
- **과도한 사용 시 가독성 저하:** 너무 많은 메서드를 체이닝하면 코드가 복잡해져 가독성이 떨어질 수 있습니다.
- **디버깅 어려움:** 문제가 발생했을 때 어느 부분에서 문제가 발생했는지 찾기 어려울 수 있습니다.
