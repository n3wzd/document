---
categories:
- BOJ
date: '2022-03-11'
title: '[BOJ] 2629 - 양팔저울'
---

{% raw %}
> 골드 III<br>

## 문제
양팔 저울과 몇 개의 추가 주어졌을 때, 이를 이용하여 입력으로 주어진 구슬의 무게를 확인할 수 있는지를 결정하려고 한다.

무게가 각각 1g과 4g인 두 개의 추가 있을 경우, 주어진 구슬과 1g 추 하나를 양팔 저울의 양쪽에 각각 올려놓아 수평을 이루면 구슬의 무게는 1g이다. 또 다른 구슬이 4g인지를 확인하려면 1g 추 대신 4g 추를 올려놓으면 된다.

구슬이 3g인 경우 아래 <그림 1>과 같이 구슬과 추를 올려놓으면 양팔 저울이 수평을 이루게 된다. 따라서 각각 1g과 4g인 추가 하나씩 있을 경우 주어진 구슬이 3g인지도 확인해 볼 수 있다.

![](https://upload.acmicpc.net/ce5b29f5-9e03-473b-97db-ce9fd740fde2/-/preview/)

<그림 1> 구슬이 3g인지 확인하는 방법 (1$\boxed{1}$은 1g인 추,  4$\boxed{4}$는 4g인 추, ●은 무게를 확인할 구슬)<br>

<그림 2>와 같은 방법을 사용하면 구슬이 5g인지도 확인할 수 있다. 구슬이 2g이면 주어진 추를 가지고는 확인할 수 없다.

추들의 무게와 확인할 구슬들의 무게가 입력되었을 때, 주어진 추만을 사용하여 구슬의 무게를 확인 할 수 있는지를 결정하는 프로그램을 작성하시오.

![](https://upload.acmicpc.net/883fb22a-7516-46e1-937d-2ddc4df94572/-/preview/)

<그림 2> 구슬이 5g인지 확인하는 방법<br>

**입력**
첫째 줄에는 추의 개수가 자연수로 주어진다. 추의 개수는 30 이하이다. 둘째 줄에는 추의 무게들이 자연수로 가벼운 것부터 차례로 주어진다. 같은 무게의 추가 여러 개 있을 수도 있다. 추의 무게는 500g이하이며, 입력되는 무게들 사이에는 빈칸이 하나씩 있 다. 세 번째 줄에는 무게를 확인하고자 하는 구슬들의 개수가 주어진다. 확인할 구슬의 개수는 7이하이다. 네 번째 줄에는 확인하고자 하는 구슬들의 무게가 자연수로 주어지며, 입력되는 무게들 사이에는 빈 칸이 하나씩 있다. 확인하고자 하는 구슬의 무게는 40,000보다 작거나 같은 자연수이다.

**출력**
주어진 각 구슬의 무게에 대하여 확인이 가능하면 Y, 아니면 N 을 차례로 출력한다. 출력은 한 개의 줄로 이루어지며, 각 구슬에 대한 답 사이에는 빈칸을 하나씩 둔다.
##  해결
저울의 추를 적절히 놓고 빼서 측정 가능한 모든 경우를 알아야 한다. 또한, 전체 문제를 추 하나씩 추가하는 부분 문제로 재귀적으로 분할 가능하다. 부분 문제의 답은 전체 문제의 답으로 이어지지는 않으므로 정복 과정은 없다. 따라서 `백트래킹`을 통해 접근할 수 있다. 오답의 방향은 이미 계산한 방향으로 한다. 이때 메모이제이션이 사용될 수 있다. 최종적으로 이 문제는 `DP`로 접근한다.

현재 상태를 저울의 무게 차, 들고 있는 추의 인덱스(w, i)로 한다. 부분 문제의 계산 값은 현재 (w, i) 저울 상태에서 구슬을 잴 수 있는지 여부다. 접시에서 무게가 적은 쪽에 구슬을 배치하면 구슬의 무게를 측정할 수 있으므로 항상 true다. 각 부분 문제의 탐색 여부를 메모이제이션으로 기록해 오답을 피한다. 초기 문제의 상태는 (0, N)이다.
> DP(w, i) = true<br>
>> DP(w + weight[i], i - 1);<br>
>> DP(abs(w - weight[i]), i - 1);<br>
>> DP(w, i - 1);<br>

백트래킹의 다음 문제 탐색은 크게 3가지로 구분할 수 있다. 들고 있는 추를 W<sub>i</sub>라고 한다면, 현재 접시에서 추가 놓인 곳에 W<sub>i</sub>를 놓는 경우, 반대편에 W<sub>i</sub>를 놓는 경우, 아예 놓지 않는 경우로 나뉜다. 저울의 무게 차만 기록하므로 현재 저울 접시에 추가 몇 개 놓여있는지는 중요하지 않다. (ex. 양팔 접시가 11, 3인 경우는 7, 0인 것과 같다고 볼 수 있다)

여담: DP 문제 중에서 `가방 문제(knapsack problem)`와 해결 방법이 비슷하다.

참고로 추로 만들 수 있는 무게는 최대 15000이지만, 구슬의 무게는 최대 40000이다. 배열 참조 범위 초과를 조심하자.

## 코드
```
#include <iostream>
#include <cmath>
using namespace std;

int n, m;
int weight[2002];
bool cache[15002][32] = { 0, };
bool answer[40002] = { 0, };

void DP(int w, int i)
{
	if (i < 1)
	{
		answer[w] = 1;
		return;
	}
	if (cache[w][i]) return;

	cache[w][i] = 1;
	answer[w] = 1;
	DP(w + weight[i], i - 1);
	DP(abs(w - weight[i]), i - 1);
	DP(w, i - 1);
}

int main()
{
	cin >> n;<br>
	for (int i = 1; i <= n; i++)
		scanf("%d", &weight[i]);
	DP(0, n);

	cin >> m;<br>
	for (int i = 1; i <= m; i++)
	{
		int w;
		scanf("%d", &w);
		if(answer[w]) printf("Y ");
		else printf("N ");
	}
	
	return 0;
}
```

## 링크
https://www.acmicpc.net/problem/2629
{% endraw %}