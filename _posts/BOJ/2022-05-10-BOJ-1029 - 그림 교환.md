---
categories:
- BOJ
date: '2022-05-10'
title: '[BOJ] 1029 - 그림 교환'
---

{% raw %}
> 골드 I<br>

## 문제
예술을 사랑하는 사람들이 시장에 모여서 그들의 그림을 서로 거래하려고 한다. 모든 그림의 거래는 다음과 같은 조건을 만족해야 한다.

1.  그림을 팔 때, 그림을 산 가격보다 크거나 같은 가격으로 팔아야 한다.
2.  같은 그림을 두 번 이상 사는 것은 불가능하다.

방금 시장에 새로운 그림이 들어왔다. 1번 아티스트는 그 그림을 외부 상인에게 가격 0을 주고 샀다. 이제 그 그림을 자신의 예술가 친구들에게 팔려고 한다. 위의 조건을 모두 만족하는 거래만 이루어진다고 가정했을 때, 그림을 소유했던 사람의 수의 최댓값을 출력하는 프로그램을 작성하시오. (1번 아티스트와 마지막으로 그 그림을 소유한 사람도 포함한다).

#### 입력
첫째 줄에 예술가의 수 N이 주어진다. N은 2보다 크거나 같고, 15보다 작거나 같은 자연수이다.

둘째 줄부터 N개의 줄에는 N개의 수가 주어진다. i번째 줄의 j번째 수는 j번 예술가가 i번 예술가에게 그 그림을 살 때의 가격이다. 모든 가격은 0이 제일 낮은 가격이고, 9가 제일 높은 가격이다.

#### 출력
첫째 줄에 그 그림을 소유 했던 사람들 (잠시라도 소유했던 사람도 포함)의 최댓값을 출력한다.

## 해결
화가를 정점, 교환을 가중치가 있는 유향 간선으로 한 그래프에서 최대 방문 가능한 정점 개수를 구해야 한다. 간선 가중치가 현재 그림 가격보다 큰 경우는 해당 간선을 이용할 수 없다.

현재 정점에서 가장 최소인 간선을 선택해도, 최적해를 보장할 수 없으므로 모든 경우를 탐색해야 한다. 그러나 완전탐색은 O(N!) 시간이 걸리므로 사용이 어렵다. `DP`를 사용하자.

현재 상태를 (방문한 정점 목록, 현재 정점, 현재 그림 비용), 계산 결과를 방문한 정점 개수로 정의한다. 초기 상태는 (공집합, 0, 0)이다. 교환 비용을 알기 위해서는 현재 정점이 필요하다. 또한, 현재 정점이 같더라도 가지고 있는 그림 비용에 따라 선택할 수 있는 간선의 범위가 달라지므로 그림 비용도 상태에 포함된다.

현재 상태에 맞는 간선을 선택해서 교환을 수행한다. 점화식 함수는 다음과 같다. 
```
list = [0, 0, ...] // 방문한 정점 목록
	- 인덱스: 정점 번호
	- 값: 방문 상태 (방문했으면 1, 초기값은 모두 0)
v = 현재 정점
cost = 현재 그림 비용
trade[N][N] // i -> j 간선 가중치<br>

DP(list, v, cost)
{
	1. 현재 모든 정점을 방문했다면 0 반환
	2. cnt = 1
	3. 현재 방문되지 않은 정점을 조사한다 (v 제외) => i<br>
		- if trade[v][i] ≥ cost,
			- list2 = list에서 i번 정점 방문 표시
			- cnt = max(cnt, 1 + DP(list2, i, trade[v][i]));
	4. cnt를 반환한다.
}
```
boolean 배열일 경우, `비트마스크`를 사용해서 정수 하나로 치환할 수 있다. 

## 코드
```
#include <iostream>
using namespace std;

int N;
int cache[1 << 15][15][10];
int trade[15][15];

int DP(int list, int v, int cost)
{
	if (list == (1 << N) - 1) return 0;
	if (cache[list][v][cost] > 0) return cache[list][v][cost];<br>

	cache[list][v][cost] = 1;
	for (int i = 0; i < N; i++)
		if (!(list & (1 << i)) && trade[v][i] >= cost && v != i)
			cache[list][v][cost] = max(cache[list][v][cost], 1 + DP(list | (1 << v), i, trade[v][i]));

	return cache[list][v][cost];
}

int main()
{
	ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
	cin >> N;<br>
	for (int i = 0; i < N; i++)
	{
		string str;
		cin >> str;<br>
		for (int j = 0; j < N; j++)
			trade[i][j] = str[j] - '0';
	}
	cout << DP(0, 0, 0);
	return 0;
}
```

## 링크
https://www.acmicpc.net/problem/1029
{% endraw %}