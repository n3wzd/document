---
categories:
- BOJ
date: '2022-07-29'
title: '[BOJ] 13202 - 피자 배치'
---

{% raw %}
> 골드 II<br>

## 문제
상언이의 단골 피자가게는 직각삼각형 모양의 테이블과 완벽한 원 모양의 피자로 유명하다. 이 가게의 사장님은 한 테이블에서 피자를 주문하면 그 테이블로 직접와서 테이블이 피자로 가득 찰 때까지 피자를 계속 만든다.

사장님은 피자 하나를 새로 만들 때 마다 다음과 같은 그만의 놀라운 방법을 사용한다. 현재 이미 만들어진 다른 피자들과 겹치지 않으면서 (접할 수는 있다) 테이블의 변 중 두개 이상에 접하도록 만들 수 있는 피자 중 가장 넓이가 큰 피자를 만든다. 상언이는 문득 이 테이블에 만들어질  _k_ 번째 피자의 넓이가 궁금해졌다.

![](images/13202-pizza.png)

### 입력
첫 번째 줄에 테스트 케이스의 수  _T_(1 ≤  _T_  ≤ 10,000)가 주어지고, 이어서  _T_  개의 테스트 케이스가 입력된다. 각 테스트 케이스는 한 줄에 3개의 정수가 주어진다. 이는 직각삼각형의 직교하는 두 변  _a_,  _b_ 의 길이와  _k_  를 의미한다. (1 ≤  _a_,  _b_  ≤ 109, 1 ≤  _k_  ≤ 100)

### 출력
각 테스트 케이스마다, 첫 번째 줄에  _k_  번째 피자의 넓이를 출력한다. 출제진의 답과 절대 오차 또는 상대 오차가 10<sup>−6</sup>  이하일 시 정답으로 인정한다.<br>

## 해결
같은 도형이 규칙에 따라 반복되는 유형의 기하 문제. 원의 넓이는 반지름에 의해 결정되므로 반지름을 구하면 된다.

원은 삼각형의 2변에 반드시 접해야 한다. 1번째 원인 내접원이 생성되면 3개의 영역으로 나뉘며, 각 영역에서 원 1개가 규칙적으로 생성된다.

**< 1. 내접원 >**
내접원 공식을 사용해서 바로 구할수 있다. (r = 반지름, a, b = 직교하는 두 변의 길이, c = 빗면 길이)
$$
r = (a + b - c) / 2
$$

c는 피타고라스의 정리를 활용해서 구할 수 있다.

**< 2. 부분 원 >**
현재 큰 원의 중심을 C<sub>1</sub>, 생성되는 작은 원의 중심을 C<sub>2</sub>라고 했을 때, d를 C<sub>1</sub>에서 C<sub>2</sub>을 거치고 삼각형의 꼭지점 A를 잇는 선분의 길이라고 하자. 그리고 C<sub>1</sub>, C<sub>2</sub>에서 삼각형에 내린 수선의 발을 각각 H<sub>1</sub>, H<sub>2</sub>이라고 하자. 삼각형 C<sub>1</sub>H<sub>1</sub>A, C<sub>2</sub>H<sub>2</sub>A는 닮음이므로 길이의 비율을 적용할 수 있다. (r<sub>1</sub>, r<sub>2</sub>는 각각 C<sub>1</sub>, C<sub>2</sub>의 반지름이다.)
$$
r_{1} : r_{2} = d : d - (r_{1} + r_{2})
$$

이 식을 정리하면,
$$
r_{2} = r_{1} \times (d - r_{1}) / (d + r_{1})
$$

이 공식은 1번째 내접원으로 나뉜 3영역에 모두 적용할 수 있다. 또한 1번째 d는 내접원 반지름과 피타고라스 정리를 적절히 활용해서 구할 수 있다.

```
1. 내접원의 반지름 r을 구한다.
2. r1[3], d[3]의 초항을 구한다.
3. k - 1번까지 반복
	1. 3영역에서 각각 부분 원의 반지름 구한다.
	2. 3개의 반지름에서 최소를 찾는다.
		- 해당 부분 원에 따라 r1[t], d[t]를 갱신
4. 현재 부분 원의 넓이를 출력
```

## 코드
```
#include <iostream>
#include <cmath>
typedef long double ld;
using namespace std;
const ld PI = 3.14159265358979323846;
int Q, N;

void Solve() {
	ld A, B;
	scanf("%Lf%Lf%d", &A, &B, &N);
	
	ld r = (A + B - sqrt(A * A + B * B)) / 2;
	ld d[3] = {
		sqrt(r * r + (A - r) * (A - r)),
		sqrt(r * r + (B - r) * (B - r)),
		sqrt(r * r + r * r)
	};
	ld r1[3] = { r, r, r };

	ld max_r = r;
	int max_idx = 0;
	for (int i = 1; i < N; i++) {
		max_r = 0, max_idx = 0;
		for (int t = 0; t < 3; t++) {
			ld r2 = r1[t] * (d[t] - r1[t]) / (d[t] + r1[t]);
			if(r2 > max_r) {<br>
				max_r = r2;
				max_idx = t;
			}
		}
		d[max_idx] -= r1[max_idx] + max_r;
		r1[max_idx] = max_r;
	}
	printf("%.8Lf\n", max_r * max_r * PI);
}

int main() {
	scanf("%d", &Q);
	while (Q--)
		Solve();
	return 0;
}
```

## 링크
https://www.acmicpc.net/problem/13202<br>
{% endraw %}