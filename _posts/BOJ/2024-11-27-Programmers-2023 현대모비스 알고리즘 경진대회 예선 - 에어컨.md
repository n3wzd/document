---
categories:
- Programmers
date: '2024-11-27'
title: '[Programmers] 2023 현대모비스 알고리즘 경진대회 예선 - 에어컨'
---

{% raw %}
> Lv. 3<br>

## 문제
현대모비스에서 개발한 실내공조 제어 시스템은 차내에 승객이 탑승 중일 때 항상 쾌적한 실내온도(`t1`  ~  `t2`)를 유지할 수 있도록 합니다. 현재(0분) 실내온도는 실외온도와 같습니다.

실내공조 제어 시스템은 실내온도를 조절하기 위해 에어컨의 전원을 켜 희망온도를 설정합니다. 희망온도는 에어컨의 전원이 켜져 있는 동안  **원하는 값으로**  변경할 수 있습니다. 실내온도와 희망온도가 다르다면 1분 뒤 실내온도가  **희망온도와 같아지는 방향으로**  1도 상승 또는 하강합니다. 실내온도가 희망온도와 같다면 에어컨이 켜져 있는 동안은 실내온도가 변하지 않습니다.

에어컨의 전원을 끄면 실내온도가  **실외온도와 같아지는 방향으로**  매 분 1도 상승 또는 하강합니다. 실내온도와 실외온도가 같다면 실내온도는 변하지 않습니다.

에어컨의 소비전력은 현재 실내온도에 따라 달라집니다. 에어컨의 희망온도와 실내온도가 다르다면 매 분 전력을  `a`만큼 소비하고, 희망온도와 실내온도가 같다면 매 분 전력을  `b`만큼 소비합니다. 에어컨이 꺼져 있다면 전력을 소비하지 않으며, 에어컨을 켜고 끄는데 필요한 시간과 전력은 0이라고 가정합니다.

실내공조 제어 시스템은 차내에 승객이 탑승 중일 때 실내온도를  `t1`  ~  `t2`도 사이로 유지하면서, 에어컨의 소비전력을 최소화합니다.

실외온도를 나타내는 정수  `temperature`, 쾌적한 실내온도의 범위를 나타내는 정수  `t1`,  `t2`, 에어컨의 소비전력을 나타내는 정수  `a`,  `b`와 승객이 탑승 중인 시간을 나타내는 1차원 정수 배열  `onboard`가 매개변수로 주어집니다. 승객이 탑승 중인 시간에 쾌적한 실내온도를 유지하기 위한 최소 소비전력을 return 하도록 solution 함수를 완성해 주세요.

### 제한사항
-   -10 ≤  `temperature`  ≤ 40
-   -10 ≤  `t1`  <  `t2`  ≤ 40
    -   `temperature`는  `t1`  ~  `t2`  범위 밖의 값입니다.
-   1 ≤  `a`,  `b`  ≤ 100
    -   `a`는 에어컨의 희망온도와 실내온도가 다를 때의 1분당 소비전력을 나타냅니다.
    -   `b`는 에어컨의 희망온도와 실내온도가 같을 때의 1분당 소비전력을 나타냅니다.
-   2 ≤  `onboard`의 길이 ≤ 1,000
    -   `onboard[i]`는 0 혹은 1이며,  `onboard[i]`가 1이라면  `i`분에 승객이 탑승 중이라는 것을 의미합니다.
    -   `onboard[0]`  = 0
    -   `onboard`에 1이 최소 한 번 이상 등장합니다.
-   승객이 탑승 중인 시간에 쾌적한 실내온도를 유지하는 것이 불가능한 경우는 주어지지 않습니다.

## 해결
유지, 조절 비용이 변수이므로 모든 경우를 확인해야 합니다. 입력이 작으니 모든 탐색이 가능하고, 부분 문제 분리 가능하며 중복 상태 존재합니다. => `DP`

현재 상태를 (시간, 온도)로 정의하고, 계산 결과는 쾌적 상태일 때 소비 전력 최솟값입니다. 초기 상태는 (0, 실외 온도)이며, 값은 0입니다. 최종 정답은 마지막 시간일 때 모든 온도에 대한 값들의 최소입니다. 다음 온도는 3가지(유지, 1도 증가, 1도 감소)가 있으며, 각 상황마다 최소 비용을 계산하면 됩니다.
- 유지: 실내 온도와 실외 온도가 같다면 에어컨을 끄고, 그렇지 않으면 에어컨을 킵니다. (비용 b)
- 1도 증가: 실내 온도가 실외 온도보다 작으면 에어컨을 끄고, 그렇지 않으면 에어컨을 킵니다. (비용 a)
- 1도 감소: 실내 온도가 실외 온도보다 크면 에어컨을 끄고, 그렇지 않으면 에어컨을 킵니다. (비용 a)
- 현재 시간에 승객이 있는데, 현재 온도가 쾌적 상태가 아니면 불가능한 경우입니다.

정리하면 점화식은 다음과 같습니다: (`x` = 현재 시간, `t` = 현재 온도, `T` = 실외 온도)
> DP(x, t) = min(DP(x - 1, t) + (t == T ? 0 : b), DP(x - 1, t - 1) + (t <= T ? 0 : a), DP(x - 1, t + 1) + (t >= T ? 0 : a))<br>

※ 최적화: bottom-up으로 구현해야 통과합니다.

## 코드
```
#include <vector>
using namespace std;
int DP[1001][51];
const int INF = 1e9;

int solution(int T, int T1, int T2, int CA, int CB, vector<int> B) {
    int N = B.size(), answer = INF; T += 10, T1 += 10, T2 += 10;
    for(int b = 0; b < N; b++)
        for(int t = 0; t <= 50; t++)
            DP[b][t] = INF;
    DP[0][T] = 0;
    for(int b = 1; b < N; b++) {
        for(int t = 0; t <= 50; t++) {
            if(B[b] == 1 && (t < T1 || t > T2))
                continue;
            DP[b][t] = DP[b - 1][t] + (t == T ? 0 : CB);
            if(t > 0)
                DP[b][t] = min(DP[b][t], DP[b - 1][t - 1] + (t <= T ? 0 : CA));
            if(t < 50)
                DP[b][t] = min(DP[b][t], DP[b - 1][t + 1] + (t >= T ? 0 : CA));
        }
    }
    for(int t = 0; t <= 50; t++)
        answer = min(answer, DP[N - 1][t]);
    return answer;
}
```

## 링크
<br>https://school.programmers.co.kr/learn/courses/30/lessons/214289
{% endraw %}