---
categories:
- Programmers
date: '2024-11-12'
title: '[Programmers] 2020 KAKAO TECH INTERNSHIP - 동굴 탐험'
---

{% raw %}
> Lv. 4<br>

## 문제
오지 탐험가인  `프로도`는 탐험 도중 n개의 방으로 이루어진 지하 동굴을 탐험하게 되었습니다. 모든 방에는 0부터 n - 1 까지 번호가 붙어있고, 이 동굴에 들어갈 수 있는 유일한 입구는 0번 방과 연결되어 있습니다. 각 방들은 양방향으로 통행이 가능한 통로로 서로 연결되어 있는데, 서로 다른 두 방을 직접 연결하는 통로는 오직 하나입니다. 임의의 서로 다른 두 방 사이의 최단경로는 딱 한 가지만 있으며, 또한 임의의 두 방 사이에 이동이 불가능한 경우는 없습니다.

탐험에 앞서 이 지하 동굴의 지도를 손에 넣은 프로도는 다음과 같이 탐험 계획을 세웠습니다.

1.  모든 방을 적어도 한 번은 방문해야 합니다.
2.  특정 방은 방문하기 전에 반드시 먼저 방문할 방이 정해져 있습니다.  
    2-1. 이는 A번 방은 방문하기 전에 반드시 B번 방을 먼저 방문해야 한다는 의미입니다.  
    2-2. 어떤 방을 방문하기 위해 반드시 먼저 방문해야 하는 방은 없거나 또는 1개 입니다.  
    2-3. 서로 다른 두 개 이상의 방에 대해 먼저 방문해야 하는 방이 같은 경우는 없습니다.  
    2-4. 어떤 방이 먼저 방문해야 하는 방이면서 동시에 나중에 방문해야 되는 방인 경우는 없습니다.  
    
위 계획 중 2-2, 2-3, 2-4는 순서를 지켜 방문해야 하는 두 방의 쌍이  `A → B`(A를 먼저 방문하고 B를 방문함) 형태로 유일함을 의미합니다. 즉, 프로도는 아래와 같은 형태로 방문순서가 잡히지 않도록 방문 계획을 세웠습니다.

-   `A → B, A → C`  (방문순서 배열 order = [...,[A,B],...,[A,C],...]) 형태로 A를 방문 후에 방문해야 할 방이 B와 C로 두 개 또는 그 이상인 경우
-   `X → A, Z → A`  (방문순서 배열 order = [...,[X,A],...,[Z,A],...]) 형태로 A를 방문하기 전에 방문해야 할 방이 X와 Z로 두 개 또는 그 이상인 경우
-   `A → B → C`  (방문순서 배열 order = [...,[A,B],...,[B,C],...) 형태로 B처럼 A 방문 후이면서 동시에 C 방문 전인 경우  
    
그리고 먼저 방문해야 할 방과 나중에 방문할 방을 반드시 연속해서 방문해야 할 필요는 없어 A방을 방문한 후 다른 방을 방문한 후 B방을 방문해도 좋습니다.

방 개수 n, 동굴의 각 통로들이 연결하는 두 방의 번호가 담긴 2차원 배열 path, 프로도가 정한 방문 순서가 담긴 2차원 배열 order가 매개변수로 주어질 때, 프로도가 규칙에 맞게 모든 방을 탐험할 수 있을 지 return 하도록 solution 함수를 완성해주세요.

### 제한사항
-   n은 2 이상 200,000 이하입니다.
-   path 배열의 세로(행) 길이는 n - 1 입니다.
    -   path 배열의 원소는 [방 번호 A, 방 번호 B] 형태입니다.
    -   두 방 A, B사이를 연결하는 통로를 나타냅니다.
    -   통로가 연결하는 두 방 번호가 순서없이 들어있음에 주의하세요.
-   order 배열의 세로(행) 길이는 1 이상 (n / 2) 이하입니다.
    -   order 배열의 원소는 [방 번호 A, 방 번호 B] 형태입니다.
    -   A번 방을 먼저 방문한 후 B번 방을 방문해야 함을 나타냅니다.

## 해결
트리에서 방문 순서가 주어졌을 때 모든 정점을 방문할 수 있는지 확인하는 문제입니다. N이 충분히 크므로 O(N)으로 해결해야 합니다. 그래프 탐색 중 효율성과 구현상 편의를 위해 `BFS`를 사용합니다.

어떤 정점을 방문하기 위해 먼저 방문해야 하는 정점을 열쇠, 열쇠에 방문하면 입장할 수 있는 정점을 문으로 정의합니다. 그래프 탐색에서 현재 정점이 문이라면, 알맞은 열쇠가 먼저 방문되어야 할 것입니다. 만약 열쇠를 방문했다면 일반 정점처럼 큐에 추가하면 되지만, 그렇지 않다면 큐에 넣지 않고 대기해야 합니다. 추후 열쇠 정점을 방문했을 때, 열쇠에 대응되는 문이 대기 중이라면 문 정점을 큐에 추가하면 됩니다.

탐색 종료시, 대기 중인 정점이 있다면  `false`, 그렇지 않다면 `true`를 출력합니다.

시작 정점(0번 정점)이 문일 수 있습니다. 이때 정답은 항상 `false`입니다.

## 코드
```
#include <vector>
#include <queue>
using namespace std;
queue<int> q;
bool visited[200001], waited[200001];
vector<int> graph[200001];
int key[200001], door[200001], waitCnt;

bool solution(int N, vector<vector<int>> paths, vector<vector<int>> orders) {
    for(auto path : paths) {
        graph[path[0]].push_back(path[1]);
        graph[path[1]].push_back(path[0]);
    }
    for(auto order : orders) {
        key[order[1]] = order[0];
        door[order[0]] = order[1];
        if(order[1] == 0)
            return 0;
    }
    q.push(0); visited[0] = 1;
    while(!q.empty()) {
        int n = q.front(); q.pop();
        for(auto next : graph[n]) {
            if(visited[next]) 
                continue;
            if(!visited[key[next]]) {
                waited[next] = 1;
                waitCnt++;
            }
            else
                q.push(next);
            if(waited[door[next]]) {
                q.push(door[next]);
                waited[door[next]] = 0;
                waitCnt--;
            }
            visited[next] = 1;
        }
    }
    return waitCnt == 0;
}
```

## 링크
<br>https://school.programmers.co.kr/learn/courses/30/lessons/67260
{% endraw %}