---
categories:
- BOJ
date: '2022-07-16'
title: '[BOJ] 11003 - 최솟값 찾기'
---

{% raw %}
> 골드 I<br>

## 문제
N개의 수 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>과 L이 주어진다.

D<sub>i</sub>  = A<sub>i-L+1</sub>  <sub> A</sub>i<sub>  중의 최솟값이라고 할 때, D에 저장된 수를 출력하는 프로그램을 작성하시오. 이때, i ≤ 0 인 A</sub>i~는 무시하고 D를 구해야 한다.<br>

### 입력
첫째 줄에 N과 L이 주어진다. (1 ≤ L ≤ N ≤ 5,000,000)

둘째 줄에는 N개의 수 A<sub>i</sub>가 주어진다. (-10<sup>9</sup>  ≤ A<sub>i</sub>  ≤ 10<sup>9</sup>)<br>

### 출력
첫째 줄에 D<sub>i</sub>를 공백으로 구분하여 순서대로 출력한다.

## 해결
1칸씩 움직이는 `슬라이딩 윈도우`에서 최솟값을 찾는 문제. 여러 가지 방법이 있다.

#### 방법 1. 세그먼트 트리
윈도우를 구간 쿼리로 취급하고 최솟값을 저장하는 `세그먼트 트리`를 활용하면 어렵지 않게 찾을 수 있다. 단, 시간 복잡도는 O(N log N)이므로 제출하면 시간 초과를 받는다!

#### 방법 2. 우선순위 큐
최솟값을 저장하는 `우선순위 큐`를 사용하면 된다. 원래 우선순위 큐는 root 노드를 제외한 삭제 기능은 제공하지 않지만, 우선순위 큐를 직접 구현해서 임의 노드 삭제 기능을 추가할 수 있다. 마찬가지로 O(N log N)이지만 재귀 함수를 사용하지 않아 세그먼트 트리보다는 빨라 통과가 될 수 있다.

#### 방법 3. 덱
`덱`을 사용하는 방법. 시간 복잡도가 O(N)으로 가장 빠른 방법이다.

```
ex. L = 4
1 5 2 3 = 1 
5 2 3 6 = 2 
2 3 6 4 = 2 
3 6 4 7 = 3
```
만약 윈도우에서 1이 쫓겨나면 2가, 2가 쫓겨나면 3이 후계자로 오른다. 즉, O(1) 시간 내에 계승이 이뤄지면 O(N)으로 설계할 수 있다.

그럼 후계자는 어떤 방법으로 찾을 수 있을까? 위의 예시를 저장소 관점으로 분석해보자.
```
> add 1<br>
1

> add 1<br>
1 5

> add 2<br>
1 5 2
2는 5보다 작으므로 1의 후계자는 2이다.
또한 앞에 2가 있어 5는 앞으로도 후계자가 될 수 없다.
따라서 5를 저장소에서 삭제한다.
1 2

> add 3<br>
1 2 3
3은 2가 삭제되었을 때 후계자 역할을 한다.

> add 6<br>
1 2 3 6
시간이 지나 1은 윈도우 바깥으로 은퇴한다.
따라서 저장소에서도 1을 제외한다.
2 3 6 

> add 4, 7<br>
2 3 4
3 4 7
```
위의 저장소는 앞에서 삭제, 뒤에서 삭제가 모두 필요하다. 따라서 이 기능을 모두 가진 `덱`이 이 문제에 가장 적합한 자료 구조다.

윈도우에서 원소를 삭제한다면 덱에서도 해당 원소 삭제가 되야 한다. 이 원소는 항상 덱의 front에 있으므로, 윈도우에서 삭제한 원소의 id와 덱의 front의 id가 같다면 덱에서도 삭제를 하자. (id는 윈도우에 들어왔을 때 배정된 순서 번호다)
```
> i = [1, N] 순차 탐색<br>
	1. 윈도우 이동
		- 윈도우에서 원소 추가 및 삭제
		- 삭제 원소 id = i - L
		- 삭제 원소 id == 덱의 front.id이면,
			- 덱의 front 삭제
	2. 덱의 back 원소가 새 원소보다 작을 때까지 덱에서 back을 삭제
	3. 새 원소를 덱에 추가
	4. 덱의 front 출력 (현재 최솟값)
```
※ 윈도우 추가 원소 id 증가량은 1이지만, 덱의 추가 원소 id 증가량은 1보다 같거나 크다. 또한 덱에 있는 원소들은 들어온 순서대로 자동 정렬되어 있으므로 front를 삭제할 시점에선 front보다 작은 id를 가진 원소는 이미 윈도우에서 삭제되었다고 볼 수 있다. 따라서 윈도우 삭제 원소 id가 front.id보다 큰 경우는 없으므로 삭제할 때는 front만 확인해도 된다.

## 코드
`덱`을 사용한 코드
```
#include <iostream>
#include <queue>
using namespace std;
struct Node { int num, id; };
int N, L, num;
deque<Node> dq;<br>

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
	cin >> N >> L;<br>
	for (int i = 0; i < N; i++) {
		cin >> num;<br>
		if (!dq.empty())
			if (i - L >= dq.front().id)
				dq.pop_front();

		while (!dq.empty()) {
			if (dq.back().num < num)
				break;
			dq.pop_back();
		}
		dq.push_back({ num, i });
		cout << dq.front().num << " ";
	}
	return 0;
}
```

## 링크
https://www.acmicpc.net/problem/11003<br>
{% endraw %}