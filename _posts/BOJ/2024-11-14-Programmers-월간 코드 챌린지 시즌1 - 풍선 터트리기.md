---
categories:
- Programmers
date: '2024-11-14'
title: '[Programmers] 월간 코드 챌린지 시즌1 - 풍선 터트리기'
---

{% raw %}
> Lv. 3<br>

## 문제
일렬로 나열된 n개의 풍선이 있습니다. 모든 풍선에는 서로 다른 숫자가 써져 있습니다. 당신은 다음 과정을 반복하면서 풍선들을 단 1개만 남을 때까지 계속 터트리려고 합니다.

1.  임의의  **인접한**  두 풍선을 고른 뒤, 두 풍선 중 하나를 터트립니다.
2.  터진 풍선으로 인해 풍선들 사이에 빈 공간이 생겼다면, 빈 공간이 없도록 풍선들을 중앙으로 밀착시킵니다.

여기서 조건이 있습니다. 인접한 두 풍선 중에서  **번호가 더 작은 풍선**을 터트리는 행위는 최대 1번만 할 수 있습니다. 즉, 어떤 시점에서 인접한 두 풍선 중 번호가 더 작은 풍선을 터트렸다면, 그 이후에는 인접한 두 풍선을 고른 뒤 번호가 더 큰 풍선만을 터트릴 수 있습니다.

당신은 어떤 풍선이 최후까지 남을 수 있는지 알아보고 싶습니다. 위에 서술된 조건대로 풍선을 터트리다 보면, 어떤 풍선은 최후까지 남을 수도 있지만, 어떤 풍선은 무슨 수를 쓰더라도 마지막까지 남기는 것이  **불가능**할 수도 있습니다.

일렬로 나열된 풍선들의 번호가 담긴 배열 a가 주어집니다. 위에 서술된 규칙대로 풍선들을 1개만 남을 때까지 터트렸을 때 최후까지 남기는 것이 가능한 풍선들의 개수를 return 하도록 solution 함수를 완성해주세요.

### 제한 사항
-   a의 길이는 1 이상 1,000,000 이하입니다.
    -   `a[i]`는 i+1 번째 풍선에 써진 숫자를 의미합니다.
    -   a의 모든 수는 -1,000,000,000 이상 1,000,000,000 이하인 정수입니다.
    -   a의 모든 수는 서로 다릅니다.

## 해결
다음과 같은 예시를 가정해봅니다:
```
[1, 2, 3, 4, 5] => 1, 2, 3, 4, 5

[5, 4, 3, 2, 1] => 5, 4, 3, 2, 1

[1, 3, 5, 4, 2] => 1, X, X, X, 2

[5, 3, 1, 2, 4] => 5, 3, 1, 2, 4

※ X: 최후까지 생존 불가능
```

3번째 예시에서 3, 5, 4는 양 옆에 자신보다 작은 값이 모두 존재합니다. 따라서 다음과 같은 결론을 얻습니다:
> 양 옆에 자신보다 작은 값이 모두 존재하면 최후까지 살아남을 수 없다.<br>

```
1. 전체 최솟값 찾기
2. 왼쪽부터 전체 최솟값까지 탐색:
	- 현재 값이 현재까지 최솟값보다 작다면 생존 가능
3. 오른쪽부터 전체 최솟값까지 탐색:
	- 현재 값이 현재까지 최솟값보다 작다면 생존 가능
```

## 코드
```
#include <vector>
using namespace std;

int solution(vector<int> a) {
    int minV = 1e9 + 1, answer = 1, N = a.size();
    for(auto n : a)
        minV = min(minV, n);
    int lo = 1e9 + 1, hi = 1e9 + 1;
    for(int i = 0; a[i] != minV; i++)
        if(a[i] < lo)
            answer++, lo = a[i];
    for(int i = N - 1; a[i] != minV; i--)
        if(a[i] < hi)
            answer++, hi = a[i];
    return answer;
}
```

## 링크
<br>https://school.programmers.co.kr/learn/courses/30/lessons/68646
{% endraw %}