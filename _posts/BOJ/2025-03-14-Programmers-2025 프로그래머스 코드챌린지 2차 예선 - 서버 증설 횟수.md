---
categories:
- Programmers
date: '2025-03-14'
title: '[Programmers] 2025 프로그래머스 코드챌린지 2차 예선 - 서버 증설 횟수'
---

{% raw %}
> Lv. 2<br>

## 문제
당신은 온라인 게임을 운영하고 있습니다. 같은 시간대에 게임을 이용하는 사람이  `m`명 늘어날 때마다 서버 1대가 추가로 필요합니다. 어느 시간대의 이용자가  `m`명 미만이라면, 서버 증설이 필요하지 않습니다. 어느 시간대의 이용자가  `n x m`명 이상  `(n + 1) x m`명 미만이라면 최소  `n`대의 증설된 서버가 운영 중이어야 합니다. 한 번 증설한 서버는  `k`시간 동안 운영하고 그 이후에는 반납합니다. 예를 들어,  `k`  = 5 일 때 10시에 증설한 서버는 10 ~ 15시에만 운영됩니다.

하루 동안 모든 게임 이용자가 게임을 하기 위해 서버를 최소 몇 번 증설해야 하는지 알고 싶습니다. 같은 시간대에 서버를 x대 증설했다면 해당 시간대의 증설 횟수는 x회입니다.

0시에서 23시까지의 시간대별 게임 이용자의 수를 나타내는 1차원 정수 배열  `players`, 서버 한 대로 감당할 수 있는 최대 이용자의 수를 나타내는 정수  `m`, 서버 한 대가 운영 가능한 시간을 나타내는 정수  `k`가 주어집니다. 이때, 모든 게임 이용자를 감당하기 위한 최소 서버 증설 횟수를 return 하도록 solution을 완성해 주세요.

### 제한사항
-   `players`의 길이 = 24
    -   0 ≤  `players`의 원소 ≤ 1,000
    -   `players[i]`는  `i`시 ~  `i+1`시 사이의 게임 이용자의 수를 나타냅니다.
-   1 ≤  `m`  ≤ 1,000
-   1 ≤  `k`  ≤ 24

## 해결
모든 시간이 커버되어야 합니다. 시간대를 순회했을 때, 서버를 증설해야 한다면 항상 현재 시간을 서버 시작 시간으로 하는 것이 이득입니다. => `스위핑`, `그리디`
- 현재 서버 개수 `cnt`를 정의합니다. 시간대를 스위핑하면서 `cnt`는 합연산으로 업데이트됩니다.
- 시간대별 서버 요구량 = `players[i] / m` (`i` = 현재 시간)
- 서버 감소량은 배열에 기록됩니다. 현재 시간 `i`에서 `d`만큼 서버를 증설했다면 `i + k` 시간 뒤에 `cnt`가 `d`만큼 감소합니다.

## 코드
```
#include <vector>
using namespace std;
int dt[50], answer, cnt;

int solution(vector<int> players, int m, int k) {
    for(int i = 0; i < 24; i++) {
        int p = players[i] / m;
        cnt -= dt[i];
        if(cnt < p) {
            dt[i + k] += p - cnt;
            answer += p - cnt;
            cnt = p;
        }
    }
    return answer;
}
```

## 링크
<br>https://school.programmers.co.kr/learn/courses/30/lessons/389479
{% endraw %}