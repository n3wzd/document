---
categories:
- Programmers
date: '2024-11-23'
title: '[Programmers] SummerWinter Coding(~2018) - 지형 편집'
---

{% raw %}
> Lv. 4<br>

## 문제
XX 게임에서는 지형 편집 기능을 이용하여 플레이어가 직접 게임 속 지형을 수정할 수 있습니다. 이 게임에서는 1 x 1 x 1 크기의 정육면체 블록을 쌓아 게임 속 지형을 표현합니다. 이때, 블록이 공중에 떠 있거나, 블록 하나가 여러 개의 칸에 걸쳐 놓일 수는 없습니다. 따라서 지형을 편집하기 위해서는 각 칸의 제일 위에 블록 1개를 새로 추가하거나, 제일 위에 있는 블록 한 개를 삭제하는 방식으로 지형을 수정해야 합니다. 이때, 블록 한 개를 새로 추가하거나 삭제하기 위해서는 게임머니를 사용해야 하므로 몇 개의 블록을 추가하고 삭제할지 신중한 선택이 필요합니다.

이 게임을 즐기던 한 플레이어는 N x N 크기의 지역에 자신만의 별장을 만들고 싶어졌습니다. 이를 위해서는 울퉁불퉁한 지형의 모든 칸의 높이가 같아지도록 만들어야 합니다. 이때, 블록 한 개를 추가하려면 P의 비용이, 제거하려면 Q의 비용이 들게 됩니다.  

현재 지형의 상태를 나타내는 배열 land와 블록 한 개를 추가하는 데 필요한 비용 P, 블록 한 개를 제거하는 데 필요한 비용 Q가 매개변수로 주어질 때, 모든 칸에 쌓여있는 블록의 높이가 같아지도록 하는 데 필요한 비용의 최솟값을 return 하도록 solution 함수를 완성해 주세요.

### 제한사항
-   land는 N x N 크기의 2차원 배열이며, N의 범위는 1 ≤ N ≤ 300입니다.
-   land의 각 원소는 각 칸에 놓여 있는 블록의 수를 나타내며, 0 이상 10억 이하의 정수입니다.
-   각 칸에 블록 하나를 추가하는 데는 P, 제거하는 데는 Q의 비용이 들며, P, Q의 범위는 1 ≤ P, Q ≤ 100인 자연수입니다.

## 해결
주어진 배열의 값들을 모두 같은 값으로 만들 때 최소 비용을 계산해야 합니다. 증가, 감소 비용은 변수이므로 모든 경우를 조사할 필요가 있습니다. 배열의 최솟값과 최댓값을 넘는 값으로 통일하는 것은 손해이므로, 항상 배열의 값 범위 내에서 정답이 존재함이 보장됩니다.

다음과 같은 예제를 가정합니다.
```
[0, 100, 500, 1000]
```

통일 값을 `v`, 통일하기 위한 총 증가량을 `p`, 감소량을 `q`으로 정의합니다. 배열에 존재하는 값만을 `v`로 정한다는 가정 하에, 예제를 `v`에 대해 정리하면 다음과 같습니다:
|v|p|q|p 증가량|q 감소량|
|---|---|---|---|---|
|0|0|1600|0|(배열의 총합)|
|100|100|1300|1 * 100|3 * 100|
|500|900|500|2 * 400|2 * 400|
|1000|2400|0|3 * 500|1 * 500|

인접한 `v` 값마다 `p`와 `q`는 두 `v`의 차이만큼 선형적으로 변함을 알 수 있습니다. 따라서 `v`를 입력으로 한 `p`와 `q`의 함수는 모두 1차함수(직선)로 구성됩니다. 최종 정답은 `P`, `Q`를 각각 계수로 하는 `p`와 `q` 함수의 합(이하 최종 함수)의 최솟값입니다. 최종 함수는 1차함수들의 선형적 결합이므로 1차함수로 구성된 함수임이 보장됩니다. 따라서 최종 함수의 기울기가 변하는 순간은 `v`가 배열에 포함된 값인 순간만 존재하며, 이 중에서 최솟값이 존재합니다.

최종 과정은 다음과 같습니다:
```
1. 배열 값 오름차순 정렬
2. 배열의 최솟값이 0이 될 때까지 배열 값 평행이동
3. p, q 초기 설정
4. 배열 값 순차 탐색:
	- 현재 비용 = p * P + q * Q
	- p, q 업데이트
```

## 코드
```
#include <vector>
#include <algorithm>
using namespace std;
typedef long long ll;

ll solution(vector<vector<int>> land2D, int P, int Q) {
    ll answer = ((ll)1 << 62), p = 0, q = 0, k = 1;
    vector<int> land;
    for(auto row : land2D)
        for(auto c : row)
            land.push_back(c);
    sort(land.begin(), land.end());
    
    ll N = land.size(), fisrt = land[0];
    for(int& block : land)
        block -= fisrt, q += block;
    for(int i = 0; i < N - 1; i++) {
        answer = min(answer, p * P + q * Q);
        ll dist = land[i + 1] - land[i];
        p += k * dist, q -= (N - k) * dist, k++;
    }
    answer = min(answer, p * P + q * Q);
    return answer;
}
```

## 링크
<br>https://school.programmers.co.kr/learn/courses/30/lessons/12984
{% endraw %}