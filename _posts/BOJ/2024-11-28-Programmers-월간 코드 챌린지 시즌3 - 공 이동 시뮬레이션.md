---
categories:
- Programmers
date: '2024-11-28'
title: '[Programmers] 월간 코드 챌린지 시즌3 - 공 이동 시뮬레이션'
---

{% raw %}
> Lv. 3<br>

## 문제
`n`행  `m`열의 격자가 있습니다. 격자의 각 행은 0, 1, ...,  `n-1`번의 번호, 그리고 각 열은 0, 1, ...,  `m-1`번의 번호가 순서대로 매겨져 있습니다. 당신은 이 격자에 공을 하나 두고, 그 공에 다음과 같은 쿼리들을 날리고자 합니다.

-   열 번호가 감소하는 방향으로  `dx`칸 이동하는 쿼리 (`query(0, dx)`)
-   열 번호가 증가하는 방향으로  `dx`칸 이동하는 쿼리 (`query(1, dx)`)
-   행 번호가 감소하는 방향으로  `dx`칸 이동하는 쿼리 (`query(2, dx)`)
-   행 번호가 증가하는 방향으로  `dx`칸 이동하는 쿼리 (`query(3, dx)`)

단, 공은 격자 바깥으로 이동할 수 없으며, 목적지가 격자 바깥인 경우 공은 이동하다가 더 이상 이동할 수 없을 때 멈추게 됩니다. 예를 들어, 5행 × 4열 크기의 격자 내의 공이 3행 2열에 있을 때  `query(3, 10)`  쿼리를 받은 경우 공은 4행 2열에서 멈추게 됩니다. (격자의 크기가 5행 × 4열이므로, 0<sub>4번 행과 0</sub>3번 열로 격자가 구성되기 때문입니다.)

격자의 행의 개수  `n`, 열의 개수  `m`, 정수  `x`와  `y`, 그리고 쿼리들의 목록을 나타내는 2차원 정수 배열  `queries`가 매개변수로 주어집니다.  `n × m`개의 가능한 시작점에 대해서 해당 시작점에 공을 두고  `queries`  내의 쿼리들을 순서대로 시뮬레이션했을 때,  `x`행  `y`열에 도착하는 시작점의 개수를 return 하도록 solution 함수를 완성해주세요.

### 제한사항
-   1 ≤  `n`  ≤ 109
-   1 ≤  `m`  ≤ 109
-   0 ≤  `x`  < n
-   0 ≤  `y`  < m
-   1 ≤  `queries`의 행의 개수 ≤ 200,000
    -   `queries`의 각 행은  `[command,dx]`  두 정수로 이루어져 있습니다.
    -   0 ≤  `command`  ≤ 3
    -   1 ≤  `dx`  ≤ 109
    -   이는  `query(command, dx)`를 의미합니다.

## 해결
격자의 크기가 충분히 크기 때문에 모든 시작점을 일일이 조사할 수 없습니다. 하지만 시작점 후보군을 직사각형으로 잡는 것은 가능합니다. 처음에 직사각형의 각 칸의 값은 1입니다. 직사각형은 쿼리에 따라 이동하며, 벽에 벗어나는 이동이면 벗어난 만큼 사각형의 크기가 감소하며 모서리의 값이 더해집니다.

```
예)
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1

L2, D1 이동
0 0 0 0 0
3 1 1 0 0
3 1 1 0 0
3 1 1 0 0
6 2 2 0 0
```

마지막에는 주어진 목적지와 직사각형의 위치 관계를 이용해서 정답을 찾습니다:
- 꼭지점 = 두 모서리 값의 곱
- 꼭지점을 제외한 모서리 = 각 모서리 값
- 꼭지점, 모서리가 아닌 칸 = 1
- 한 위치에서 꼭지점과 꼭지점, 또는 모서리와 모서리가 서로 겹쳐지는 경우가 있습니다. 이때는 합으로 계산합니다.

위의 예제에서 목적지가 (0, 4)이면 정답은 6입니다. 이 방법의 시간 복잡도는 `O(Q)`입니다. (`Q` = 쿼리 개수)

다음으로 사각형의 이동을 구현합시다. 사각형 값에서 변경되는 값은 모서리만 존재하므로 필요한 변수는 다음과 같습니다:
- 사각형의 위치: (`x`, `y`) 
- 4개의 모서리 값: (`s1`, `s2`, `s3`, `s4`)

사각형의 특성은 다음과 같습니다:
- 수평, 수직은 독립입니다. 따라서 수평, 수직에 작용되는 메커니즘은 서로 동일합니다.
- `s1 + s2`의 최댓값은 `M`이고, `s3 + s4`의 `N`입니다. (`N` = 격자 높이, `M` = 격자 길이)

합의 최대가 정해졌다는 점에서 `투 포인터`를 사용해 모서리 값을 구현할 수 있습니다.
- 모서리의 값 변경은 대응되는 포인터를 옮기는 것과 같습니다.
- 모서리의 값은 각 포인터의 이동량 + 1입니다.
- 두 포인터가 겹쳐지는 것까지 가능하며, 순서가 어긋날 수 없습니다.
- 두 포인터가 겹쳐지는 경우는 사각형의 길이가 1이며, 두 모서리 값이 합쳐진 순간입니다. 이 경우에는 모서리의 값이 1 증가하지 않습니다. (이때 모서리 값을 계산한다면 두 이동량의 합에서 1을 빼줍니다.)

포인터가 이동하는 경우는 사각형의 일부가 격자를 벗어난 것이며, 정리하면 다음과 같습니다: (`압축량` = 두 포인터의 이동량 합)
- `x`가 0보다 작을 때: 수평 왼쪽 포인터 증가, `y` = 0
- `x`가 `수평 압축량`보다 클 때: 수평 오른쪽 포인터 감소, `x` = `수평 압축량`
- `y`가 0보다 작을 때: 수직 왼쪽 포인터 증가, `y` = 0
- `y`가 `수직 압축량`보다 클 때: 수직 오른쪽 포인터 감소, `y` = `수직 압축량`

## 코드
```
#include <vector>
using namespace std;
typedef long long ll;
ll dx[] = { -1, 1, 0, 0 }, dy[] = { 0, 0, -1, 1 };

ll solution(int N, int M, int Y, int X, vector<vector<int>> Q) {<br>
    ll h1 = 0, h2 = M - 1, v1 = 0, v2 = N - 1, x = 0, y = 0, answer = 0;
    for(auto q : Q) {
        x += dx[q[0]] * q[1]; y += dy[q[0]] * q[1];
        ll dh = h1 + (M - 1 - h2), dv = v1 + (N - 1 - v2);
        if(x < 0)
            h1 = min(h1 - x, h2), x = 0;
        if(x > dh)<br>
            h2 = max(h2 - (x - dh), h1), x = h1 + (M - 1 - h2);
        if(y < 0)
            v1 = min(v1 - y, v2), y = 0;
        if(y > dv)<br>
            v2 = max(v2 - (y - dv), v1), y = v1 + (N - 1 - v2);
    }
    ll x1 = x, x2 = x + h2 - h1, y1 = y, y2 = y + v2 - v1;
    ll sl = h1 + 1, sr = M - 1 - h2 + 1, su = v1 + 1, sd = N - 1 - v2 + 1;
    if(h1 == h2) sl--;
    if(v1 == v2) su--;
    if(X == x1 && Y == y1) answer += sl * su;
    if(X == x1 && Y == y2) answer += sl * sd;
    if(X == x2 && Y == y1) answer += sr * su;
    if(X == x2 && Y == y2) answer += sr * sd;
    if(X == x1 && Y > y1 && Y < y2) answer += sl;<br>
    if(X == x2 && Y > y1 && Y < y2) answer += sr;<br>
    if(Y == y1 && X > x1 && X < x2) answer += su;<br>
    if(Y == y2 && X > x1 && X < x2) answer += sd;<br>
    if(X > x1 && X < x2 && Y > y1 && Y < y2) answer += 1;<br>
    return answer;
}
```

## 링크
https://school.programmers.co.kr/learn/courses/30/lessons/87391<br>
{% endraw %}