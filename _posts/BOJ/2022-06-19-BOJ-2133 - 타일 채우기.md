---
categories:
- BOJ
date: '2022-06-19'
title: '[BOJ] 2133 - 타일 채우기'
---

{% raw %}
> 골드 IV<br>

## 문제
3×N 크기의 벽을 2×1, 1×2 크기의 타일로 채우는 경우의 수를 구해보자.

#### 입력
첫째 줄에 N(1 ≤ N ≤ 30)이 주어진다.

#### 출력
첫째 줄에 경우의 수를 출력한다.

## 해결
`DP`로 타일을 채우는 문제.

현재 상태를 타일 세로 길이 n, 계산 결과를 타일 경우의 수로 정의하자. 초기 상태는 N이다.

**n = 2**
```
| |   ---   ---
| |   | |   ---
---   | |   ---
```
3가지 경우가 가능하다.

**n = 4**
2 + (2) 길이 문제로 분할 가능하고,
```
--- --- ---    | --- --- |
| --- --- |    | --- --- |
| --- --- |    --- --- ---
```
위와 같이 N = 4 오리지널 경우도 2가지가 존재한다.

**n = 6**
2 + (4), 4 + (2) 길이 문제로 분할 가능하고, 
```
--- --- --- ---    | --- --- --- |
| --- --- --- |    | --- --- --- |
| --- --- --- |    --- --- --- ---
```
위와 같이 N = 6 오리지널 경우도 2가지가 존재한다.

이 규칙을 활용해 점화식을 생성하자.
```
DP(n) = DP(n - 2) * 3
	+ DP(n - 4) * 2
	+ DP(n - 6) * 2 
	...
	+ DP(n - n) * 2

DP(0) = 1
```
참고로 n이 홀수일 때의 경우의 수는 0이다. (타일 채우는 것이 불가능)

## 코드
```
#include <iostream>
using namespace std;
int N, cache[31] = { 1, 0, 3, };

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
	cin >> N;
	for (int i = 4; i <= N; i += 2) {
		cache[i] = 3 * cache[i - 2];
		for(int b = 4; i - b >= 0; b += 2)
			cache[i] += 2 * cache[i - b];
	}
	cout << cache[N];
	return 0;
}
```

## 링크
<br>https://www.acmicpc.net/problem/2133
{% endraw %}