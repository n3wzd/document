---
categories:
- BOJ
date: '2022-05-08'
title: '[BOJ] 2482 - 색상환'
---

{% raw %}
> 골드 IV<br>

## 문제
색을 표현하는 기본 요소를 이용하여 표시할 수 있는 모든 색 중에서 대표적인 색을 고리 모양으로 연결하여 나타낸 것을 색상환이라고 한다. 미국의 화가 먼셀(Munsell)이 교육용으로 고안한 20색상환이 널리 알려져 있다.

색상환에서 인접한 두 색은 비슷하여 언뜻 보면 구별하기 어렵다. 위 그림의 20색상환에서 다홍은 빨강과 인접하고 또 주황과도 인접하다. 풀색은 연두, 녹색과 인접하다. 시각적 대비 효과를 얻기 위하여 인접한 두 색을 동시에 사용하지 않기로 한다.

주어진 색상환에서 시각적 대비 효과를 얻기 위하여 서로 이웃하지 않은 색들을 선택하는 경우의 수를 생각해 보자. 먼셀의 20색상환에서 시각적 대비 효과를 얻을 수 있게 10개의 색을 선택하는 경우의 수는 2이지만, 시각적 대비 효과를 얻을 수 있게 11개 이상의 색을 선택할 수 없으므로 이 경우의 수는 0이다.

주어진 정수 N과 K에 대하여, N개의 색으로 구성되어 있는 색상환 (N색상환)에서 어떤 인접한 두 색도 동시에 선택하지 않으면서 서로 다른 K개의 색을 선택하는 경우의 수를 구하는 프로그램을 작성하시오.

#### 입력
입력 파일의 첫째 줄에 색상환에 포함된 색의 개수를 나타내는 양의 정수 N(4 ≤ N ≤ 1,000)이 주어지고, 둘째 줄에 N색상환에서 선택할 색의 개수 K(1 ≤ K ≤ N)가 주어진다.

#### 출력
첫째 줄에 N색상환에서 어떤 인접한 두 색도 동시에 선택하지 않고 K개의 색을 고를 수 있는 경우의 수를 1,000,000,003 (10억 3) 으로 나눈 나머지를 출력한다.

## 해결
원형 배치에서 이웃하지 않는 조합을 선택하는 경우의 수 문제.

case를 나눠 원형 배치를 일직선 배치 경우의 수의 합으로 구할 수 있다.
```
    1  2
  6      3
    5  4
```

case 1. 1번 색을 선택했을 때
```
    X  X
  X      3
    5  4
```
N번 색과 2번 색을 제외한 배치에서 선택하는 경우의 수와 같다. => DP(n - 3, k - 1)<br>

case 2. 1번 색을 선택하지 않을 때
```
    X  2
  6      3
    5  4
```
1번 색은 이제 선택되지 않으므로, N번 색은 자유롭게 선택될 수 있다.  => DP(n - 1, k)<br>

이제 일직선 배치에서 이웃하지 않는 조합 경우의 수를 구해보자. 경우의 수가 10억을 넘기 때문에 백트래킹으로 일일이 탐색하긴 어렵고, `DP`를 사용해서 조합 경우의 수를 구하자.

부분 문제의 현재 상태는 (색 번호, 선택 가능 개수)로 하고 계산 결과는 경우의 수다. 현재 색을 선택할지, 안할지 분기로 문제를 분할한다. 현재 색을 선택하면 2칸 앞의 색으로 이동한다.
```
DP(n, k) = 
1								(k == 0)
n								(k == 1)
DP(n−2, k−1) + DP(n−1, k)		else
```

최종 경우의 수 = DP(n - 3, k - 1) + DP(n - 1, k)

## 코드
```
#include <iostream>
#include <cmath>
using namespace std;

int N, K;
int cache[1002][1002];
const int p = 1000000003;

int ModAdd(int a, int b)
{
	return ((a % p) + (b % p)) % p;
}

int DP(int _N, int _K)
{
	if (_N < 0 || _K < 0) return 0;
	for (int n = 1; n <= _N; n++) cache[n][0] = 1;
	for (int n = 1; n <= 2; n++) cache[n][1] = n;

	for (int n = 3; n <= _N; n++)
		for (int k = 1; k <= _K; k++)
			cache[n][k] = ModAdd(cache[n - 2][k - 1], cache[n - 1][k]);

	return cache[_N][_K];
}

int main()
{
	ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
	cin >> N >> K;<br>
	cout << ModAdd(DP(N - 3, K - 1), DP(N - 1, K));
	return 0;
}
```

## 링크
https://www.acmicpc.net/problem/2482<br>
{% endraw %}