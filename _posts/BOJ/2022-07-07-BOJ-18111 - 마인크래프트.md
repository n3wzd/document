---
categories:
- BOJ
date: '2022-07-07'
title: '[BOJ] 18111 - 마인크래프트'
---

{% raw %}
> 실버 II<br>

## 문제
팀 레드시프트는 대회 준비를 하다가 지루해져서 샌드박스 게임인 ‘마인크래프트’를 켰다. 마인크래프트는 1 × 1 × 1(세로, 가로, 높이) 크기의 블록들로 이루어진 3차원 세계에서 자유롭게 땅을 파거나 집을 지을 수 있는 게임이다.

목재를 충분히 모은 lvalue는 집을 짓기로 하였다. 하지만 고르지 않은 땅에는 집을 지을 수 없기 때문에 땅의 높이를 모두 동일하게 만드는 ‘땅 고르기’ 작업을 해야 한다.

lvalue는 세로  _N_, 가로  _M_  크기의 집터를 골랐다. 집터 맨 왼쪽 위의 좌표는 (0, 0)이다. 우리의 목적은 이 집터 내의 땅의 높이를 일정하게 바꾸는 것이다. 우리는 다음과 같은 두 종류의 작업을 할 수 있다.

1.  좌표 (_i_,  _j_)의 가장 위에 있는 블록을 제거하여 인벤토리에 넣는다.
2.  인벤토리에서 블록 하나를 꺼내어 좌표 (_i_,  _j_)의 가장 위에 있는 블록 위에 놓는다.

1번 작업은 2초가 걸리며, 2번 작업은 1초가 걸린다. 밤에는 무서운 몬스터들이 나오기 때문에 최대한 빨리 땅 고르기 작업을 마쳐야 한다. ‘땅 고르기’ 작업에 걸리는 최소 시간과 그 경우 땅의 높이를 출력하시오.

단, 집터 아래에 동굴 등 빈 공간은 존재하지 않으며, 집터 바깥에서 블록을 가져올 수 없다. 또한, 작업을 시작할 때 인벤토리에는  _B_개의 블록이 들어 있다. 땅의 높이는 256블록을 초과할 수 없으며, 음수가 될 수 없다.

### 입력
첫째 줄에  _N, M_,  _B_가 주어진다. (1 ≤ _M_,  _N_  ≤ 500, 0 ≤ _B_  ≤ 6.4 × 107)

둘째 줄부터  _N_개의 줄에 각각  _M_개의 정수로 땅의 높이가 주어진다. (_i_ + 2)번째 줄의 (_j_ + 1)번째 수는 좌표 (_i_, _j_)에서의 땅의 높이를 나타낸다. 땅의 높이는 256보다 작거나 같은 자연수 또는 0이다.

### 출력
첫째 줄에 땅을 고르는 데 걸리는 시간과 땅의 높이를 출력하시오. 답이 여러 개 있다면 그중에서 땅의 높이가 가장 높은 것을 출력하시오.

## 해결
땅 파기 경우의 수는 많지만 최대 높이가 한정되어 있다. 공간 높이를 따라 분석하는 `브루트포스` + `스위핑` 문제.

사실 땅을 파는 데는 x, y 위치는 중요하지 않다. 높이 h만 알면 충분하므로 높이에 따라 저장하자.
```
H[258]
- 인덱스: 높이
- 값: 현재 높이에서 끝나는 (x, y)의 개수
```

입력을 받은 다음에는 스위핑 탐색하자.
- 스위핑 대상 = 현재 높이로 맞추기 위해 파야 할 블록 개수, 채워야 할 블록 개수
	- 파야 할 블록 개수의 초기 값은 존재하는 블록의 총 개수다. (입력에서 구할 수 있음)
- 스위핑 방향 = 높이 0 → 256 순차 탐색
- 스위핑 결과 = 최소 작업 시간, 최소 작업 시간일 때 최대 높이

```
int block = SUM; // 현재 높이로 맞추기 위해 파야 할 블록 개수
int space = 0; // 현재 높이로 맞추기 위해 채워야 할 블록 개수
int time = 1 << 30 // 최소 작업 시간
int workH = 0 // 최소 작업 시간일 때 최대 높이
int layer = N * M // 현재 높이에서 존재하는 블록 개수

for (int h = 0; h <= 256; h++) {
	// 현재 높이로 맞추는데 필요한 작업 시간 계산
	int workTime = 2 * block + space;
	
	// 최소 작업 시간 업데이트
	// 인벤토리에 있는 블록으로 작업이 가능한지 판단
	if (block + B >= space && workTime <= time) {
		time = workTime;
		workH = h;
	}

	// 스위핑 대상 업데이트
	layer -= H[h];
	block -= layer;
	space += (N * M) - layer;
}
```

## 코드
```
#include <iostream>
using namespace std;
int N, M, B;
int block = 0, space = 0;
int H[258];

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
	cin >> N >> M >> B;<br>
	for (int y = 0; y < N; y++) {
		for (int x = 0; x < M; x++) {
			int h;
			cin >> h;<br>
			H[h]++;
			block += h;
		}
	}
	
	int time = 1 << 30, workH = 0, layer = N * M;
	for (int h = 0; h <= 256; h++) {
		int workTime = 2 * block + space;
		if (block + B >= space && workTime <= time) {
			time = workTime;
			workH = h;
		}

		layer -= H[h];
		block -= layer;
		space += (N * M) - layer;
	}

	cout << time << " " << workH;
	return 0;
}
```

## 링크
https://www.acmicpc.net/problem/18111<br>
{% endraw %}