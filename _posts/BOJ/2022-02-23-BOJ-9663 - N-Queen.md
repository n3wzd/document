---
categories:
- BOJ
date: '2022-02-23'
title: '[BOJ] 9663 - N-Queen'
---

{% raw %}
>골드 V

## 문제


N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.

N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오. (1 ≤ N < 15)

##  해결
유명한 백트래킹 문제. 재귀 함수로 접근하였다.

접근 1. (N, N) 크기의 보드를 현재 상태로 하고, 퀸을 배치하는 횟수를 재귀 인덱스로 한다. 각 점(x, y)마다 퀸의 배치를 시도한다. (=재귀를 호출한다.) 이 때 보드의 상태를 퀸의 배치에 맞게 업데이트한다. 예를 들어 (5, 5) 크기 보드에서 퀸이 (1, 1), (1, 2)에 있다면 보드 상태는 다음과 같다.
```
1 2 1 1 0
2 2 2 1 1
2 2 2 1 1
1 2 1 1 0
0 2 0 1 1
```
보드의 각 점 상태에서 1 이상인 위치에는 퀸을 배치할 수 없고, 이를 오답 방향으로 간주한다. 탈출 조건은 모든 N개의 퀸을 배치한 상황으로 한다.

이 방법으로 답을 구할 수 있지만, 문제는 매우 오래 걸린다! 보드의 모든 좌표 (x, y)를 탐색하면서, 점을 탐색할 때마다 퀸을 배치하므로 최소 N번의 반복을 수행한다. 따라서 한 함수당 시간 복잡도가 O(N<sup>3</sup>)이다. 사실 이 방법이 오래 걸릴 수 밖에 없는게, 퀸들은 서로 구분되지 않으므로 위 방법대로 한다면 중복 탐색이 발생하게 된다.(=오답을 포함하는 탐색을 수행) 물론 구한 답에서 N!을 나눠서 정답을 알 순 있지만, 그렇다고 아주 오래 걸린다는 것은 변하지 않는다.

접근 2. 다시 백트래킹을 설계해보자. 퀸을 식별하면서 탐색 경로를 줄일 수 있는 아이디어가 있을까?
사실 퀸의 배치를 고려할 때는 모든 점을 고려할 필요가 없다. y축을 기준으로 했을 때, y = 0에 어떤 퀸 1개를 배치하면 y = 0에는 더 이상 다른 퀸을 확정적으로 배치할 수 없다. 따라서 퀸 배치 횟수, y 위치의 값을 일대일 대응으로 하는 동시, 같이 재귀 인덱스로 활용하면 퀸 중복 문제도 해결되고 전체적인 탐색 횟수도 감소한다! 예를 들어 N=5에서 3번째 재귀는 다음과 같다. 1은 이전 퀸 위치, x는 배치 불가(오답 방향), 0은 배치 가능, -는 현재 위치 상에서 고려하지 않는 점이다.
```
- 1 - - -
- - - 1 -
0 x x x x
- - - - -
- - - - -
```
이렇게 하면 함수 당 시간 복잡도가 최대 O(N<sup>2</sup>)로 감소한다.

여담으로 접근2 아이디어는 접근1로 하다가 생각이 안 나서 그냥 자러 갔는데, 자던 도중에 떠올렸다. 아이디어가 생각나자마자 컴퓨터를 키고 작업하였고, 바로 정답이 뜰 때의 쾌감을 잊을 수 있는가. 남들이 말하는 개발자의 로망(?)같은 것을 경험하니 나름 신선했다.

## 코드
```
#include <iostream>
using namespace std;

int n;
int queen[15] = { 0, }; // index - y, value - x
int cases = 0;

void Queen(int y)
{
	if (y == n)
	{
		cases++;
		return;
	}

	bool board[15] = { 0, }; // 0 = safe, 1 = danger
	for (int i = 0; i < y; i++)
	{
		int x = queen[i];
		int leftDiagX = x - (y - i);
		int rightDiagX = x + (y - i);

		board[x] = 1;
		if (leftDiagX >= 0) board[leftDiagX] = 1;
		if (rightDiagX < n) board[rightDiagX] = 1;
	}

	for (int x = 0; x < n; x++)
	{
		if (!board[x])
		{
			queen[y] = x;
			Queen(y + 1);
		}
	}
}

int main()
{
	cin >> n;
	Queen(0);
	cout << cases << endl;
	return 0;
}
```

## 링크
<br>https://www.acmicpc.net/problem/9663
{% endraw %}