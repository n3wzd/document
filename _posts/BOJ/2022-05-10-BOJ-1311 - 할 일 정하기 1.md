---
categories:
- BOJ
date: '2022-05-10'
title: '[BOJ] 1311 - 할 일 정하기 1'
---

{% raw %}
> 골드 I<br>

## 문제
N명의 사람과 N개의 일이 있다. 각 사람은 일을 하나 담당해야 하고, 각 일을 담당하는 사람은 한 명 이어야 한다. 또한, 모든 사람은 모든 일을 할 능력이 있다.

사람은 1번부터 N번까지 번호가 매겨져 있으며, 일도 1번부터 N번까지 번호가 매겨져 있다.

Dij를 i번 사람이 j번 일을 할 때 필요한 비용이라고 했을 때, 모든 일을 하는데 필요한 비용의 최솟값을 구하는 프로그램을 작성하시오.

#### 입력
첫째 줄에 사람과 일의 수 N (1 ≤ N ≤ 20)이 주어진다. 둘째 줄부터 N개의 줄에는 D의 내용이 주어진다. 비용은 10,000보다 작거나 같은 자연수이다.

#### 출력
모든 일을 하는데 필요한 비용의 최솟값을 출력한다.

## 해결
일의 위치를 고정하고, 사람을 적절한 순서로 배치했을 때 최소를 찾는 문제. 즉, 사람의 최적 배치 순서 1개를 찾아야 한다.

순열의 모든 경우를 탐색하는 완전탐색을 사용할 수 있지만, 시간 복잡도가 O(N!)이므로 오래 걸린다. 단, 최종 목표는 순열이 아니라 배치했을 때 최소 비용이므로, 최소 비용만 확인하면 된다.
```
4 (123)
5 (123)
6 (123)
``` 
위의 예시에서 123 순서가 중복되고, 따라서 123으로부터 얻는 최소 비용도 동일하다. 이처럼 중복되는 계산이 존재하므로 `DP`를 고려해볼 수 있다.

현재 상태를 (배치한 사람 목록), 계산 결과는 최소 비용으로 정의한다. 초기 상태는 (공집합)이다.

1번 일부터 N번 일까지 탐색하고, 사람 1명씩 차례대로 배정해서 최소인 경우를 찾으면 된다. 따라서 점화식 함수는 다음과 같다.
```
list = [0, 0, ...] // 배치한 사람 목록
	- 인덱스: 사람 번호
	- 값: 배치 상태 (배치되었으면 1, 초기값은 모두 0)
w = 일의 번호. list에서 1의 개수로 구할 수 있어 생략 가능하나, 계산 편의를 위해 분할 함수의 인자로 추가한다.
work[N][N] // i번 사람이 j번 일을 했을 때 비용

DP(list, w)
{
	1. 현재 모든 인원을 배치했다면 0 반환
	2. cost = INF
	3. 현재 배치되지 않은 모든 인원을 조사한다 => i<br>
		- list2 = list에서 i번 사람을 방문 표시
		- cost = min(cost, DP(list2, w + 1) + work[i][w]);
	4. cost를 반환한다.
}
```
boolean 배열일 경우, `비트마스크`를 사용해서 정수 하나로 치환할 수 있다. 

## 코드
```
#include <iostream>
using namespace std;

int N;
int cache[1 << 20];
int work[20][20];
const int INF = 20 * 10000 + 1;

int DP(int list, int w)
{
	if (w == N) return 0;
	if (cache[list] > 0) return cache[list];<br>

	cache[list] = INF;
	for (int i = 0; i < N; i++)
		if(!(list & (1 << i)))
			cache[list] = min(cache[list], DP(list | (1 << i), w + 1) + work[i][w]);
		
	return cache[list];
}

int main()
{
	ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
	cin >> N;<br>
	for (int i = 0; i < N; i++)
		for (int j = 0; j < N; j++)
			cin >> work[i][j];<br>

	cout << DP(0, 0);
	return 0;
}
```

## 링크
https://www.acmicpc.net/problem/1311<br>
{% endraw %}