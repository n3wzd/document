---
categories:
- Programmers
date: '2024-11-25'
title: '[Programmers] 월간 코드 챌린지 시즌3 - 금과 은 운반하기'
---

{% raw %}
> Lv. 3<br>

## 문제
어느 왕국에 하나 이상의 도시들이 있습니다. 왕국의 왕은 새 도시를 짓기로 결정하였습니다. 해당 도시를 짓기 위해서는 도시를 짓는 장소에 금  `a`  kg과 은  `b`  kg이 전달되어야 합니다.

각 도시에는 번호가 매겨져 있는데,  `i`번 도시에는 금  `g[i]`  kg, 은  `s[i]`  kg, 그리고 트럭 한 대가 있습니다.  `i`번 도시의 트럭은 오직 새 도시를 짓는 건설 장소와  `i`번 도시만을 왕복할 수 있으며, 편도로 이동하는 데  `t[i]`  시간이 걸리고, 최대  `w[i]`  kg 광물을 운반할 수 있습니다. (광물은 금과 은입니다. 즉, 금과 은을 동시에 운반할 수 있습니다.) 모든 트럭은 같은 도로를 여러 번 왕복할 수 있으며 연료는 무한대라고 가정합니다.

정수  `a`,  `b`와 정수 배열  `g`,  `s`,  `w`,  `t`가 매개변수로 주어집니다. 주어진 정보를 바탕으로 각 도시의 트럭을 최적으로 운행했을 때, 새로운 도시를 건설하기 위해 금  `a`  kg과 은  `b`  kg을 전달할 수 있는 가장 빠른 시간을 구해 return 하도록 solution 함수를 완성해주세요.

### 제한사항
-   0 ≤  `a`,  `b`  ≤ 109
-   1 ≤  `g`의 길이 =  `s`의 길이 =  `w`의 길이 =  `t`의 길이 = 도시 개수 ≤ 105
    -   0 ≤  `g[i]`,  `s[i]`  ≤ 109
    -   1 ≤  `w[i]`  ≤ 102
    -   1 ≤  `t[i]`  ≤ 105
    -   `a`  ≤  `g`의 모든 수의 합
    -   `b`  ≤  `s`의 모든 수의 합

## 해결
최대 매장량과 운송량 등 변수가 많으므로 모든 경우를 탐색해야 합니다. 매장량은 충분히 큰 수이므로 나이브한 탐색은 오래 걸려서 사용할 수 없습니다. (최대 1e9 시간대의 시간이 소요됩니다.)

구해야 할 목표는 총 운송 시간입니다. 만약 어떠한 총 운송 시간이 주어졌다면, 이 것이 정답인지 아닌지를 판별하는 것은 도시 개수만큼 시간이 소요됩니다. 그리고 어떠한 총 운송 시간으로 목표 운송량 달성이 불가능하다면, 이 총 운송 시간보다 적은 시간으로 달성이 불가능합니다. 정리하면, 총 운송 시간이 정해졌을 때, 빠른 조건 검증이 가능하며, 총 운송 시간에 대한 출력 결과가 단조증가하므로 `매개변수 탐색`을 사용할 수 있습니다. 어떠한 총 운송 시간이 있을 때, 이 시간에서 운송 달성이 가능하면 왼쪽, 불가능하면 오른쪽 구간을 탐색합니다. 초기 범위는 [0, 4e14]입니다. (최대 금, 은 요구량 × (도시의 최대 운송 시간 × 2))

다음으로 총 운송 시간이 정해졌을 때, 운송 가능성을 판정해야 합니다. 먼저 각 도시에서 주어진 총 운송 시간에 맞는 최대 운송량을 찾아야 합니다. 금과 은은 한꺼번에 운반할 수 있으므로, 금과 은을 트럭 내에서 어떤 비율로 보내든 가능한 최대 운송량만큼 실어서 보내는 것이 항상 이득입니다. 따라서 일반적인 상황이면 각 도시의 광물 최대 운송량 총합이 광물 요구량의 총합보다 같거나 크면 운송 목표를 달성할 수 있습니다.

그러나 이 경우는 어떤 광물의 운송량이 다른 광물 요구량을 커버하면 안되는 경우를 고려하지 못합니다. 예를 들어, 요구량이 금 10, 은 100이고 도시 1은 금 100, 은 0, 도시 2는 금 0, 은 100이고 트럭 용량과 운송 시간은 모두 같은 상황에서, 도시 1의 금 배송량이 도시 2의 은 배송량보다 빨라서 실제 총 운송 시간보다 더 빠른 시간이 출력되는 문제가 있습니다. (문제의 2번째 예제가 이에 해당합니다.) 이 상황을 처리하기 위해 금만 최대로 배송하는 경우, 은만 최대로 배송하는 경우를 추가로 고려해야 합니다. 최종적으로 판정 함수는 다음과 같습니다:
```
1. 모든 도시 순회
	1. 현재 도시에서 최대 운송량 찾기
		- 주어진 총 운송 시간동안 왕복 가능한 횟수 * 트럭 용량
	2. 광물, 금, 은 운송량 총합 업데이트
2. 각 총합이 요구량보다 같거나 커야 통과
```

## 코드
```
#include <vector>
using namespace std;
typedef long long ll;

ll solution(int a, int b, vector<int> G, vector<int> S, vector<int> W, vector<int> T) {<br>
    ll lo = 0, hi = 4e14, N = G.size();
    while(lo < hi) {
        ll t = (lo + hi) / 2;
        ll sum = 0, sumG = 0, sumS = 0;
        for(int i = 0; i < N; i++) {
            ll mt = t / (T[i] * 2);
            mt += t - mt * (T[i] * 2) >= T[i] ? 1 : 0;
            sum += min(mt * W[i], (ll)G[i] + S[i]);
            sumG += min(mt * W[i], (ll)G[i]);
            sumS += min(mt * W[i], (ll)S[i]);
        }
        sum >= a + b && sumG >= a && sumS >= b ? hi = t : lo = t + 1;
    }
    return hi;
}

```

## 링크
https://school.programmers.co.kr/learn/courses/30/lessons/86053<br>
{% endraw %}