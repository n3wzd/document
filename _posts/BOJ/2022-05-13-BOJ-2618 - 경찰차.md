---
categories:
- BOJ
date: '2022-05-13'
title: '[BOJ] 2618 - 경찰차'
---

{% raw %}
> 플래티넘 V<br>

## 문제
어떤 도시의 중심가는 N개의 동서방향 도로와 N개의 남북방향 도로로 구성되어 있다.

모든 도로에는 도로 번호가 있으며 남북방향 도로는 왼쪽부터 1에서 시작하여 N까지 번호가 할당되어 있고 동서방향 도로는 위부터 1에서 시작하여 N까지 번호가 할당되어 있다. 또한 동서방향 도로 사이의 거리와 남 북방향 도로 사이의 거리는 모두 1이다. 동서방향 도로와 남북방향 도로가 교차하는 교차로의 위치는 두 도로의 번호의 쌍인 (동서방향 도로 번호, 남북방향 도로 번호)로 나타낸다.

이 도시에는 두 대의 경찰차가 있으며 두 차를 경찰차1과 경찰차2로 부른다. 처음에는 항상 경찰차1은 (1, 1)의 위치에 있고 경찰차2는 (N, N)의 위치에 있다. 경찰 본부에서는 처리할 사건이 있으면 그 사건이 발생된 위치를 두 대의 경찰차 중 하나에 알려 주고, 연락 받은 경찰차는 그 위치로 가장 빠른 길을 통해 이동하여 사건을 처리한다. (하나의 사건은 한 대의 경찰차가 처리한다.) 그리고 사건을 처리 한 경찰차는 경찰 본부로부터 다음 연락이 올 때까지 처리한 사건이 발생한 위치에서 기다린다. 경찰 본부에서는 사건이 발생한 순서대로 두 대의 경찰차에 맡기려고 한다. 처리해야 될 사건들은 항상 교차로에서 발생하며 경찰 본부에서는 이러한 사건들을 나누어 두 대의 경찰차에 맡기되, 두 대의 경찰차들이 이동하는 거리의 합을 최소화 하도록 사건을 맡기려고 한다.

예를 들어 N=6인 경우, 처리해야 하는 사건들이 3개 있고 그 사건들이 발생된 위치 를 순서대로 (3, 5), (5, 5), (2, 3)이라고 하자. (3, 5)의 사건을 경찰차2에 맡기고 (5, 5)의 사건도 경찰차2에 맡기며, (2, 3)의 사건을 경찰차1에 맡기면 두 차가 이동한 거리의 합은 4 + 2 + 3 = 9가 되 고, 더 이상 줄일 수는 없다.

처리해야 할 사건들이 순서대로 주어질 때, 두 대의 경찰차가 이동하는 거리의 합을 최소화 하도록 사건들을 맡기는 프로그램을 작성하시오.

#### 입력
첫째 줄에는 동서방향 도로의 개수를 나타내는 정수 N(5 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 처리해야 하는 사건의 개수를 나타내는 정수 W(1 ≤ W ≤ 1,000)가 주어진다. 셋째 줄부터 (W+2)번째 줄까지 사건이 발생된 위치가 한 줄에 하나씩 주어진다. 경찰차들은 이 사건들을 주어진 순서대로 처리해야 한다. 각 위치는 동서방향 도로 번호를 나타내는 정수와 남북방향 도로 번호를 나타내는 정수로 주어지며 두 정수 사이에는 빈칸이 하나 있다. 두 사건이 발생한 위치가 같을 수 있다.

#### 출력
첫째 줄에 두 경찰차가 이동한 총 거리를 출력한다. 둘째 줄부터 시작하여 (i+1)번째 줄에 i(1 ≤ i ≤ W)번째 사건이 맡겨진 경찰차 번호 1 또는 2를 출력한다.

## 해결
사건을 경찰차1, 경찰차2에게 적절히 분담하여 전체 이동 거리가 최소가 되어야 한다. 현재 사건 위치에서 가장 가까운 곳에 있는 차를 호출하는 그리디 방법은 전체 최적해를 보장하지 못하므로 사용할 수 없고, 전체 경우를 탐색하는 브루트포스 역시 계산 시간 문제로 사용이 어렵다. 따라서 `DP`를 사용하자.

현재 문제를 정의해보자. 현재 사건에 대해 최소 이동 거리를 알기 위해서는 경찰차1, 경찰차2의 위치 정보가 모두 필요하다. 따라서 현재 상태를 (현재 사건 번호, 경찰차1 위치(x, y), 경찰차2 위치(x, y))로 정의할 수 있다. 그러나 N은 최대 1000이므로 캐시 크기 문제로 사용할 수 없다. 또한, 현재 상태를 (현재 사건 번호, 현재 담당한 경찰차 종류)로 하는 것도 다른 경찰차의 위치 정보를 알 수 없으므로 사용할 수 없다.

필요한 정보를 압축해보자. 경찰차는 사건을 해결하면 다음 사건이 오기까지 움직이지 않는다. 이 성질로 활용해 사건 위치 = 경찰차 위치 정보를 대응할 수 있다. 즉, 경찰차가 최근에 맡은 사건 번호를 알면 현재 위치를 알 수 있다.

현재 상태를 (현재 사건 번호, 이전 사건을 담당한 경찰차 종류, 사건을 담당하지 않은 경찰차의 최근 사건 번호)로 정의하면 1000×2×1000 크기 캐시를 사용해서 필요한 정보를 모두 표현할 수 있다. 하지만 역추적이 힘든 관계로 불편한 면이 있다. 현재 상태의 인덱스 개수를 압축해서 최적화를 해보자.
=> 힌트: `LCS`<br>

현재 상태를 (경찰차1이 최근에 담당한 사건 번호, 경찰차2가 최근에 담당한 사건 번호), 계산 결과는 전체 최소 이동 거리로 정의한다. 초기 상태는 (0, 0)이다.

현재 사건을 기점으로 경찰차1, 경찰차2가 맡는 경우를 모두 고려한다. 점화식은 다음과 같다.
```
DP(car1, car2) =>
	inc = max(car1, car2) + 1  // 현재 사건 번호
	min(Distance(work[inc], work[car1]) + DP(inc, car2), 
		Distance(work[inc], work[car2]) + DP(car1, inc))

work[0] = 
	car1에서 호출한 경우 => (1, 1)<br>
	car2에서 호출한 경우 => (N, N)<br>
```

경로 출력은 `역추적 배열`을 활용하면 된다. 

## 코드
```
#include <iostream>
using namespace std;

class Point {
public:
	int x, y;
	Point() { x = 0, y = 0; }
	Point(int a, int b) { x = a, y = b; }
};

int N, W;
Point work[1002];
int cache[1002][1002];
int trace[1002][1002];

int WorkDistance(Point p1, Point p2) {
	return abs(p1.x - p2.x) + abs(p1.y - p2.y);
}

int DP(int car1, int car2)
{
	if (car1 >= W || car2 >= W) return 0;
	if (trace[car1][car2] != 0) return cache[car1][car2];
	
	int inc = max(car1, car2) + 1;
	Point prePos1 = (car1 >= 1) ? work[car1] : Point(1, 1);
	Point prePos2 = (car2 >= 1) ? work[car2] : Point(N, N);
	int cost1 = WorkDistance(work[inc], prePos1) + DP(inc, car2);
	int cost2 = WorkDistance(work[inc], prePos2) + DP(car1, inc);

	cache[car1][car2] = min(cost1, cost2);
	trace[car1][car2] = (cost1 <= cost2) ? 1 : 2;
	return cache[car1][car2];
}

int main()
{
	ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
	cin >> N >> W;<br>
	for (int i = 1; i <= W; i++)
		cin >> work[i].x >> work[i].y;<br>
	cout << DP(0, 0) << "\n";

	int car1 = 0, car2 = 0;
	for (int i = 1; i <= W; i++)
	{
		cout << trace[car1][car2] << "\n";
		if (trace[car1][car2] == 1) car1 = i;
		else car2 = i;
	}
	return 0;
}
```

## 링크
https://www.acmicpc.net/problem/2618<br>
{% endraw %}