---
categories:
- Programmers
date: '2024-11-21'
title: '[Programmers] 월간 코드 챌린지 시즌1 - 스타 수열'
---

{% raw %}
> Lv. 3<br>

## 문제
다음과 같은 것들을 정의합니다.

-   어떤 수열 x의 부분 수열(Subsequence)이란, x의 몇몇 원소들을 제거하거나 그러지 않고 남은 원소들이 원래 순서를 유지하여 얻을 수 있는 새로운 수열을 말합니다.
    
    -   예를 들어,  `[1,3]`은  `[1,2,3,4,5]`의 부분수열입니다. 원래 수열에서 2, 4, 5를 제거해서 얻을 수 있기 때문입니다.
-   다음과 같은 조건을 모두 만족하는 수열 x를  **스타 수열**이라고 정의합니다.
    
    -   x의 길이가 2 이상의 짝수입니다. (빈 수열은 허용되지 않습니다.)
    -   x의 길이를 2n이라 할 때, 다음과 같은 n개의 집합  `{x[0], x[1]}, {x[2], x[3]}, ..., {x[2n-2], x[2n-1]}`  의 교집합의 원소의 개수가 1 이상입니다.
    -   `x[0] != x[1], x[2] != x[3], ..., x[2n-2] != x[2n-1]`  입니다.
    -   예를 들어,  `[1,2,1,3,4,1,1,3]`은 스타 수열입니다.  `{1,2}, {1,3}, {4,1}, {1,3}`  의 교집합은  `{1}`  이고, 각 집합 내의 숫자들이 서로 다르기 때문입니다.

1차원 정수 배열 a가 매개변수로 주어집니다. a의 모든 부분 수열 중에서 가장 길이가 긴 스타 수열의 길이를 return 하도록 solution 함수를 완성해주세요. 이때, a의 모든 부분 수열 중에서 스타 수열이 없다면, 0을 return 해주세요.

### 제한사항
-   a의 길이는 1 이상 500,000 이하입니다.
    -   a의 모든 수는 0 이상 (a의 길이) 미만입니다.

## 해결
어떠한 수 A를 교집합의 원소로 가정했을 때, A가 아닌 다른 수를 집합의 원소로 해서 스타 수열을 만들 수 있습니다. (아래 예시에서 0에 대한 최대 스타 수열의 길이는 8이며, A에 대한 최대 스타 수열의 길이와 A의 개수가 대응되는 경우입니다.)
```
0 2 1 0 0 2 0 1
```

그러나 집합으로 할 다른 수의 개수가 부족할 수 있으므로 A에 대한 최대 스타 수열의 길이와 A의 개수는 항상 대응되지 않습니다. (아래 예시에서  0에 대한 최대 스타 수열의 길이는 4입니다.)
```
0 1 0 0 2 0
```

집합으로 할 다른 수가 부족한 경우는 크게 2가지가 있습니다.
1. 다른 수가 없는 경우
```
1 0 0 0 1 
ㄴ 가운데 0은 집합 불가
```

2. 집합으로 할 다른 수가 공유 자원인 경우
```
0 1 0
ㄴ 0에서 둘 중 하나만 집합 가능
```

모든 수에 대하여 집합으로 할 다른 수를 카운팅해봅시다. 탐색 방향이 왼쪽이라면 현재 위치에서 가급적 왼쪽 수를 채택하는 것이 이득입니다. 만약 왼쪽 수가 없다면, 오른쪽을 확인하고 선택할 수 있다면 선택합니다. 선택한 수는 `set`에 추가하여 다음 위치에서 선택한 수를 가져가지 못하게 합니다.
```
1. 수열 순차 탐색: 
	- 현재 위치의 왼쪽 조사: 현재 수와 다르고 set에 없다면 추가
	- 추가하지 못했다면 현재 위치의 오른쪽 조사: 현재 수와 다르면 추가
2. 모든 set 탐색: set의 크기 최댓값 찾기
```

## 코드
```
#include <vector>
#include <set>
using namespace std;
set<int> S[500001];

int solution(vector<int> A) {
    int N = A.size(), answer = 0;
    for(int i = 0; i < N; i++) {
        if(i > 0 && A[i - 1] != A[i] && S[A[i]].find(i - 1) == S[A[i]].end())
            S[A[i]].insert(i - 1);
        else if(i < N - 1 && A[i + 1] != A[i])
            S[A[i]].insert(i + 1);
    }
    for(int a = 0; a < N; a++)
        answer = max(answer, (int)S[a].size());  
    return answer * 2;
}
```

## 링크
<br>https://school.programmers.co.kr/learn/courses/30/lessons/70130
{% endraw %}