---
categories:
- BOJ
date: '2022-03-06'
title: '[BOJ] 1300 - K번째 수'
---

{% raw %}
> 골드 II<br>

## 문제
세준이는 크기가 N×N인 배열 A를 만들었다. 배열에 들어있는 수 A[i][j] = i×j 이다. 이 수를 일차원 배열 B에 넣으면 B의 크기는 N×N이 된다. B를 오름차순 정렬했을 때, B[k]를 구해보자.

배열 A와 B의 인덱스는 1부터 시작한다.

**입력**
첫째 줄에 배열의 크기 N이 주어진다. N은 105보다 작거나 같은 자연수이다. 둘째 줄에 k가 주어진다. k는 min(109, N2)보다 작거나 같은 자연수이다.

**출력**
B[k]를 출력한다.

##  해결
시간상 A를 정렬할 수 없으므로 다른 방법을 찾아야 한다.

> A = [ 1 2 3 2 4 6 3 6 9 ]<br>
> B = [ 1 2 2 3 3 4 **6** 6 9 ] // 현재 알 수 없다고 가정하자<br>
> R = [ 1 2 3 4 5 6 7 8 9 ]<br>
> k = 7<br>

정렬된 A의 7번째 위치를 알 수 있을까? 아직은 알 수 없으므로 그냥 A의 모든 값을 무작위로 찍어서 탐색해보자.

5를 선택했다. 그러면 A에 5 이하의 값이 몇 개 존재하는지 찾아보자. (일단 5가 A에 있고 없고는 중요하지 않다)
> 5 - 1 + 2 + 2 + 1 + 0 = 6 X<br>

만약 5가 있다고 생각하면, B에는 6번째 위치에 있을 것이다. 어쨌든 목표 값이 아니므로 R의 탐색 범위를 조정해야 한다. 여기서 왼쪽을 선택하면 결과(=B에서 위치)가 항상 6보다 같거나 작고, 오른쪽을 선택하면 항상 6보다 같거나 크다는 점을 추정할 수 있다. 따라서 입력 값에 따라 출력 값이 단조증가하므로 R 탐색에는 이진 탐색을 적용할 수 있다는 점을 알 수 있다.

6은 k=7보다 작으므로 오른쪽을 탐색한다. R에서 7을 조사해보자.
> 7 - 1 + 2 + 2 + 1 + 0 + 2 + 0 = 8 O (가능성 있음)<br>

k = 7이므로 8은 목표했던 값보다 크다. 따라서 원하는 답이 아닌... 것이 아니라 답일 수도 있다! 왜냐하면 B에는 중복 원소가 존재할 수 있기 때문. 만약 B = { ... 4, 6, 6, ... } 이라면 B[7] = B[8]이다. 따라서 목표 값보다 큰 값도 이진 탐색 범위에 포함해야 한다.

R에서 6을 선택해보자.
> 6 - 1 + 2 + 2 + 1 + 0 + 2 = 8 O (가능성 있음)<br>

마찬가지로 가능성이 있다. R->5일 때는 6이었고, R->6일 때는 8이므로, B[7] = B[8] = 6이라고 결론지을 수 있다. 따라서 해답은 B[7] = 6이다.

**이진 탐색**
```
start = 1;
end = min(1000000000, n * n);
mid = 0;

while (start < end)
	mid = (start + end) / 2;
	if (Checker(mid)) end = mid;
	else start = mid + 1;
return end;
```
시작, 끝 범위는 탐색 범위로, 문제 조건에 따라 1부터 min(1000000000, n * n)이다. 현재 조건(Checker)에 맞으면 왼쪽을 탐색한다. 조건에 맞지 않으면 오른쪽을 탐색한다. 출력 값은 B[k]이다.

**조건**
현재 선택한 값보다 같거나 작은 값이 A에서 몇 개 존재하는지(=sum) 확인한다. sum이 k보다 같거나 크면 true다.

실행 시간은 여유롭지 않으므로 sum을 구하는 시간은 최대한 빨라야 한다. A에는 i*j 값을 가진 원소만 존재하므로 규칙을 발견해 수식을 적절히 세우면 O(sqrt(mid)) 시간 이내에 계산할 수 있다.

약수를 구하는 알고리즘에 따르면 sqrt(mid)까지만 조사해도 모든 약수를 알 수 있다.
```
120
sqrt(120) = 10.xxxxx
1 120 = 1 × 1, 1 × 2, ... 1 × 120 -> (120 - 1)개 // 1 x 1은 중복되므로 1을 뺀다.<br>
2 60 = 2 × 2, 2 × 3, ... 2 x 60 -> ((60-1) - 1)개 // 2 x 1은 앞에서 계산했다.<br>
...
10 12 -> ((12-9) - 1)개 // 제곱근 이하까지 탐색하므로 항상 중복원소(10 x 10)를 거친다.<br>
```
일반화하면 다음과 같다. (i = 현재 인덱스, 범위 [1, sqrt(mid)])
> sum += (mid / i) - (i-1)) * 2 - 1<br>

단, mid가 n보다 큰 경우도 있다. 이 때는 n까지 탐사해야 한다.
```
5) = 2.4xxxx
1 × 1
1 × 2
1 × 3
1 × 4 -> A에 존재하지 않음 <br>
```
따라서 최종 수식은 다음과 같다.
> sum += (min((mid / i), n) - (i-1)) * 2 - 1<br>

**시간 복잡도**
O(sqrt(N) × log N)

## 코드
```
#include <iostream>
#include <cmath>
using namespace std;

int n, k;

int BS()
{
	int start = 1;
	int end = (int)min((long long)1000000000, (long long)n * n);
	int mid = 0;

	while (start < end)
	{
		mid = (start + end) / 2;

		int sum = 0, range = sqrt(mid);
		for (int i = 1; i <= range; i++)
			sum += (min((mid / i), n) - (i-1)) * 2 - 1;
		
		if (k <= sum) end = mid;
		else start = mid + 1;
	}

	return end;
}

int main()
{
	cin >> n >> k;<br>
	cout << BS() << endl;
	return 0;
}
```

## 링크
https://www.acmicpc.net/problem/1300<br>
{% endraw %}