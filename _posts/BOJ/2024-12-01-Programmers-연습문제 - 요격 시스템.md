---
categories:
- Programmers
date: '2024-12-01'
title: '[Programmers] 연습문제 - 요격 시스템'
---

{% raw %}
> Lv. 2<br>

## 문제
A 나라가 B 나라를 침공하였습니다. B 나라의 대부분의 전략 자원은 아이기스 군사 기지에 집중되어 있기 때문에 A 나라는 B 나라의 아이기스 군사 기지에 융단폭격을 가했습니다.  
A 나라의 공격에 대항하여 아이기스 군사 기지에서는 무수히 쏟아지는 폭격 미사일들을 요격하려고 합니다. 이곳에는 백발백중을 자랑하는 요격 시스템이 있지만 운용 비용이 상당하기 때문에 미사일을 최소로 사용해서 모든 폭격 미사일을 요격하려 합니다.  
A 나라와 B 나라가 싸우고 있는 이 세계는 2 차원 공간으로 이루어져 있습니다. A 나라가 발사한 폭격 미사일은 x 축에 평행한 직선 형태의 모양이며 개구간을 나타내는 정수 쌍 (s, e) 형태로 표현됩니다. B 나라는 특정 x 좌표에서 y 축에 수평이 되도록 미사일을 발사하며, 발사된 미사일은 해당 x 좌표에 걸쳐있는 모든 폭격 미사일을 관통하여 한 번에 요격할 수 있습니다. 단, 개구간 (s, e)로 표현되는 폭격 미사일은 s와 e에서 발사하는 요격 미사일로는 요격할 수 없습니다. 요격 미사일은 실수인 x 좌표에서도 발사할 수 있습니다.  
각 폭격 미사일의 x 좌표 범위 목록  `targets`이 매개변수로 주어질 때, 모든 폭격 미사일을 요격하기 위해 필요한 요격 미사일 수의 최솟값을 return 하도록 solution 함수를 완성해 주세요.

### 제한 사항
-   1 ≤  `targets`의 길이 ≤ 500,000
-   targets의 각 행은 [s,e] 형태입니다.
    -   이는 한 폭격 미사일의 x 좌표 범위를 나타내며, 개구간 (s, e)에서 요격해야 합니다.
    -   0 ≤ s < e ≤ 100,000,000

## 해결
최소 개수로 모든 개구간을 커버해야 합니다. 어떤 구간을 커버할 때, 최대한 다른 구간도 많이 커버하는 것이 이득입니다. 부분 최적이 전체 최적을 보장합니다. => `그리디`<br>

현재 구간을 현재 범위로 설정합니다. 그리고 시작점과 가까운 다음 구간을 가져옵니다. 이 구간이 현재 범위와 걸쳐진다면 같이 커버가 가능합니다. 이때 현재 범위가 다음 구간의 교집합으로 축소됩니다. 현재 범위가 커버하지 못하는 다음 구간을 만나면, 정답 개수에 1을 더하고 현재 범위를 다음 구간으로 리셋합니다.
```
1. 구간 목록 정렬: 시작 오름차순
2. 목록 순회:
	- 현재 범위 설정: 현재 구간 시작, 끝
	- 다음 구간 탐색:
	    - 다음 구간이 현재 범위에 걸쳐진다면 현재 범위 업데이트 (교집합)
	    - 현재 범위에 포함되지 않다면 커버 불가
		    - 현재 범위 재설정 및 정답 업데이트
```

## 코드
```
#include <vector>
#include <algorithm>
using namespace std;

int solution(vector<vector<int>> targets) {<br>
    int N = targets.size(), answer = 0;
    sort(targets.begin(), targets.end(), [](const vector<int>& a, const vector<int>& b) {
        return a[0] != b[0] ?  a[0] < b[0] : a[1] > b[1];<br>
    });
    for(int i = 0; i < N;) {
        int lo = targets[i][0], hi = targets[i][1];
        for(i++; i < N; i++) {
            if(!(targets[i][1] <= lo || targets[i][0] >= hi)) {
                lo = max(lo, targets[i][0]);
                hi = min(hi, targets[i][1]);
            }
            else
                break;
        }
        answer++;
    }
    return answer;
}
```

## 링크
https://school.programmers.co.kr/learn/courses/30/lessons/181188
{% endraw %}