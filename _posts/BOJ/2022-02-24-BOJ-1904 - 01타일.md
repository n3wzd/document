---
categories:
- BOJ
date: '2022-02-24'
title: '[BOJ] 1904 - 01타일'
---

{% raw %}
>실버 III

## 문제
지원이에게 2진 수열을 가르쳐 주기 위해, 지원이 아버지는 그에게 타일들을 선물해주셨다. 그리고 이 각각의 타일들은 0 또는 1이 쓰여 있는 낱장의 타일들이다.

어느 날 짓궂은 동주가 지원이의 공부를 방해하기 위해 0이 쓰여진 낱장의 타일들을 붙여서 한 쌍으로 이루어진 00 타일들을 만들었다. 결국 현재 1 하나만으로 이루어진 타일 또는 0타일을 두 개 붙인 한 쌍의 00타일들만이 남게 되었다.

그러므로 지원이는 타일로 더 이상 크기가 N인 모든 2진 수열을 만들 수 없게 되었다. 예를 들어, N=1일 때 1만 만들 수 있고, N=2일 때는 00, 11을 만들 수 있다. (01, 10은 만들 수 없게 되었다.) 또한 N=4일 때는 0011, 0000, 1001, 1100, 1111 등 총 5개의 2진 수열을 만들 수 있다.

지원이가 만들 수 있는 길이가 N인 모든 2진 수열의 개수를 15746으로 나눈 나머지를 출력한다. (1 ≤ N ≤ 1,000,000)

##  해결
큰 경우의 수를 구하는 문제. N은 최대 1,000,000까지 입력될 수 있으므로 시간 초과와 메모리 초과(스택 오버플로우)를 주의한다. 또한 연산 대상의 값이 매우 크므로 오버플로우가 발생하기 때문에 나머지 연산의 적용이 필요하다.

**방법 1.**
같은 것을 포함한 순열로 접근한다. 00 타일의 개수와 1 타일의 개수로 케이스를 분류한 다음, 모든 케이스별로 00 타일과 1 타일의 순열을 구하는 방법. 팩토리얼을 구할 때는 DP(동적 계획법)를 적용하여 시간 초과를 피할 수 있다. 

하지만 치명적인 문제가 있다. 순열을 구하다 보면 나눗셈을 거쳐야 하는데, 나눗셈에 대한 나머지 연산 분배법칙이 성립하지 않기 때문. 페르마의 소정리를 활용하면 어떻게든 해결할 수는 있겠지만, 다른 방법을 찾아보는 게 더 빠를 수도...

**방법 2.**
문제를 분리하여 재귀적으로 접근한다. 00 타일의 길이는 2, 1 타일의 길이는 1이고 둘 중 하나를 미리 배정했다는 생각으로 바라보면, 다음과 같이 문제를 분리할 수 있다. (N ≥ 2)
> Solution(N) = Solution(N - 1) + Solution(N - 2)<br>
> Solution(1) = 1<br>
> Solution(0) = 0<br>

DP를 적용한 재귀함수로 구현할 수 있겠지만, N이 매우 크므로 C++ 기준으로 스택 오버플로우가 발생할 것이다. 따라서 반복문으로 구현하자. 이전 2개의 항을 기억하는 변수를 추가하고 반복문을 돌리면 된다.

여담으로 위에서 구한 수열은 그 유명한 피보나치 수열이 맞다. 따라서 처음부터 피보나치 수열로 접근해도 문제는 풀린다.

## 코드
```
#include <iostream>
using namespace std;

const int p = 15746;

int ModAdd(int a, int b)
{
	return ((a % p) + (b % p)) % p;
}

int main()
{
	int n;
	int cases = 1, A = 1, B = 0;
	cin >> n;<br>

	for (int i = 0; i < n; i++)
	{
		cases = ModAdd(A, B);
		B = A;
		A = cases;
	}
	cout << cases << endl;

	return 0;
}
```

## 링크
https://www.acmicpc.net/problem/1904<br>
{% endraw %}