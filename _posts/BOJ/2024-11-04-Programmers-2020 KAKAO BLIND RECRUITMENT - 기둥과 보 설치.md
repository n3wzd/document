---
categories:
- Programmers
date: '2024-11-04'
title: '[Programmers] 2020 KAKAO BLIND RECRUITMENT - 기둥과 보 설치'
---

{% raw %}
> Lv. 3<br>

## 문제
빙하가 깨지면서 스노우타운에 떠내려 온  **"죠르디"**는 인생 2막을 위해 주택 건축사업에 뛰어들기로 결심하였습니다. "죠르디"는  **기둥과 보**를 이용하여 벽면 구조물을 자동으로 세우는 로봇을 개발할 계획인데, 그에 앞서 로봇의 동작을 시뮬레이션 할 수 있는 프로그램을 만들고 있습니다.  
프로그램은  **2차원 가상 벽면**에 기둥과 보를 이용한 구조물을 설치할 수 있는데, 기둥과 보는  **길이가 1인 선분**으로 표현되며 다음과 같은 규칙을 가지고 있습니다.

-   기둥은 바닥 위에 있거나 보의 한쪽 끝 부분 위에 있거나, 또는 다른 기둥 위에 있어야 합니다.
-   보는 한쪽 끝 부분이 기둥 위에 있거나, 또는 양쪽 끝 부분이 다른 보와 동시에 연결되어 있어야 합니다.

단, 바닥은 벽면의 맨 아래 지면을 말합니다.

2차원 벽면은  **`n x n`**  크기 정사각 격자 형태이며, 각 격자는  **`1 x 1`**  크기입니다. 맨 처음 벽면은 비어있는 상태입니다. 기둥과 보는 격자선의 교차점에 걸치지 않고, 격자 칸의 각 변에 정확히 일치하도록 설치할 수 있습니다. 

벽면의 크기 n, 기둥과 보를 설치하거나 삭제하는 작업이 순서대로 담긴 2차원 배열 build_frame이 매개변수로 주어질 때, 모든 명령어를 수행한 후 구조물의 상태를 return 하도록 solution 함수를 완성해주세요.

### 제한사항
-   n은 5 이상 100 이하인 자연수입니다.
-   build_frame의 세로(행) 길이는 1 이상 1,000 이하입니다.
-   build_frame의 가로(열) 길이는 4입니다.
-   build_frame의 원소는 [x, y, a, b]형태입니다.
    -   x, y는 기둥, 보를 설치 또는 삭제할 교차점의 좌표이며, [가로 좌표, 세로 좌표] 형태입니다.
    -   a는 설치 또는 삭제할 구조물의 종류를 나타내며, 0은 기둥, 1은 보를 나타냅니다.
    -   b는 구조물을 설치할 지, 혹은 삭제할 지를 나타내며 0은 삭제, 1은 설치를 나타냅니다.
    -   벽면을 벗어나게 기둥, 보를 설치하는 경우는 없습니다.
    -   바닥에 보를 설치 하는 경우는 없습니다.
-   구조물은 교차점 좌표를 기준으로 보는 오른쪽, 기둥은 위쪽 방향으로 설치 또는 삭제합니다.
-   구조물이 겹치도록 설치하는 경우와, 없는 구조물을 삭제하는 경우는 입력으로 주어지지 않습니다.
-   최종 구조물의 상태는 아래 규칙에 맞춰 return 해주세요.
    -   return 하는 배열은 가로(열) 길이가 3인 2차원 배열로, 각 구조물의 좌표를 담고있어야 합니다.
    -   return 하는 배열의 원소는 [x, y, a] 형식입니다.
    -   x, y는 기둥, 보의 교차점 좌표이며, [가로 좌표, 세로 좌표] 형태입니다.
    -   기둥, 보는 교차점 좌표를 기준으로 오른쪽, 또는 위쪽 방향으로 설치되어 있음을 나타냅니다.
    -   a는 구조물의 종류를 나타내며, 0은 기둥, 1은 보를 나타냅니다.
    -   return 하는 배열은 x좌표 기준으로 오름차순 정렬하며, x좌표가 같을 경우 y좌표 기준으로 오름차순 정렬해주세요.
    -   x, y좌표가 모두 같은 경우 기둥이 보보다 앞에 오면 됩니다.

## 해결
- 주어진 건설 쿼리를 그대로 구현하면 됩니다. => `시뮬레이션`
- 기둥 원점은 아래 점이며, 보 원점은 왼쪽 점입니다. 한 위치에 기둥과 보는 중첩될 수 있습니다.

설치 조건은 다음과 같습니다:
> 기둥: 현재 면이 바닥 or 한 칸 밑에 기둥 존재 or 한 칸 왼쪽 또는 현재 칸에 보 존재<br>
> 보: 한 칸 밑 또는 한 칸 오른쪽 대각선 밑에 기둥 존재 or 한 칸 왼쪽과 오른쪽에 보 모두 존재<br>

삭제 조건은 주어진 구조물을 제거했을 때 인접한 8방향 구조물과 현재 위치의 구조물이 모두 설치 조건을 만족한다면 제거를 합니다. 그렇지 않다면 유지합니다.

최종 반환은 격자를 주어진 순서대로 탐색하면 됩니다.

좌표 경계는 빈 칸으로 처리하는 것이 구현상 편리합니다. (좌표를 0이 아닌 1부터 시작하게 합니다.)

## 코드
```
#include <vector>
using namespace std;
int N, dx[9] = { 1, 0, -1, 0, 1, 1, -1, -1, 0 }, dy[9] = { 0, 1, 0, -1, 1, -1, 1, -1, 0 };
bool board[104][104][2];

bool isSafe(int x, int y, int a) {
    return (a == 0) ?
        (y == 1 || (y > 1 && board[y - 1][x][0]) || board[y][x - 1][1] || board[y][x][1]) :
        ((board[y - 1][x][0] || board[y - 1][x + 1][0]) || (board[y][x - 1][1]) && (board[y][x + 1][1]));
}

void install(int x, int y, int a) {
    if (isSafe(x, y, a))
        board[y][x][a] = 1;
}

void uninstall(int x, int y, int a) {
    board[y][x][a] = 0;
    bool ok = 1;
    for (int d = 0; d < 9; d++) {
        int nx = x + dx[d], ny = y + dy[d];
        for (int b = 0; b < 2; b++) {
            if (board[ny][nx][b])
                ok &= isSafe(nx, ny, b);
        }
    }
    if (!ok) board[y][x][a] = 1;
}

vector<vector<int>> solution(int n, vector<vector<int>> build_frame) {
    N = n + 1; vector<vector<int>> answer;
    for (auto frame : build_frame) {
        frame[3] == 1 ?
            install(frame[0] + 1, frame[1] + 1, frame[2]) :
            uninstall(frame[0] + 1, frame[1] + 1, frame[2]);
    }
    for (int x = 1; x <= N; x++)
        for (int y = 1; y <= N; y++)
            for (int a = 0; a < 2; a++)
                if (board[y][x][a])
                    answer.push_back({ x - 1, y - 1, a });
    return answer;
}
```

## 링크
<br>https://school.programmers.co.kr/learn/courses/30/lessons/60061
{% endraw %}