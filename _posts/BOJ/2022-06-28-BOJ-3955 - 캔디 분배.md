---
categories:
- BOJ
date: '2022-06-28'
title: '[BOJ] 3955 - 캔디 분배'
---

{% raw %}
> 플래티넘 V<br>

## 문제
창영이는 선영이가 사탕을 공평하게 나누어주지 않으면 친구들을 때릴정도로 사탕을 좋아한다.

따라서, 선영이는 다음 파티에 사용할 사탕을 구매하기 전에 고민을 하기 시작했다.

만약 파티에 K명이 참가한다면, 공정하게 나누어주려면 K×X개를 사야 한다. (X는 자연수)

선영이는 항상 적어도 한 아이는 사탕을 잃어버린다는 사실을 알고 있다. 그래서 캔디를 하나 더 구매해 총 (K×X+1)개를 구매하려고 한다.

사탕은 봉지 단위로 판매한다. 한 봉지에는 사탕이 총 C개 들어있다. 문제의 조건을 만족하면서 구매할 수 있는 사탕 봉지의 개수를 구하는 프로그램을 작성하시오.

### 입력
첫째 줄에 테스트 케이스의 개수 t가 주어진다. (0 < t < 100) 각 테스트 케이스는 한 줄로 이루어져 있고, K와 C가 공백으로 구분되어져서 주어진다. (1 ≤ K, C ≤ 109) 선영이는 부자가 아니기 때문에 109개를 넘는 사탕 봉지를 구매하지 못한다.

### 출력
각 테스트 케이스에 대해서 문제의 조건을 만족시키면서 구매할 수 있는 사탕 봉지가 없다면, "IMPOSSIBLE"을 출력한다. 이 경우가 아닌 경우에는 선영이가 구매해야 하는 사탕 봉지의 수를 출력한다. 만약, 가능한 봉지의 수가 여러개라면 아무거나 출력한다.

## 해결
문제의 식을 정리하면,
> K×X + C×Y = 1 (X < 0, Y > 0)<br>

이 식에서 적당한 Y를 출력하면 된다.

`확장 유클리드 알고리즘`을 사용하면 위 식의 해를 빠르게 구할 수 있다. K, C의 최대 공약수가 1이라면 X, Y가 항상 존재한다. 만약 최대 공약수가 1이 아니면 "IMPOSSIBLE"을 출력한다.

단, X는 0이 아닌 음의 정수(= Y는 자연수)여야 한다. 유클리드 알고리즘으로 해를 구했는데 X가 0보다 같거나 크면, X가 음수가 될 때까지 X에 C를 빼고, Y에 K를 더하면 된다. 이때 Y가 10<sup>9</sup>보다 크면 문제 조건에 따라 "IMPOSSIBLE"을 출력한다.


## 코드
```
#include <iostream>
typedef long long ll;
using namespace std;

ll GCD2(ll a, ll b, ll* x, ll* y) {
	if (a == 0) {
		*x = 0, *y = 1;
		return b;
	}
	ll x1, y1;
	ll gcd = GCD2(b % a, a, &x1, &y1);

	*x = y1 - (b / a) * x1;
	*y = x1;
	return gcd;
}

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
	int Q;
	cin >> Q;<br>
	while (Q--) {
		ll x, y, a, b;
		cin >> a >> b;<br>
		ll g = GCD2(a, b, &x, &y);
		while (x >= 0) {
			x -= b, y += a;
		}
		if (g == 1 && y <= 1e9) cout << y << "\n";
		else cout << "IMPOSSIBLE\n";
	}
	return 0;
}
```

## 링크
https://www.acmicpc.net/problem/3955
{% endraw %}