---
categories:
- BOJ
date: '2022-05-01'
title: '[BOJ] 20040 - 사이클 게임'
---

{% raw %}
> 골드 IV<br>

## 문제
사이클 게임은 두 명의 플레이어가 차례대로 돌아가며 진행하는 게임으로, 선 플레이어가 홀수 번째 차례를, 후 플레이어가 짝수 번째 차례를 진행한다. 게임 시작 시 0 부터  _n_  − 1 까지 고유한 번호가 부여된 평면 상의 점  _n_  개가 주어지며, 이 중 어느 세 점도 일직선 위에 놓이지 않는다. 매 차례 마다 플레이어는 두 점을 선택해서 이를 연결하는 선분을 긋는데, 이전에 그린 선분을 다시 그을 수는 없지만 이미 그린 다른 선분과 교차하는 것은 가능하다. 게임을 진행하다가 처음으로 사이클을 완성하는 순간 게임이 종료된다. 사이클  _C_는 플레이어가 그린 선분들의 부분집합으로, 다음 조건을 만족한다.

> _C_에 속한 임의의 선분의 한 끝점에서 출발하여 모든 선분을 한 번씩만 지나서 출발점으로 되돌아올 수 있다.<br>

문제는 선분을 여러 개 그리다 보면 사이클이 완성 되었는지의 여부를 판단하기 어려워 이미 사이클이 완성되었음에도 불구하고 게임을 계속 진행하게 될 수 있다는 것이다. 이 문제를 해결하기 위해서 게임의 진행 상황이 주어지면 몇 번째 차례에서 사이클이 완성되었는지, 혹은 아직 게임이 진행 중인지를 판단하는 프로그램을 작성하려 한다.

입력으로 점의 개수  _n_과  _m_  번째 차례까지의 게임 진행 상황이 주어지면 사이클이 완성 되었는지를 판단하고, 완성되었다면 몇 번째 차례에서 처음으로 사이클이 완성된 것인지를 출력하는 프로그램을 작성하시오.

#### 입력
입력은 표준입력을 사용한다. 입력의 첫 번째 줄에는 점의 개수를 나타내는 정수 3 ≤  _n_  ≤ 500,000 과 진행된 차례의 수를 나타내는 정수 3 ≤  _m_  ≤ 1,000,000 이 주어진다. 게임에서 사용하는  _n_개의 점에는 0 부터  _n_  − 1 까지 고유한 번호가 부여되어 있으며, 이 중 어느 세 점도 일직선 위에 놓이지 않는다. 이어지는  _m_  개의 입력 줄에는 각각  _i_번째 차례에 해당 플레이어가 선택한 두 점의 번호가 주어진다 (1 ≤  _i_  ≤  _m_).

#### 출력
출력은 표준출력을 사용한다. 입력으로 주어진 케이스에 대해,  _m_  번째 차례까지 게임을 진행한 상황에서 이미 게임이 종료되었다면 사이클이 처음으로 만들어진 차례의 번호를 양의 정수로 출력하고,  _m_  번의 차례를 모두 처리한 이후에도 종료되지 않았다면 0을 출력한다.

## 해결
간선이 하나씩 주어질 때 사이클이 생기는 시점을 찾는 문제. 입력 간선 수가 충분히 많기 때문에 매 회차마다 `DFS/BFS`를 사용하기 어렵다. `Disjoint Set`을 사용하자.

트리는 사이클이 없고, 항상 정점 개수가 간선 개수보다 1개 많다. 만약 트리 내부에 새로운 간선 1개가 추가되면 사이클이 발생하므로, 간선의 두 정점이 같은 트리에 속한다면 사이클이 발생한다고 판단할 수 있다.
```
if (Find(A) == Find(B))
	=> 사이클 발생<br>
Union(A, B) // 트리 간선 연결
```

## 코드
```
#include <iostream>
using namespace std;

int N, M;
int parent[500002];

int Find(int n)
{
	int p = n;
	while (parent[p] >= 0) p = parent[p];
	if(parent[n] >= 0) parent[n] = p;
	return p;
}

void Union(int a, int b)
{
	int p1 = Find(a);
	int p2 = Find(b);
	if (p1 == p2) return;

	if (parent[p1] < parent[p2])
	{
		parent[p1] += parent[p2];
		parent[p2] = p1;
	}
	else
	{
		parent[p2] += parent[p1];
		parent[p1] = p2;
	}
}

int main()
{
	cin >> N >> M;<br>
	for (int i = 0; i <= N; i++)
		parent[i] = -1;

	int cycle = 0;
	for (int i = 1; i <= M; i++)
	{
		int a, b;
		scanf("%d%d", &a, &b);
		if (Find(a) == Find(b) && cycle == 0) cycle = i;
		Union(a, b);
	}
	cout << cycle;
	return 0;
}
```

## 링크
https://www.acmicpc.net/problem/20040<br>
{% endraw %}