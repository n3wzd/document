---
categories:
- BOJ
date: '2022-02-23'
title: '[BOJ] 2580 - 스도쿠'
---

{% raw %}
>골드 IV

## 문제
게임 시작 전 스도쿠 판에 쓰여 있는 숫자들의 정보가 주어질 때 모든 빈 칸이 채워진 최종 모습을 출력하는 프로그램을 작성하시오.

아홉 줄에 걸쳐 한 줄에 9개씩 게임 시작 전 스도쿠판 각 줄에 쓰여 있는 숫자가 한 칸씩 띄워서 차례로 주어진다. 스도쿠 판의 빈 칸의 경우에는 0이 주어진다. 스도쿠 판을 규칙대로 채울 수 없는 경우의 입력은 주어지지 않는다.

모든 빈 칸이 채워진 스도쿠 판의 최종 모습을 아홉 줄에 걸쳐 한 줄에 9개씩 한 칸씩 띄워서 출력한다. 스도쿠 판을 채우는 방법이 여럿인 경우는 그 중 하나만을 출력한다.

baekjoon의 백트래킹 알고리즘으로 풀 수 있는 입력만 주어진다.

##  해결
문제에서 백트래킹이 언급되었으니 백트래킹으로 접근해보자.

스도쿠의 칸을 탐색 대상으로 하며, 칸의 위치(x, y)를 재귀 인덱스로 한다. (0, 0)부터 (8, 8)까지 차례대로 모든 칸을 탐색하게 되며, (8, 8)까지 탐색 완료했다면 탐색이 종료된다. (=탈출 조건)

오답 방향은 이미 숫자가 존재하는 칸으로 한다. 따라서 비어 있는 칸을 대상으로 가능한 숫자를 기록하고 재귀를 호출한다. 기입 가능한 숫자 판단은 스도쿠 규칙에 따른다. 칸에 여러 숫자를 기입할 수 있는 경우는 작은 숫자부터 차례대로 시도해본다. 만약 칸에서 숫자를 기입할 수 없는 경우는 오답 방향이므로 퇴각 처리하여 재귀 호출을 중단한다.

주의사항으로 문제 조건에 따라 해답은 단 하나만 출력해야 한다. 스도쿠는 문제에 따라 여러 풀이가 존재할 수 있는데, 백트래킹을 통해 탐색하면 모든 해답을 찾아내므로 별도의 처리가 없으면 모든 해답을 출력할 것이다. 따라서 하나의 해답을 찾는 순간, 백트래킹 탐색을 중단하도록 설정한다.

```
Backtracking(x, y)
1. (x, y)부터 보드의 칸을 순차적으로 탐색
	1. 현재 칸의 숫자가 0인가?
		1. 스도쿠 규칙에 따라 기입할 수 있는 숫자 목록 L(x, y)을 구한다.
		2. L(x, y)에 있는 모든 숫자를 차례대로 하나씩 기입.
			1. Backtracking(x, y) // 다음 스탯 이동
			2. 출력이 완료되었는가? -> true면 탈출 // 이전 스탯 복귀<br>
		3. 더 이상 기입할 숫자가 없다. -> 전체적으로 오답이므로 탈출 // 이전 스탯 복귀<br>
2. 모든 칸 탐색 완료 = 정답 위치 -> 보드를 출력하고, 출력 플래그를 설정한다.<br>
```
스도쿠 규칙 구현은 가로, 세로, 정사각형 범위에 없는 숫자를 찾아내는 로직으로 접근하면 된다.

## 코드
```
#include <iostream>
using namespace std;

int sudoku[9][9] = { 0, };
bool isSubmit = false;

void Print()
{
	if (isSubmit) return;

	for (int i = 0; i < 9; i++)
	{
		for (int j = 0; j < 9; j++)
			cout << sudoku[i][j] << " ";
		cout << endl;
	}
	isSubmit = true;
}

void Answer(int posX, int posY)
{
	int x = posX, y = posY;

	while (y < 9)
	{
		if (sudoku[y][x] == 0)
		{
			// input number in (posX, posY)
			bool mask[10] = { 0, }; // 1 = exist, 0 = none, index = number(1-9)
			int sqX = x / 3 * 3, sqY = y / 3 * 3;
			bool mark = false;

			for (int xi = 0; xi < 9; xi++) // horizontal
				mask[sudoku[y][xi]] = 1;
			for (int yi = 0; yi < 9; yi++) // vertical
				mask[sudoku[yi][x]] = 1;
			for (int dy = 0; dy < 3; dy++) // square
				for (int dx = 0; dx < 3; dx++)
					mask[sudoku[sqY + dy][sqX + dx]] = 1;

			for (int i = 1; i <= 9; i++)
			{
				if (!mask[i]) // success - move to next state
				{
					sudoku[y][x] = i;
					Answer(x, y);
					if (isSubmit) return; // print only one answer
				}
			}
			sudoku[y][x] = 0;
			return; // fail - wrong answer! return to previous state
		}

		x++;
		if (x >= 9)
		{
			x = 0;
			y++;
		}
	}

	Print(); // final answer
}

int main()
{
	for (int i = 0; i < 9; i++)
		for (int j = 0; j < 9; j++)
			cin >> sudoku[i][j];<br>

	Answer(0, 0);
	return 0;
}
```

## 테스트 케이스
#### 1
```
입력
0 4 8 0 0 1 0 6 3
0 9 7 5 6 2 0 4 1
6 0 0 8 3 4 5 7 0
9 0 5 0 4 8 0 2 7
7 6 0 2 0 5 9 0 0
1 0 2 9 0 0 6 5 4
4 0 9 0 8 6 7 1 2
0 1 6 4 2 7 3 9 0
0 7 3 1 5 0 0 0 6

출력
5 4 8 7 9 1 2 6 3
3 9 7 5 6 2 8 4 1
6 2 1 8 3 4 5 7 9
9 3 5 6 4 8 1 2 7
7 6 4 2 1 5 9 3 8
1 8 2 9 7 3 6 5 4
4 5 9 3 8 6 7 1 2
8 1 6 4 2 7 3 9 5
2 7 3 1 5 9 4 8 6
```

#### 2
```
입력
6 0 5 0 0 8 0 4 0
0 0 8 0 9 0 0 6 0
0 7 0 0 0 0 0 1 0
3 0 0 8 0 0 0 0 0
0 9 0 3 0 1 0 8 0
0 0 0 0 0 9 0 0 2
0 4 0 0 0 0 0 7 0
0 2 0 0 6 0 8 0 0
0 8 0 7 0 0 5 0 6

출력
6 3 5 2 1 8 7 4 9
2 1 8 4 9 7 3 6 5
9 7 4 5 3 6 2 1 8
3 6 7 8 2 4 9 5 1
4 9 2 3 5 1 6 8 7
8 5 1 6 7 9 4 3 2
5 4 6 9 8 2 1 7 3
7 2 3 1 6 5 8 9 4
1 8 9 7 4 3 5 2 6
```

#### 3 (스페셜 저지 - 답이 여러 가지인 경우)
```
입력
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0

출력
1 2 3 4 5 6 7 8 9
4 5 6 7 8 9 1 2 3
7 8 9 1 2 3 4 5 6
2 1 4 3 6 5 8 9 7
3 6 5 8 9 7 2 1 4
8 9 7 2 1 4 3 6 5
5 3 1 6 4 2 9 7 8
6 4 2 9 7 8 5 3 1
9 7 8 5 3 1 6 4 2
```

## 링크
https://www.acmicpc.net/problem/2580<br>
{% endraw %}