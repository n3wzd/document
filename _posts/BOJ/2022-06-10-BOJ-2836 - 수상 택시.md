---
categories:
- BOJ
date: '2022-06-10'
title: '[BOJ] 2836 - 수상 택시'
---

{% raw %}
> 골드 III<br>

## 문제
상근이가 살고 있는 도시에는 큰 강이 흐르고 있고, 모든 사람의 집은 이 강 근처에 있다. 집은 0번부터 M번까지 강을 따라서 번호가 매겨져 있고, 인접한 집 사이의 거리는 모두 1 킬로미터이다.

상근이는 0번 집에 살고 있고, 보트를 이용해서 사람들을 운송하는 일을 하고 있다.

오늘은 저녁때까지 M번 집으로 가야한다. 상근이는 M번 집으로 가는 길에 사람들을 태워주려고 한다.

오늘 상근이의 수상 택시를 타려고 하는 사람은 총 N명이다. 상근이는 각 사람들이 탑승할 위치와 목적지를 알고 있다. 상근이의 보트는 매우 커서 N명 모두 보트에 태울 수 있다.

예를 들어, 사람 A가 2번 집에서 8번으로 가려고 하고, B가 6에서 4로 가려고 하는 경우를 생각해보자. 상근이는 0번 집에서 시작해서, 2번에서 A를 태우고, 6번에서 B를 태울 것이다. 그 다음 4로 돌아가 B를 내려주고, 8번에서 A를 내려다준다. 그 다음에 원래 상근이가 가려고 했던 M번 집으로 가면 된다.

상근이가 모든 사람을 데려다주고, M번 집으로 가기 위해서 이동해야 하는 거리의 최솟값을 구하는 프로그램을 작성하시오.

#### 입력
첫째 줄에 N과 M이 주어진다. (N ≤ 300,000, 3 ≤ M ≤ 10<sup>9</sup>)

다음 N개 줄에는 각 사람이 상근이의 수상 택시를 타는 위치와 목적지가 주어진다. 모든 숫자는 0과 M 사이이다.

#### 출력
첫째 줄에 상근이의 이동 거리의 최솟값을 출력한다.

## 해결
아이디어를 이용해서 문제를 추상화하면, `2170 - 선 긋기` 문제와 비슷하게 바꿀 수 있다. `스위핑` 기법을 적용해보자.

우선, 0부터 M까지 이동해야 하는 것은 자명하다. 따라서 시작점이 끝점보다 작은 정방향 이동은 무시해도 상관없다.

시작점이 끝점보다 큰 역방향 이동을 탐색해보자. 동선이 최대한 겹치지 않게 이동해야 한다. 이동 종류에 대해 크게 3가지 case가 있다.

**case 1. 이동이 다른 이동에 포함되는 경우**
```
----|---#--------#---|-----

> 최소 이동<br>
|--------------------|
	|----------------|
    |---------------------|
```
큰 이동에 포함되므로 작은 이동은 무시할 수 있다.

**case 2. 한 쪽 끝만 미포함인 경우**
```
----#---|--------#---|-----

> 최소 이동<br>
|--------------------|
	|----------------|
    |---------------------|
```
이동의 최소 끝과 최대 끝을 이은 선이 항상 최소 이동이다.

**case 3. 분리된 이동**
```
----#---#--------|---|-----

> 이동 1<br>
|--------------------|
	|----------------|
    |---------------------|

> 이동 2 (최소)<br>
|-------|
	|---|
	|----------------|
                 |---|
                 |--------|
```
이동 선 조각을 합해보면 방법 1보다 방법 2가 항상 작다는 점을 알 수 있다.

그리고 방법 2의 이동 조각은 다음과 같이 정리할 수 있다.
```
----#---#--------|---|-----

> 최소 이동<br>
|-------|
	|---|
	|---|
	    |------------|
                 |---|
                 |---|
                     |----|
```
(역방향 이동의 선 길이) × 2에서 M을 더하면 답이 된다는 점을 알 수 있다.

구현은 `2170 - 선 긋기`에서 현재 선 길이를 2배해서 더하고, 마지막에 M을 더하면 된다.

## 코드
```
#include <iostream>
#include <algorithm>
typedef long long ll;
using namespace std;
class Line {
public:
	ll lo, hi;
	Line() {}
	Line(ll a, ll b) { lo = a, hi = b; }
};
ll N, M;
ll sum = 0;
Line line[300001];

bool cmp(Line a, Line b) {
	return a.lo < b.lo;
}

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
	cin >> N >> M;<br>
	for (int i = 0; i < N; i++)
		cin >> line[i].hi >> line[i].lo;<br>
	sort(line, line + N, cmp);

	ll lo = -1, hi = -1;
	for (int i = 0; i < N; i++) {
		ll newLo = line[i].lo, newHi = line[i].hi;
		if (newLo > newHi)<br>
			continue;

		if (newLo > hi) {<br>
			sum += (hi - lo) * 2;
			lo = newLo, hi = newHi;
		}
		if (newHi > hi) <br>
			hi = newHi;
	}
	sum += (hi - lo) * 2;
	cout << sum + M;
	return 0;
}
```

## 링크
https://www.acmicpc.net/problem/2836

## 이전 문제
https://www.acmicpc.net/problem/2170
{% endraw %}