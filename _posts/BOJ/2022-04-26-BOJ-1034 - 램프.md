---
categories:
- BOJ
date: '2022-04-26'
title: '[BOJ] 1034 - 램프'
---

{% raw %}
> 골드 V<br>

## 문제
지민이는 각 칸마다 (1×1크기의 정사각형) 램프가 들어있는 직사각형 모양의 탁자를 샀다. 모든 램프는 켜져있거나 꺼져있다. 각 열의 아래에는 스위치가 하나씩 달려있는데, 이 스위치를 누를 때마다 그 열에 있는 램프의 상태가 바뀐다. 켜져있는 램프는 꺼지고, 꺼져있는 램프는 켜진다)

만약 어떤 행에 있는 램프가 모두 켜져있을 때, 그 행이 켜져있다고 말한다. 지민이는 스위치를 K번 누를 것이다. 서로다른 스위치 K개를 누르지 않아도 된다. 지민이는 스위치를 K번 눌러서 켜져있는 행을 최대로 하려고 한다.

지민이의 탁자에 있는 램프의 상태와 K가 주어졌을 때, 스위치를 K번 누른 후에 켜져있는 행의 최댓값을 구하는 프로그램을 작성하시오.

#### 입력
첫째 줄에 N과 M이 주어진다. N은 행의 개수이고, M은 열의 개수이다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 램프의 상태가 주어진다. 1이 켜져있는 상태이고, 0이 꺼져있는 상태이다. 마지막 줄에는 K가 주어진다. K는 1,000보다 작거나 같은 자연수 또는 0이다.

#### 출력
첫째 줄에 문제의 정답을 출력한다.

## 해결
스위치에 대해 `완전 탐색`을 활용해야 할 것 같지만, 최대 경우의 수가 2<sup>50</sup>이다. M = 25부터 무한로딩 모드로 들어가버리기 때문에 모든 경우를 탐색하는 것은 무리다. 답이 될 수 있는 확실한 경우만 조사해서 탐색 횟수를 줄여야 한다.

```
000
001
001
100
010
```
위의 예시에서 켜진 행이 0보다 큰 경우는 000, 001, 100, 010 뿐이다. 열 스위치를 키면 해당 열의 모든 전구가 반전되므로, 만약 0번, 1번 열 스위치를 작동하면 001과 같은 모양을 제외하고 켜진 행이 되는 경우는 존재하지 않는다. 따라서 같은 모양이 가장 많이 등장한 횟수가 켜진 행의 최대와 같다고 결론지을 수 있다! 현재 상황에서 최적을 찾는 `그리디` 방법을 사용하자.

여기서 스위치 작동 횟수는 K번 고정이라는 조건이 있다. 스위치를 제자리에서 껐다 키면 건드리지 않은 것과 동일하다는 규칙을 활용하자. K 값에 따라 켜진 행이 될 수 있는 경우를 조사하면 다음과 같다.
```
K = 0
=> 0의 개수 = 0 (ex. 111)<br>

K = 1
=> 0의 개수 = 1 (ex. 011, 101 ...)<br>

K = 2
=> 0의 개수 = 0, 2<br>

K = 3
=> 0의 개수 = 1, 3<br>

K = 4
=> 0의 개수 = 0, 2, 4<br>

K = 5
=> 0의 개수 = 1, 3, 5<br>

K = 6
=> 0의 개수 = 0, 2, 4, 6<br>
...
```
따라서 다음과 같은 수식을 얻는다.
```
zero = 현재 행에서 0의 개수
if(zero <= K && zero % 2 == K % 2)
	=> 켜진 행 가능<br>
```

전체 과정
```
1. 행을 조사한다.
2. 현재 행이 켜진 행이 될 수 있는지 확인한다.
3. 켜진 행이 될 수 있다면, 보드에서 현재 행과 같은 모양인 행의 개수를 구한다.
	- 최대를 넘는다면, 최대를 갱신한다.
```

## 코드
```
#include <iostream>
#include <cmath>
using namespace std;

int N, M, K;
string board[52];
int max_bulb = 0;

int main()
{
	cin >> N >> M;<br>
	for (int y = 0; y < N; y++)
		cin >> board[y];<br>
	cin >> K;<br>

	for (int y = 0; y < N; y++)
	{
		int zero = 0;
		for (int x = 0; x < M; x++)
			if (board[y][x] == '0')
				zero++;

		if (zero <= K && zero % 2 == K % 2)
		{
			int cnt = 0;
			for (int y2 = 0; y2 < N; y2++)
				if (board[y] == board[y2])
					cnt++;
			max_bulb = max(max_bulb, cnt);
		}
	}
	cout << max_bulb << endl;
	return 0;
}
```

## 링크
https://www.acmicpc.net/problem/1034
{% endraw %}