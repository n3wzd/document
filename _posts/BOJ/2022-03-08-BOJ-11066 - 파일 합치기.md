---
categories:
- BOJ
date: '2022-03-08'
title: '[BOJ] 11066 - 파일 합치기'
---

{% raw %}
> 골드 III<br>

## 문제
소설가인 김대전은 소설을 여러 장(chapter)으로 나누어 쓰는데, 각 장은 각각 다른 파일에 저장하곤 한다. 소설의 모든 장을 쓰고 나서는 각 장이 쓰여진 파일을 합쳐서 최종적으로 소설의 완성본이 들어있는 한 개의 파일을 만든다. 이 과정에서 두 개의 파일을 합쳐서 하나의 임시파일을 만들고, 이 임시파일이나 원래의 파일을 계속 두 개씩 합쳐서 소설의 여러 장들이 연속이 되도록 파일을 합쳐나가고, 최종적으로는 하나의 파일로 합친다. 두 개의 파일을 합칠 때 필요한 비용(시간 등)이 두 파일 크기의 합이라고 가정할 때, 최종적인 한 개의 파일을 완성하는데 필요한 비용의 총 합을 계산하시오.

예를 들어, C1, C2, C3, C4가 연속적인 네 개의 장을 수록하고 있는 파일이고, 파일 크기가 각각 40, 30, 30, 50 이라고 하자. 이 파일들을 합치는 과정에서, 먼저 C2와 C3를 합쳐서 임시파일 X1을 만든다. 이때 비용 60이 필요하다. 그 다음으로 C1과 X1을 합쳐 임시파일 X2를 만들면 비용 100이 필요하다. 최종적으로 X2와 C4를 합쳐 최종파일을 만들면 비용 150이 필요하다. 따라서, 최종의 한 파일을 만드는데 필요한 비용의 합은 60+100+150=310 이다. 다른 방법으로 파일을 합치면 비용을 줄일 수 있다. 먼저 C1과 C2를 합쳐 임시파일 Y1을 만들고, C3와 C4를 합쳐 임시파일 Y2를 만들고, 최종적으로 Y1과 Y2를 합쳐 최종파일을 만들 수 있다. 이때 필요한 총 비용은 70+80+150=300 이다.

소설의 각 장들이 수록되어 있는 파일의 크기가 주어졌을 때, 이 파일들을 하나의 파일로 합칠 때 필요한 최소비용을 계산하는 프로그램을 작성하시오.

**입력**
프로그램은 표준 입력에서 입력 데이터를 받는다. 프로그램의 입력은 T개의 테스트 데이터로 이루어져 있는데, T는 입력의 맨 첫 줄에 주어진다.각 테스트 데이터는 두 개의 행으로 주어지는데, 첫 행에는 소설을 구성하는 장의 수를 나타내는 양의 정수 K (3 ≤ K ≤ 500)가 주어진다. 두 번째 행에는 1장부터 K장까지 수록한 파일의 크기를 나타내는 양의 정수 K개가 주어진다. 파일의 크기는 10,000을 초과하지 않는다.

**출력**
프로그램은 표준 출력에 출력한다. 각 테스트 데이터마다 정확히 한 행에 출력하는데, 모든 장을 합치는데 필요한 최소비용을 출력한다.

##  해결
>  두 개씩 합쳐서 소설의 여러 장들이 **연속이 되도록** 파일을 합쳐나가고<br>

인접한 파일끼리 합치는 것만 가능하다. 이러한 조건으로 인해 최소합으로 계산하는 그리디 방법은 사용하기 어렵다. 모든 경우를 탐색하는 DP를 사용해보자.

현재 상태를 탐색 범위 [start, end]로 하자.
```
DP(start, end) = min(DP(start, d) + DP(d + 1, end)) + Sum(start, end)  // (d = start ... end - 1)
```
start부터 end까지 탐색하는 문제를 아래 예시와 같이 2개로 분할 가능하다. (마치 중간에 칸막이가 있는 것처럼 생각할 수 있다)
```
ex. 10 20 30 50 70 [start = 1, end = 5]
(10) (20 30 50 70)
(10 20) (30 50 70)
(10 20 30) (50 70)
(10 20 30 50) (70)
```
이러한 식으로 이진 트리처럼 분할이 진행된다. 만약 start = end라면 파일이 1개이므로 더 이상 재귀를 호출하지 않는다.

DP의 계산 값은 start부터 end까지 파일 생성 누적 최소 비용이다. 여기서 임시 파일 크기와 파일 생성 비용은 별개다. 임시 파일 크기는 합성된 파일의 크기로, start부터 end까지 있는 파일 크기를 전부 더하면 알 수 있다. 파일 생성 비용은 지금까지 생성했던 임시 파일들의 누적 크기다. 임시 파일 크기는 d와 관계없이 일정한 것과 달리, 파일 생성 비용은 임시 파일을 어떻게 생성했는지에 따라 달라진다.

Sum은 시작부터 끝의 연속 합을 구하는 함수로, O(N)의 시간이 걸린다. Sum 역시 이전에 계산한 경우를 재참조하는 경우가 있으므로 메모이제이션을 적용해서 시간을 단축할 수 있다.

Tip. 이 문제는 실행 한번에 여러 테이스 케이스를 돌린다. 따라서 매 테스트 케이스마다 캐시를 초기화해야 한다는 점을 기억하자.

## 코드
```
#include <iostream>
#include <cmath>
using namespace std;
const int INT_MAXV = 2147483647;

int n;
int page[501];
int fsize[501][501];
int rsum[501][501];

int GetSum(int start, int end)
{
	if (rsum[start][end] != 0) return rsum[start][end];

	rsum[start][end] = 0;
	for (int i = start; i <= end; i++)
		rsum[start][end] += page[i];
	return rsum[start][end];
}

int DP(int start, int end)
{
	if (end == start) return 0;
	if (fsize[start][end] != 0) return fsize[start][end];

	int min_size = INT_MAXV;
	int range_sum = GetSum(start, end);
	for (int d = start; d <= end - 1; d++)
		min_size = min(min_size, range_sum + DP(start, d) + DP(d + 1, end));

	fsize[start][end] = min_size;
	return fsize[start][end];
}

int main()
{
	int t;
	cin >> t;<br>
	for (; t > 0; t--)<br>
	{
		scanf("%d", &n);
		for (int i = 0; i < n; i++)
		{
			scanf("%d", &page[i]);
			for (int j = 0; j < n; j++)
			{
				fsize[i][j] = 0;
				rsum[i][j] = 0;
			}
		}

		printf("%d\n", DP(0, n - 1));
	}
	
	return 0;
}
```

## 링크
https://www.acmicpc.net/problem/11066
{% endraw %}