---
categories:
- BOJ
date: '2022-04-26'
title: '[BOJ] 1033 - 칵테일'
---

{% raw %}
> 골드 II<br>

## 문제
august14는 세상에서 가장 맛있는 칵테일이다. 이 칵테일을 만드는 정확한 방법은 아직 세상에 공개되지 않았지만, 들어가는 재료 N개는 공개되어 있다.

경근이는 인터넷 검색을 통해서 재료 쌍 N-1개의 비율을 알아냈고, 이 비율을 이용해서 칵테일에 들어가는 전체 재료의 비율을 알아낼 수 있다.

총 재료 쌍 N-1개의 비율이 입력으로 주어진다. 이때, 칵테일을 만드는데 필요한 각 재료의 양을 구하는 프로그램을 작성하시오. 이때, 필요한 재료의 질량을 모두 더한 값이 최소가 되어야 한다. 칵테일을 만드는 재료의 양은 정수이고, 총 질량은 0보다 커야한다.

비율은 "a b p q"와 같은 형식이고, a번 재료의 질량을 b번 재료의 질량으로 나눈 값이 p/q라는 뜻이다.

#### 입력
첫째 줄에 august14를 만드는데 필요한 재료의 개수 N이 주어지며, N은 10보다 작거나 같은 자연수이다.

둘째 줄부터 N-1개의 줄에는 재료 쌍의 비율이 한 줄에 하나씩 주어지는데, 문제 설명에 나온 형식인 "a b p q"로 주어진다. 재료는 0번부터 N-1까지이며, a와 b는 모두 N-1보다 작거나 같은 음이 아닌 정수이다. p와 q는 9보다 작거나 같은 자연수이다.

#### 출력
첫째 줄에 칵테일을 만드는데 필요한 각 재료의 질량을 0번 재료부터 순서대로 공백으로 구분해 출력한다.

##  해결
트리 구조(=사이클 없음)로 주어지는 그래프에서 정점끼리 비율을 유지한 상태에서 최소를 구해야 한다.

현재 그래프의 각 정점은 최솟값을 유지하고 있다고 하자. 그래프에 새로운 연결 간선이 추가되면, 각 연결 요소(=연결 안된 분리된 부분)에 적절한 계수를 곱해서 입력된 연결 비율을 반영해야 한다. 그럼 계수는 어떤 방법으로 구할 수 있을까? 예시를 통해 찾아보자.
```
1153 - 128    5  -  1
        2  -  3
```
2-3 비율 간선이 들어왔을 때, 이를 그래프에 반영해야 한다. 우선, 기존 정점과 호환이 되어야 하므로 기존 정점과 새 정점간의 최소공배수를 구한다. (최소공배수는 최대공약수로 구할 수 있으며, 최대공약수는 `유클리드 호제법`으로 찾을 수 있다.)
```
1153 - 128    5  -  1
        2  -  3
      (×64)  (×5)
       128 -  15
```
단, 입력된 비율은 유지되어야 한다. 곱한 값의 최소공배수를 이용하자.
```
LCM(64, 5) = 320
```
이 수를 입력된 간선에 곱한다. 그러면 각 연결 요소에 곱해야 하는 계수를 알 수 있다.
```
1153 - 128    5  -  1
       640 - 960
계수 A = 640 / 128 = 5
계수 B = 960 / 5 = 192
```
계수를 반영하고 입력된 간선을 그래프에 반영한다. 연결 요소에 계수를 곱하는 과정은 그래프 탐색 알고리즘인 `DFS/BFS`를 사용하면 된다.
```
5765 - 640 - 960 - 192
```

전체 과정
```
1. 연결 간선을 입력 받는다. => v-w
	- 연결 간선의 비율을 최소로 맞춘다. (서로소) => 최대공약수 이용
2. 수식을 통해 각각 정점 v, w가 속한 연결 요소에 곱할 계수를 찾는다. => A, B
3. DFS/BFS를 사용해 각 연결 요소에 계수 A, B를 곱한다.
4. 입력된 연결 간선을 그래프에 반영하여 연결 요소를 잇는다.
```

## 코드
```
#include <iostream>
#include <vector>
using namespace std;

int N;
long long recipe[11];
vector<int> conn[11];
bool visited[11];

long long GCD(long long a, long long b)
{
	return (a % b == 0) ? b : GCD(b, a % b);
}

void DFS(long long v, long long d)
{
	visited[v] = true;
	recipe[v] *= d;

	int len = conn[v].size();
	for (int i = 0; i < len; i++)
	{
		int next = conn[v][i];
		if (!visited[next])
		{
			DFS(next, d);
			visited[next] = true;
		}
	}
}

int main()
{
	cin >> N;
	for (int i = 0; i < N; i++) recipe[i] = 1;

	for (int i = 0; i < N - 1; i++)
	{
		long long v, w, a, b;
		cin >> v >> w >> a >> b;

		long long g = GCD(a, b);
		a /= g, b /= g;

		long long g1 = (a * recipe[v]) / GCD(a, recipe[v]);
		long long g2 = (b * recipe[w]) / GCD(b, recipe[w]);
		long long g3 = ((g1 / a) * (g2 / b)) / GCD((g1 / a), (g2 / b));

		for (int i = 0; i < N; i++) visited[i] = 0;
		DFS(v, (g3 * a) / recipe[v]);
		for (int i = 0; i < N; i++) visited[i] = 0;
		DFS(w, (g3 * b) / recipe[w]);

		conn[v].push_back(w);
		conn[w].push_back(v);
	}
	
	for (int i = 0; i < N; i++)
		cout << recipe[i] << " ";

	return 0;
}
```

## 테스트 케이스
입력 1
```
10 
0 1 9 8 
1 2 9 8 
2 3 9 8 
3 4 9 8 
4 5 9 8 
5 6 9 8 
6 7 9 8 
7 8 9 8 
8 9 9 8 
```

출력 1
```
387420489 344373768 306110016 272097792 241864704 214990848 191102976 169869312 150994944 134217728
```

입력 2-1
```
10 
2 3 5 6 
6 7 4 5 
7 8 6 7 
0 1 1 2 
1 2 3 4 
8 9 8 9 
3 4 7 8 
4 5 9 1 
5 6 2 3 
```

입력 2-2
```
10 
0 1 1 2 
1 2 3 4 
2 3 5 6 
3 4 7 8 
4 5 9 1 
5 6 2 3 
6 7 4 5 
7 8 6 7 
8 9 8 9 
```

출력 2
```
315 630 840 1008 1152 128 192 240 280 315
```

## 링크
<br>https://www.acmicpc.net/problem/1033
{% endraw %}