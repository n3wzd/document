---
categories:
- BOJ
date: '2022-05-19'
title: '[BOJ] 1023 - 괄호 문자열'
---

{% raw %}
> 플래티넘 III<br>

## 문제
괄호 문자열은 다음과 같이 정의 한다.

1.  빈 문자열은 괄호 문자열이다.
2.  `S`가 괄호 문자열일 때,  `(S)`도 괄호 문자열이다.
3.  `S`와  `T`가 괄호 문자열이라면,  `ST`도 괄호 문자열이다.
4.  모든 괄호 문자열은 위의 3개 규칙으로만 만들 수 있다.

이 문제에서는 괄호 문자열이 아닌 문자열이 나온다. 만약 문자열이 ‘`(`’와 ‘`)`’로만 이루어져 있고, 괄호 문자열이 아니라면, 그 문자열을 괄호ㄴㄴ문자열이라고 한다.

길이가 N인 괄호ㄴㄴ문자열 중에 사전순으로 K번째인 문자열을 출력하는 프로그램을 작성하시오. 그러한 것이 없으면 -1을 출력한다. ‘`(`’가 ‘`)`’보다 사전순으로 앞선다.

#### 입력
첫째 줄에 두 정수 N과 K가 주어진다.

#### 출력
첫째 줄에 문제의 정답을 출력한다.

#### 제한
-   1 ≤ N ≤ 50
-   0 ≤ K ≤ 2<sup>N</sup>  - 1<br>

## 해결
괄호ㄴㄴ문자열 사전 위치는 전체 문자열 사전 위치에서 현재까지 괄호 문자열 개수를 더하면 알 수 있다. 따라서 다음 기능이 필요하다.
- 사전 위치 기준으로 괄호 문자열 개수 구하기 & 찾기
- 괄호 문자열 개수를 이용해 괄호ㄴㄴ문자열 위치 찾기

#### 괄호 문자열 개수 구하기
문자열의 총 개수는 2<sup>N</sup>개라서 완전 탐색을 사용할 수 없다. `DP`를 사용하자.

부분 문제의 현재 상태를 (자릿수 위치, 현재 자리에서 괄호 문자, 괄호 생명) = (n, b, life)으로 하고, 계산 결과는 현재 상태에서 만들 수 있는 괄호 문자열 개수로 한다. 초기 상태는 (0, 0, 1) + (0, 1, -1)이지만, 후자는 항상 0이므로 (0, 0, 1)만 구해도 무방하다.
```
<<<< 0
<<<> 0     <<<(?) 0<br>

<<>< 0
<<>> 1     <<>(?) 1     <<(??) 1<br>
                                       <(???) 2
<><< 0     <><(?) 1     <>(??) 1
<><> 1<br>

<>>< 0     <>>(?) 0
<>>> 0<br>
```
괄호 생명은 앞 자리에서 '('의 개수이다. 순차적으로 탐색했을 때, 괄호 문자열이 되기 위해서는 탐색 완료 시, 괄호 생명이 0이 되어야 한다. 또한, 중간에 괄호 생명이 음수가 되는 경우가 있다면 괄호 문자열이 될 수 없다.

분할 함수는 다음과 같다. (b에서 0 = '(', 1 = ')')
```
DP(n, b, life) = 
	if (life < 0) return 0
	if (n == N - 1) return (life == 0) ? 1 : 0
	return DP(n + 1, 0, life + 1) + DP(n + 1, 1, life - 1)
```

#### 사전 위치로 괄호 문자열 개수 찾기
현재 사전 위치에서 앞쪽에 있는 괄호 문자열 개수를 찾아보자. 문자열은 '(', ')'만 존재하므로 0과 1로 대응할 수 있다. `비트마스크`를 사용하자.

< 전체적인 탐색 구조 >
- 사전 순을 기준으로 탐색한다.
- 기본적으로 길이가 n인 문자열은 길이 n+1인 문자열보다 항상 사전 순으로 앞에 있다는 점을 이용한다. => 길이 n+1 괄호 문자열 개수는 길이 n 괄호 문자열 개수를 포함한다.<br>
- '(', ')' 사전 순서 반영: 현재 문자가 ')'이면, '('일 때의 괄호 문자열 개수를 결과에 더하고, 현재 문자가 '('이면 더하지 않는다.
- 괄호 생명이 음수가 되는 경우를 유의한다. 이 경우는 다음 위치에서 괄호 문자열 개수는 항상 0이므로 재귀 호출을 중단한다.
```
cache[n][k][life] = DP에서 구한 괄호 문자열 개수
n = 현재 자리 위치
k = 사전 위치
life = 괄호 생명

Finder(n, k, life)
	if (n == N) return (life == 0) ? 1 : 0
	
	sum = 0
	if (k의 n번째 자리가 1인가?) // 비트마스크로 표현 가능
		if (life > 0)<br>
			sum = cache[n][0][life + 1] + Finder(n + 1, k, life - 1)
		else
			sum = cache[n][0][1]
	else
		sum = Finder(n + 1, k, life + 1)
	return sum
```
예를 들어 '<>><'의 출력은 2이다.

#### 괄호ㄴㄴ문자열 위치 찾기
마지막으로 괄호 문자열 개수를 이용해 괄호ㄴㄴ문자열 위치를 찾는다.
```
K = 입력 문자열 (괄호ㄴㄴ문자열 위치)
1. K 포함하여 사전 순으로 앞서는 괄호 문자열 개수를 구한다. => cnt = Finder(0, K, 0)<br>
2. 괄호ㄴㄴ문자열의 위치를 전체 문자열 위치로 변환한다.
	- pos = K + cnt
3. K -> pos로 이동했을 때 거쳐간 괄호 문자열 개수를 구한다. => cnt2 = Finder(0, pos, 0) - cnt<br>
4. 위치에 반영한다. => pos += cnt2<br>
5. 새로 거치는 괄호 문자열이 없을 때까지 과정 3-4 반복
	- 단, 현재 위치가 2^N을 넘으면 반복을 중단한다.
```
```
ex. K = 4
0 <<<< X
1 <<<> X<br>
2 <<>< X
3 <<>> O<br>
4 <><< X
5 <><> O<br>
6 <>>< X
```
4번 위치까지 괄호 문자열의 개수는 1개이므로 4+1위치로 이동한다. 5번 위치로 이동했을 때, 괄호 문자열 1개를 거치므로 또다시 현재 위치에 1을 더한다. 최종 결과는 6번 위치 '<>><'이다.

## 코드
```
#include <iostream>
typedef long long ll;
using namespace std;

int N;
ll K;
ll cache[51][2][51];
bool visited[51][2][51];

ll DP(int n, int b, int life)
{
	if (life < 0) return 0;
	if (n == N - 1) return (life == 0) ? 1 : 0;
	if (visited[n][b][life]) return cache[n][b][life];

	cache[n][b][life] = DP(n + 1, 0, life + 1) + DP(n + 1, 1, life - 1);
	visited[n][b][life] = 1;
	return cache[n][b][life];
}

ll Finder(int n, ll k, int life)
{
	if (n == N) return (life == 0) ? 1 : 0;
	ll sum = 0;
	if (k & ((ll)1 << ((N - 1) - n))) {
		if (life > 0) sum = cache[n][0][life + 1] + Finder(n + 1, k, life - 1);<br>
		else sum = cache[n][0][1];
	}
	else sum = Finder(n + 1, k, life + 1);
	return sum;
}

void Printer(int n, ll k)
{
	if (n == N) return;
	if (k & ((ll)1 << ((N - 1) - n))) cout << ")";
	else cout << "(";
	Printer(n + 1, k);
}

int main()
{
	ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
	cin >> N >> K;<br>
	DP(0, 0, 1);

	ll newK = K, preKF = 0;
	while (1)
	{
		ll newKF = Finder(0, newK, 0);
		newK += newKF - preKF;
		if (newKF - preKF <= 0 || newK >= ((ll)1 << N)) break;
		preKF = newKF;
	}

	if (newK < ((ll)1 << N)) Printer(0, newK);
	else cout << "-1";
	return 0;
}
```

## 테스트 케이스
입력 - 2번 점프하는 경우
```
6 12
=> (())))<br>
```

## 링크
https://www.acmicpc.net/problem/1023<br>
{% endraw %}