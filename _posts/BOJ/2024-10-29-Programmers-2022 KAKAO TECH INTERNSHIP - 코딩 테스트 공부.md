---
categories:
- Programmers
date: '2024-10-29'
title: '[Programmers] 2022 KAKAO TECH INTERNSHIP - 코딩 테스트 공부'
---

{% raw %}
> Lv. 3<br>

## 문제
당신은 코딩 테스트를 준비하기 위해 공부하려고 합니다. 코딩 테스트 문제를 풀기 위해서는 알고리즘에 대한 지식과 코드를 구현하는 능력이 필요합니다.

알고리즘에 대한 지식은  `알고력`, 코드를 구현하는 능력은  `코딩력`이라고 표현합니다.  `알고력`과  `코딩력`은 0 이상의 정수로 표현됩니다.

문제를 풀기 위해서는 문제가 요구하는 일정 이상의  `알고력`과  `코딩력`이 필요합니다.

예를 들어, 당신의 현재  `알고력`이 15,  `코딩력`이 10이라고 가정해보겠습니다.

-   A라는 문제가  `알고력`  10,  `코딩력`  10을 요구한다면 A 문제를 풀 수 있습니다.
-   B라는 문제가  `알고력`  10,  `코딩력`  20을 요구한다면  `코딩력`이 부족하기 때문에 B 문제를 풀 수 없습니다.

풀 수 없는 문제를 해결하기 위해서는  `알고력`과  `코딩력`을 높여야 합니다.  `알고력`과  `코딩력`을 높이기 위한 다음과 같은 방법들이 있습니다.

-   `알고력`을 높이기 위해 알고리즘 공부를 합니다.  `알고력`  1을 높이기 위해서 1의 시간이 필요합니다.
-   `코딩력`을 높이기 위해 코딩 공부를 합니다.  `코딩력`  1을 높이기 위해서 1의 시간이 필요합니다.
-   현재 풀 수 있는 문제 중 하나를 풀어  `알고력`과  `코딩력`을 높입니다. 각 문제마다 문제를 풀면 올라가는 알고력과 코딩력이 정해져 있습니다.
-   문제를 하나 푸는 데는 문제가 요구하는 시간이 필요하며 같은 문제를 여러 번 푸는 것이 가능합니다.

당신은 주어진 모든 문제들을 풀 수 있는  `알고력`과  `코딩력`을 얻는 최단시간을 구하려 합니다.

초기의  `알고력`과  `코딩력`을 담은 정수  `alp`와  `cop`, 문제의 정보를 담은 2차원 정수 배열  `problems`가 매개변수로 주어졌을 때, 모든 문제들을 풀 수 있는  `알고력`과  `코딩력`을 얻는 최단시간을 return 하도록 solution 함수를 작성해주세요.

**모든 문제들을 1번 이상씩 풀 필요는 없습니다.**

### 제한사항
-   초기의  `알고력`을 나타내는  `alp`와 초기의  `코딩력`을 나타내는  `cop`가 입력으로 주어집니다.
    -   0 ≤  `alp`,`cop`  ≤ 150
-   1 ≤  `problems`의 길이 ≤ 100
-   `problems`의 원소는 [`alp_req`,  `cop_req`,  `alp_rwd`,  `cop_rwd`,  `cost`]의 형태로 이루어져 있습니다.
-   `alp_req`는 문제를 푸는데 필요한  `알고력`입니다.
    -   0 ≤  `alp_req`  ≤ 150
-   `cop_req`는 문제를 푸는데 필요한  `코딩력`입니다.
    -   0 ≤  `cop_req`  ≤ 150
-   `alp_rwd`는 문제를 풀었을 때 증가하는  `알고력`입니다.
    -   0 ≤  `alp_rwd`  ≤ 30
-   `cop_rwd`는 문제를 풀었을 때 증가하는  `코딩력`입니다.
    -   0 ≤  `cop_rwd`  ≤ 30
-   `cost`는 문제를 푸는데 드는 시간입니다.
    -   1 ≤  `cost`  ≤ 100

## 해결
- 알고력, 코딩력을 높이는 모든 방법을 조사해야 합니다. 부분 문제로 분할 가능하며 중복 부분 문제가 존재하므로 `DP`를 사용합니다.
- 현재 상태는 (알고력 = a, 코딩력 = c)이고, 계산 값은 목표치까지 도달하는 데 소요되는 최소 시간입니다. 초기 상태는 (`alp`, `cop`)이고 값은 0입니다. 점화식은 다음과 같습니다:

> DP(a, c) = min(DP(a + 1, c) + 1, DP(a, c + 1) + 1)<br>
> 현재 풀 수 있는 모든 문제: <br>
	> DP(a, c) = min(DP(a + (획득 알고력), c + (획득 코딩력)) + (소요 시간));<br>

- 탐색이 종료되는 순간은 알고력과 코딩력이 각 모든 문제의 요구 알고력 최댓값, 코딩력 최댓값과 같거나 클 때입니다. 정확히 목표치와 같지 않아도 되며, 목표치보다 알고력 또는 코딩력이 커도 상관이 없습니다. 초기 알고력 또는 코딩력이 목표치보다 큰 경우도 존재합니다.
```
0, 0, [[150, 150, 1, 1, 10], [0, 0, 150, 1, 1]]
```
- 위 예제와 같이 알고력 또는 코딩력은 극단적으로 증가할 수 있으므로, 캐시 메모리 초과 방지를 위해 최대치를 제한해야 합니다. 알고력 또는 코딩력이 목표치를 초과했을 때, 해당 값은 더 이상 고려할 필요가 없으므로 목표치와 동일하게 설정해도 계산에 영향이 없습니다. (예: 알고력이 300이 되면 목표치 150으로 맞추기)


## 코드
```
#include <vector>
using namespace std;
int alp, cop, alpGoal, copGoal, cache[151][151];
vector<vector<int>> problems;<br>

int DP(int a, int c) {
    if (a >= alpGoal && c >= copGoal)
        return 0;
    a = min(a, alpGoal); c = min(c, copGoal);
    if (cache[a][c] > 0)<br>
        return cache[a][c];
    cache[a][c] = 999;
    cache[a][c] = min(cache[a][c], min(DP(a + 1, c) + 1, DP(a, c + 1) + 1));
    for (auto p : problems)
        if (a >= p[0] && c >= p[1])
            cache[a][c] = min(cache[a][c], DP(a + p[2], c + p[3]) + p[4]);
    return cache[a][c];
}

int solution(int a, int c, vector<vector<int>> pro) {<br>
    problems = pro; alp = a, cop = c;
    for (auto p : problems)
        alpGoal = max(alpGoal, p[0]), copGoal = max(copGoal, p[1]);
    alpGoal = max(alpGoal, alp), copGoal = max(copGoal, cop);
    return DP(alp, cop);
}
```

## 링크
https://school.programmers.co.kr/learn/courses/30/lessons/118668<br>
{% endraw %}