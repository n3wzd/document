---
categories:
- BOJ
date: '2022-05-04'
title: '[BOJ] 1949 - 우수 마을'
---

{% raw %}
> 골드 II<br>

## 문제
N개의 마을로 이루어진 나라가 있다. 편의상 마을에는 1부터 N까지 번호가 붙어 있다고 하자. 이 나라는 트리(Tree) 구조로 이루어져 있다. 즉 마을과 마을 사이를 직접 잇는 N-1개의 길이 있으며, 각 길은 방향성이 없어서 A번 마을에서 B번 마을로 갈 수 있다면 B번 마을에서 A번 마을로 갈 수 있다. 또, 모든 마을은 연결되어 있다. 두 마을 사이에 직접 잇는 길이 있을 때, 두 마을이 인접해 있다고 한다.

이 나라의 주민들에게 성취감을 높여 주기 위해, 다음 세 가지 조건을 만족하면서 N개의 마을 중 몇 개의 마을을 '우수 마을'로 선정하려고 한다.

1.  '우수 마을'로 선정된 마을 주민 수의 총 합을 최대로 해야 한다.
2.  마을 사이의 충돌을 방지하기 위해서, 만일 두 마을이 인접해 있으면 두 마을을 모두 '우수 마을'로 선정할 수는 없다. 즉 '우수 마을'끼리는 서로 인접해 있을 수 없다.
3.  선정되지 못한 마을에 경각심을 불러일으키기 위해서, '우수 마을'로 선정되지 못한 마을은 적어도 하나의 '우수 마을'과는 인접해 있어야 한다.

각 마을 주민 수와 마을 사이의 길에 대한 정보가 주어졌을 때, 주어진 조건을 만족하도록 '우수 마을'을 선정하는 프로그램을 작성하시오.

#### 입력
첫째 줄에 정수 N이 주어진다. (1 ≤ N ≤ 10,000) 둘째 줄에는 마을 주민 수를 나타내는 N개의 자연수가 빈칸을 사이에 두고 주어진다. 1번 마을부터 N번 마을까지 순서대로 주어지며, 주민 수는 10,000 이하이다. 셋째 줄부터 N-1개 줄에 걸쳐서 인접한 두 마을의 번호가 빈칸을 사이에 두고 주어진다.

#### 출력
첫째 줄에 '우수 마을'의 주민 수의 총 합을 출력한다.

## 해결
`트리` 마을에서 '우수 마을'로 선정된 주민 수의 합의 최댓값을 구하는 문제. 모든 경우를 탐색하면서 이전 문제의 탐색이 중복되므로 `DP`를 사용하자.

완전탐색 관점으로 어떤 마을이 '우수 마을'인지 아닌지를 모두 확인한다. 부분 문제의 상태는 현재 마을의 '우수 마을' 선정 여부로, 계산 값은 주민의 누적 합 최대이다. 마을들은 트리 구조로 구성되어 있으니 문제의 분할은 서브 트리의 분할로 하자. (부모-자식 노드 탐색) 현재 마을이 '우수 마을'이라면 인접 마을은 '우수 마을'이 될 수 없다는 조건을 주의한다.
> DFS(v, excel) = <br>
> if excel == 1, villager(v) + DFS(c<sub>1</sub>, 0) + DFS(c<sub>2</sub>, 0) + ... + DFS(c<sub>n</sub>, 0)<br>
> if excel == 0, max(DFS(c<sub>1</sub>, 0), DFS(c<sub>1</sub>, 1)) + max(DFS(c<sub>2</sub>, 0), DFS(c<sub>2</sub>, 1)) + ... + max(DFS(c<sub>n</sub>, 0), DFS(c<sub>n</sub>, 1))<br>

루트 마을부터 시작했을 때, 현재 마을이 '우수 마을'이면 아랫마을은 모두 '우수 마을'이 될 수 없다. 만약 현재 마을이 '우수 마을'이 아니면 각 아랫마을은 '우수 마을' 선정과 탈락 2가지 경우가 존재하며, 둘 중 주민 합이 최대인 경우를 선택한다.

문제의 3번 조건, "'우수 마을'로 선정되지 못한 마을은 적어도 하나의 '우수 마을'과는 인접해 있어야 한다."는 1번 조건에 포함되므로 고려하지 않아도 된다. 아래와 같은 예시를 보았을 때,
```
      0
      ?
0   0   0   0
```
? 마을이 '우수 마을'로 선정되지 않으면 조건에 위배된다. 하지만 역으로 주위에 '우수 마을'이 없으므로 ? 마을은 언제든 '우수 마을'로 선정될 수 있다. 1번 조건에 의해 주민 최대 합을 구해야 하므로 ? 마을을 '우수 마을'로 선정하는 것이 항상 이득이다. 

## 코드
```
#include <iostream>
#include <vector>
using namespace std;

int N;
vector<int> tree[10002];
int villager[10002];
int cache[10002][2];

int DFS(int v, int excel, int parent)
{
	if (cache[v][excel] > 0) return cache[v][excel];

	int size = tree[v].size();
	for (int i = 0; i < size; i++)
	{
		int c = tree[v][i];
		if (c != parent)
		{
			if(excel == 1) cache[v][excel] += DFS(c, 0, v);
			else cache[v][excel] += max(DFS(c, 0, v), DFS(c, 1, v));
		}
	}
	if (excel == 1) cache[v][excel] += villager[v];
	return cache[v][excel];
}

int main()
{
	ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
	cin >> N;
	for (int i = 1; i <= N; i++)
		cin >> villager[i];
	for (int i = 0; i < N-1; i++)
	{
		int a, b;
		cin >> a >> b;
		tree[a].push_back(b);
		tree[b].push_back(a);
	}

	cout << max(DFS(1, 0, 0), DFS(1, 1, 0));
	return 0;
}
```

## 링크
<br>https://www.acmicpc.net/problem/1949
{% endraw %}