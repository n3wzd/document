---
categories:
- BOJ
date: '2022-05-08'
title: '[BOJ] 2098 - 외판원 순회'
---

{% raw %}
> 골드 I<br>

## 문제
외판원 순회 문제는 영어로 Traveling Salesman problem (TSP) 라고 불리는 문제로 computer science 분야에서 가장 중요하게 취급되는 문제 중 하나이다. 여러 가지 변종 문제가 있으나, 여기서는 가장 일반적인 형태의 문제를 살펴보자.

1번부터 N번까지 번호가 매겨져 있는 도시들이 있고, 도시들 사이에는 길이 있다. (길이 없을 수도 있다) 이제 한 외판원이 어느 한 도시에서 출발해 N개의 도시를 모두 거쳐 다시 원래의 도시로 돌아오는 순회 여행 경로를 계획하려고 한다. 단, 한 번 갔던 도시로는 다시 갈 수 없다. (맨 마지막에 여행을 출발했던 도시로 돌아오는 것은 예외) 이런 여행 경로는 여러 가지가 있을 수 있는데, 가장 적은 비용을 들이는 여행 계획을 세우고자 한다.

각 도시간에 이동하는데 드는 비용은 행렬 W[i][j]형태로 주어진다. W[i][j]는 도시 i에서 도시 j로 가기 위한 비용을 나타낸다. 비용은 대칭적이지 않다. 즉, W[i][j] 는 W[j][i]와 다를 수 있다. 모든 도시간의 비용은 양의 정수이다. W[i][i]는 항상 0이다. 경우에 따라서 도시 i에서 도시 j로 갈 수 없는 경우도 있으며 이럴 경우 W[i][j]=0이라고 하자.

N과 비용 행렬이 주어졌을 때, 가장 적은 비용을 들이는 외판원의 순회 여행 경로를 구하는 프로그램을 작성하시오.

#### 입력
첫째 줄에 도시의 수 N이 주어진다. (2 ≤ N ≤ 16) 다음 N개의 줄에는 비용 행렬이 주어진다. 각 행렬의 성분은 1,000,000 이하의 양의 정수이며, 갈 수 없는 경우는 0이 주어진다. W[i][j]는 도시 i에서 j로 가기 위한 비용을 나타낸다.

항상 순회할 수 있는 경우만 입력으로 주어진다.

#### 출력
첫째 줄에 외판원의 순회에 필요한 최소 비용을 출력한다.

## 해결
외판원 문제(TSP)는 대표적인 NP-난해 문제로, 현재 다항 시간을 가진 알고리즘이 발견되지 않았다. 현재로서는 모든 경우를 탐색해서 답을 찾아야 한다. 그러나 순회의 경우의 수는 최대 N!이므로 백트래킹을 사용하기는 어렵다. `DP`를 사용해서 계산 횟수를 줄여보자.

부분 문제의 현재 상태를 (현재 도시, 이전에 방문한 도시 목록), 계산 결과는 경로의 최소 비용으로 정의한다.

현재 도시가 같아도, 이전에 방문한 도시에 따라 현재 문제의 탐색이 달라질 수 있으므로, 이전 도시들의 방문도 현재 상태에 포함되어야 한다. (역으로 이전 도시 방문 목록이 같으면, 같은 문제라고 볼 수 있다.) 그러나 이전 도시를 방문하는 순서는 현재 문제 탐색에 영향을 주지 않으므로, 이전 도시 방문 순서는 기록하지 않아도 된다.
```
              0
     1        2
 2      3    ...
 3      2
 0      0
```
현재 도시가 1, 방문했던 도시 경로가 2-3-0, 3-2-0 2가지가 있다고 하자. 부분 문제는 2가지 경로 중에서 최적인 것을 선택한다. 따라서 점화식 함수는 다음과 같다.
```
v = 0 // 시작 정점
visited = [1, 1, ...] // 이전 정점 방문 목록
	- 인덱스: 정점 번호
	- 값: 방문 여부 (초기값은 모두 1)
weight[v][w] // v -> w 간선 가중치 <br>

DP(v, visited)
	1. cost[v][visited] = INF // INF = 문제의 최댓값보다 큰 수
	2. v와 인접한 정점을 모두 조사 => 도착 정점 w<br>
		- visited[w] == 1이라면,
			cost[v][visited] = min(cost[v][visited], weight[v][w] + DP(w, visited[w]에 0을 대입한 값)
	3. 다음을 검사한다. (초항 정의)
		- 현재 모든 정점이 방문되지 않았고, 시작 정점으로 가는 길이 있는가?
			cost[v][visited] = weight[v][0]
	4. cost[v][visited]를 반환한다.
```
현재 도시는 아무거나 선택해도 무방하다. (순회는 시작점이 없기 때문)

boolean 배열을 부분 문제의 인덱스로 사용한다. `비트마스크`를 적용해서 boolean 배열을 정수 하나로 치환해서 사용할 수 있다.

이 문제에선 그래프가 인접 행렬로 주어진다. 정점 개수가 그다지 많지 않으므로 인접 리스트보다 인접 행렬이 구현에서 더 편리한 편이다.

## 코드
```
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

int N;
int cache[16][1 << 16];
int graph[16][16];
const int INF = 20000000;

int DP(int v, int visited)
{
	if (cache[v][visited] > 0) return cache[v][visited];<br>
	cache[v][visited] = INF;
	for (int w = 0; w < N; w++)
		if (!(visited & (1 << w)) && graph[v][w] != 0)
			cache[v][visited] = min(cache[v][visited], graph[v][w] + DP(w, visited | (1 << v)));
	if (graph[v][0] != 0 && (visited | (1 << v)) == (1 << N) - 1)
		cache[v][visited] = graph[v][0];
	return cache[v][visited];
}

int main()
{
	ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
	cin >> N;<br>
	for (int y = 0; y < N; y++)
		for (int x = 0; x < N; x++)
			cin >> graph[y][x];<br>

	cout << DP(0, 0);
	return 0;
}
```

## 테스트 케이스
입력
```
4 
0 1 2 3 
2 0 3 0 
3 0 0 0 
1 2 3 0 
```
출력
```
11
```

## 링크
https://www.acmicpc.net/problem/2098

## 참고
https://www.acmicpc.net/board/view/26647
{% endraw %}