---
categories:
- Programmers
date: '2024-11-21'
title: '[Programmers] 월간 코드 챌린지 시즌2 - 110 옮기기'
---

{% raw %}
> Lv. 3<br>

## 문제
0과 1로 이루어진 어떤 문자열 x에 대해서, 당신은 다음과 같은 행동을 통해 x를 최대한 사전 순으로 앞에 오도록 만들고자 합니다.

-   x에 있는 "110"을 뽑아서, 임의의 위치에 다시 삽입합니다.

예를 들어, x = "11100" 일 때, 여기서 중앙에 있는 "110"을 뽑으면 x = "10" 이 됩니다. 뽑았던 "110"을 x의 맨 앞에 다시 삽입하면 x = "11010" 이 됩니다.

변형시킬 문자열 x가 여러 개 들어있는 문자열 배열  `s`가 주어졌을 때, 각 문자열에 대해서 위의 행동으로 변형해서 만들 수 있는 문자열 중 사전 순으로 가장 앞에 오는 문자열을 배열에 담아 return 하도록 solution 함수를 완성해주세요.

### 제한사항
-   1 ≤  `s`의 길이 ≤ 1,000,000
-   1 ≤  `s`의 각 원소 길이 ≤ 1,000,000
-   1 ≤  `s`의 모든 원소의 길이의 합 ≤ 1,000,000

## 해결
"110"으로 옮겨서 최대한 "0"이 앞에 오게 만들어야 합니다. "110" 이동은 자유이므로 "0" 1개를 앞으로 오게 하는건 쉽지만, "110"에 포함되지 않는 "0"을 앞으로 오게 하는건 어렵습니다. 따라서 가급적 "110"을 뒤로 보내서 가능한 "0"을 앞으로 오게 해야 합니다.

"110"을 얼만큼 뒤로 옮겨야 하는지 찾아봅시다. 사전순은 가장 앞에 있는 것을 우선하므로, "110"을 뒤로 보냈을 때 당겨온 가장 앞의 2개의 숫자 중 하나가 "0"이어야 이득을 볼 수 있습니다. 즉, "110"을 "11"을 만날 때까지 뒤로 옮겨야 합니다.
```
110 | 00 O
110 | 01 O
110 | 10 O
110 | 11 X
ㄴ 11이 앞에 오면 사전순으로 이득 없음
```

입력에서 "110"을 모두 찾고 이러한 과정을 반복하면, 수열 내에서 항상 "110"이 연속적으로 이어진 그룹이 형성되는 것을 발견할 수 있습니다. "110"의 이동은 자유이므로 이 그룹을 통째로 앞으로 이동할 수 있습니다. 정리하면 아래와 같은 과정으로 정답을 찾을 수 있습니다:
```
1. 입력 수열에서 110을 만나면 뒤에 가장 가까이 있는 11의 앞으로 이동시킴
2. 110으로 연속적으로 이어진 그룹 찾기
3. 그룹 왼쪽에 가장 가까이 있는 0과 그룹 앞 사이에 있는 모든 1을 수열 맨 뒤로 보냄
```

이 과정을 더 간단히 정리하면 다음과 같습니다:
```
1. 입력 수열에서 110을 모두 찾아서 추출
2. 찾은 모든 110을 이어붙여서 입력 수열 중 가장 뒤에 있는 0(없으면 맨 앞)에 붙임
```

"110"은 `스택`을 활용해서 추출할 수 있습니다. 수열의 수를 하나씩 스택에 저장하고, 스택 위쪽에 "110"가 형성되는 것을 찾으면 됩니다.

## 코드
```
#include <string>
#include <vector>
using namespace std;

vector<string> solution(vector<string> list) {
    vector<string> answer;
    for (auto s : list) {
        string stk; int cnt = 0;
        for(int i = 0; i < s.size(); i++) {
            stk += s[i];
            int N = stk.size();
            if(N > 2 && stk.substr(N - 3, 3) == "110") {
                stk.erase(N - 3);
                cnt++;
            }
        }
        int N = stk.size(), p;
        string group = "";
        for(p = N - 1; p >= 0; p--)
            if(stk[p] == '0')
                break;
        while(cnt--)
            group += "110";
        stk.insert(p + 1, group);
        answer.push_back(stk);
    }
    return answer;
}
```

## 링크
<br>https://school.programmers.co.kr/learn/courses/30/lessons/77886
{% endraw %}