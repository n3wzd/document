---
categories:
- Programmers
date: '2024-12-10'
title: '[Programmers] 연습문제 - 유사 칸토어 비트열'
---

{% raw %}
> Lv. 2<br>

## 문제
수학에서 칸토어 집합은 0과 1 사이의 실수로 이루어진 집합으로, [0, 1]부터 시작하여 각 구간을 3등분하여 가운데 구간을 반복적으로 제외하는 방식으로 만들어집니다.

남아는 칸토어 집합을 조금 변형하여 유사 칸토어 비트열을 만들었습니다. 유사 칸토어 비트열은 다음과 같이 정의됩니다.

-   0 번째 유사 칸토어 비트열은 "1" 입니다.
-   n(1 ≤ n) 번째 유사 칸토어 비트열은 n - 1 번째 유사 칸토어 비트열에서의 1을 11011로 치환하고 0을 00000로 치환하여 만듭니다.

남아는  `n`  번째 유사 칸토어 비트열에서 특정 구간 내의 1의 개수가 몇 개인지 궁금해졌습니다.  
`n`과 1의 개수가 몇 개인지 알고 싶은 구간을 나타내는  `l`,  `r`이 주어졌을 때 그 구간 내의 1의 개수를 return 하도록 solution 함수를 완성해주세요.

### 제한사항
-   1 ≤  `n`  ≤ 20
-   1 ≤  `l`,  `r`  ≤ 5`n`
    -   l ≤  `r`  <  `l`  + 10,000,000
    -   `l`과  `r`은 비트열에서의 인덱스(1-base)이며 폐구간 [l, r]을 나타냅니다.

## 해결
비트열은 재귀적으로 반복되며, 이를 점화식으로 정리하면 다음과 같습니다:
> A[n] = A[n-1] + A[n-1] + Z[5<sup>(n-1)</sup>] + A[n-1] + A[n-1]<br>
> A[0] = 1<br>
> Z[x] = x개의 0으로 구성된 비트열<br>

현재 깊이 `n`에서 1의 개수는 다음과 같습니다:
> O[0] = 1<br>
> O[1] = 4<br>
> O[2] = 16<br>
> O[n] = 4<sup>n</sup><br>

비트열 구간이 주어졌을 때, 이 구간의 1의 개수를 찾아봅시다. 전체 범위를 나눠서 탐색해서 `O(logN)` 시간으로 답을 구할 수 있습니다. => `분할 정복`<br>
- 처음에는 전체 길이를 범위로 합니다. 그리고 이 범위를 5등분하고, 분할된 범위 중 가운데를 제외하고 재귀적으로 탐색합니다.
- 현재 범위가 주어진 구간에 완전히 벗어난다면 탐색하지 않습니다.
- 현재 범위가 주어진 구간에 완전히 포함된다면 현재 범위에서 1의 개수를 반환합니다.
- 현재 범위가 주어진 구간에 걸쳐진다면 분할 재귀 탐색을 수행합니다.

※ 이러한 방법은 자료구조 `세그먼트 트리`의 메커니즘과 유사합니다.

## 코드
```
using namespace std;
typedef long long ll;
int answer = 0;
ll M4[21] = { 1, }, M5[21] = { 1, };

void R(ll lo, ll n, ll l, ll r) {
    ll hi = lo + M5[n] - 1, t = M5[n] / 5;
    if(lo > r || hi < l)<br>
		return;
    if(lo >= l && hi <= r) {
        answer += M4[n];
        return;
    }
    for(int i = 0; i < 5; i++)
        if(i != 2)
            R(lo + t * i, n - 1, l, r);
}

int solution(int n, ll l, ll r) {
    for(int i = 1; i <= n; i++)
        M4[i] = M4[i - 1] * 4, M5[i] = M5[i - 1] * 5;
    R(0, n, l - 1, r - 1);
    return answer;
}
```

## 링크
https://school.programmers.co.kr/learn/courses/30/lessons/148652
{% endraw %}