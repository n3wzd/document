---
categories:
- BOJ
date: '2022-08-03'
title: '[BOJ] 11001 - 김치'
---

{% raw %}
> 플래티넘 I<br>

## 문제
최재현은 지지부진한 알앤이 진도에 분노해서, 구재현의 싸대기에 잘 익은 김치를 던지려고 한다.

물론 김치를 만드는 것이 쉬운 일은 아니기 때문에, 갈수록 추워지는 가을날 최재현은 남도에 있는 한 김치 명장을 찾아갔다.

김치 명장이 말한 "좋은 김치"의 조건은 :

-   숙성 시간이 길수록 김치의 맛은 좋아진다.
-   추운 날에는 김치가 얼기 때문에, 현재 온도가 높을수록 김치의 맛은 좋아진다.
-   김치를 넣은 날 장독대의 가치는 김치의 맛에 영향을 준다.

최재현은 이 말이 잘 와닿지 않는지, 계속 질문을 던졌다. 다행인지 불행인지, 김치 명장은 컴퓨터 공학과를 전공한 실력 있는 프로그래머이다. 때문에 김치의 맛을 조금 더 엄밀하게 정의했다.

-   김치의 맛은, (숙성 시간) * (김치를 꺼낼 때의 온도) + (김치를 넣은 날 가치) 로 정의된다. 숙성 시간은, (김치를 꺼낸 날짜 - 김치를 넣은 날짜) 이며, 숙성 시간이 0일 수도 있다.
-   겨울이 오기 때문에, 김치를 꺼낼 때의 온도는 감소한다. (Ti >= Ti+1)

하지만 최재현은 그렇게 시간이 많지 않고, 솔직히 말해서 알앤이 파트너에게 묵은지로 싸대기를 때리는 건 좀 나쁜 거 같다고 생각해서, 숙성 시간이 D 이하인 범위 안에서 재현이에게 싸대기를 때리려고 한다.

재현이에게는 매일의 온도와 장독대의 가치가 주어진다. 재현이가 던질 수 있는 가장 맛있는 김치싸대기의 값은 얼마가 될수 있을까?

### 입력
첫 번째 줄에 날짜의 수와 시간 제한 N, D가 주어진다. (1 ≤ D ≤ N ≤ 100,000)

두 번째 줄에 온도 Ti가 주어진다. N-1 이하의 정수 i에 대해서 Ti  >= Ti+1을 만족하며, 109  이하의 자연수이다.

세 번째 줄에 가치 Vi가 주어진다. 109  이하의 자연수이다.

### 출력
가장 맛있는 김치싸대기의 값을 출력하라.

## 해결
우선, 맛있는 김치싸대기의 수식을 정리하면 다음과 같다. (j > i)<br>
> F[i, j] = max((j - i) × T[j] + V[i])<br>

모든 i, j 조합을 조사하면 가장 맛있는 김치싸대기를 알 수 있다. 하지만 O(N<sup>2</sup>) 시간이 걸리니 다른 방법을 찾아보자.

이 문제는 `분할정복 최적화`을 적용해서 O(N log N)으로 단축할 수 있다. 김치를 넣은 날을 i로 했을 때 김치를 꺼낸 최적의 날짜가 J[i]라면, 문제 조건에 의해 아래 조건이 성립한다.
> i<sub>1</sub> < i<sub>2</sub> → J[i<sub>1</sub>] ≤ J[i<sub>2</sub>]<br>

따라서 분할정복 최적화를 적용할 수 있다. i가 고정일 때, j는 다음 조건으로 구할 수 있다.
> 1. F[i, j]가 최대일 때<br>
> 2. j - i의 차가 D 이하<br>

## 코드
```
#include <iostream>
typedef long long ll;
using namespace std;
const int SIZE = 1e5 + 2;
ll N, D, T[SIZE], V[SIZE], res = 0;
ll F(ll i, ll j) { return (j - i) * T[j] + V[i]; }

void DC(ll lo, ll hi, ll lo2, ll hi2) {
	if (lo > hi)<br>
		return;
	ll i = (lo + hi) / 2;
	ll v = 0, v_idx = 0;

	for (int j = lo2; j <= hi2; j++) {
		if (F(i, j) > v && abs(j - i) <= D) {<br>
			v = F(i, j);
			v_idx = j;
		}
	}
	res = max(res, v);

	DC(lo, i - 1, lo2, v_idx);
	DC(i + 1, hi, v_idx, hi2);
}

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
	cin >> N >> D;<br>
	for (int i = 0; i < N; i++)
		cin >> T[i];<br>
	for (int i = 0; i < N; i++)
		cin >> V[i];<br>
	DC(0, N - 1, 0, N - 1);
	cout << res;
	return 0;
}
```

## 링크
https://www.acmicpc.net/problem/11001
{% endraw %}