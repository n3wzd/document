---
categories:
- Programmers
date: '2024-10-31'
title: '[Programmers] 2022 KAKAO BLIND RECRUITMENT - 파괴되지 않은 건물'
---

{% raw %}
> Lv. 3<br>

## 문제
N x M 크기의 행렬 모양의 게임 맵이 있습니다. 이 맵에는 내구도를 가진 건물이 각 칸마다 하나씩 있습니다. 적은 이 건물들을 공격하여 파괴하려고 합니다. 건물은 적의 공격을 받으면 내구도가 감소하고 내구도가 0이하가 되면 파괴됩니다. 반대로, 아군은 회복 스킬을 사용하여 건물들의 내구도를 높이려고 합니다.

적의 공격과 아군의 회복 스킬은 항상 직사각형 모양입니다.  

건물의 내구도를 나타내는 2차원 정수 배열  `board`와 적의 공격 혹은 아군의 회복 스킬을 나타내는 2차원 정수 배열  `skill`이 매개변수로 주어집니다. 적의 공격 혹은 아군의 회복 스킬이 모두 끝난 뒤 파괴되지 않은 건물의 개수를 return하는 solution함수를 완성해 주세요.

### 제한사항
-   1 ≤  `board`의 행의 길이 (=  `N`) ≤ 1,000
-   1 ≤  `board`의 열의 길이 (=  `M`) ≤ 1,000
-   1 ≤  `board`의 원소 (각 건물의 내구도) ≤ 1,000
-   1 ≤  `skill`의 행의 길이 ≤ 250,000
-   `skill`의 열의 길이 = 6
-   `skill`의 각 행은  `[type, r1, c1, r2, c2, degree]`형태를 가지고 있습니다.
    -   type은 1 혹은 2입니다.
        -   type이 1일 경우는 적의 공격을 의미합니다. 건물의 내구도를 낮춥니다.
        -   type이 2일 경우는 아군의 회복 스킬을 의미합니다. 건물의 내구도를 높입니다.
    -   (r1, c1)부터 (r2, c2)까지 직사각형 모양의 범위 안에 있는 건물의 내구도를 degree 만큼 낮추거나 높인다는 뜻입니다.
        -   0 ≤ r1 ≤ r2 <  `board`의 행의 길이
        -   0 ≤ c1 ≤ c2 <  `board`의 열의 길이
        -   1 ≤ degree ≤ 500
        -   type이 1이면 degree만큼 건물의 내구도를 낮춥니다.
        -   type이 2이면 degree만큼 건물의 내구도를 높입니다.
-   건물은 파괴되었다가 회복 스킬을 받아 내구도가 1이상이 되면 파괴되지 않은 상태가 됩니다. 즉, 최종적으로 건물의 내구도가 1이상이면 파괴되지 않은 건물입니다.

## 해결
- 직사각형 구간 업데이트 쿼리를 수행해야 합니다. O(N<sup>2</sup>) 시간 내에 통과해야 하므로 쿼리마다 일일이 건물을 업데이트하는 나이브한 방법이나 세그먼트 트리는 적용이 어렵습니다.
- 쿼리 순서는 상관없고 쿼리는 교환법칙이 성립하므로 쿼리 순서를 바꿀 수 있습니다. 쿼리를 탐색 전에 전처리가 가능합니다. => `오프라인 쿼리`<br>
- 건물 순회 1번만 수행해야 하며, 이는 2중 `스위핑`으로 구현할 수 있습니다.

먼저 직선 구간부터 생각해봅시다. 구간 (x1, x2)에 3을 더하는 쿼리가 주어졌다면, 다음과 같이 기록합니다.
```
      x1       x2+1
|----(+3)------(-3)---|
```
건물 변화량 `delta`를 정의합시다. (초기 값은 0입니다.) 오른쪽 방향으로 스위핑 탐색하면서 `delta`는 합연산으로 업데이트되며, 건물 초기 값과 `delta`를 더해서 쿼리를 반영할 수 있습니다.

이제 2차원으로 확장합시다. 가로 구간 (x1, x2)에 3을 더하는 쿼리가 (y1, y2) 세로 구간으로 주어졌다면, 다음과 같이 기록합니다.
```
           x1       x2+1
y1   |----(+3)------(-3)---|
     |---------------------|
y2+1 |----(-3)------(+3)---|
```
직선쿼리 변화량, 1차원 배열 `deltaY`를 정의합시다. 아래 방향으로 스위핑 탐색하면서 `deltaY`는 합연산으로 업데이트되며, 각 행마다 오른쪽 방향으로 스위핑 탐색하면 모든 쿼리를 반영할 수 있습니다.

## 코드
```
#include <vector>
using namespace std;
int N, M, cnt, dtx, dty[1002], dtRect[1002][1002];

int solution(vector<vector<int>> board, vector<vector<int>> skills) {<br>
    N = board.size(), M = board[0].size();
    for (auto s : skills) {
        dtRect[s[1]][s[2]] += s[5] * (s[0] == 1 ? -1 : 1);
        dtRect[s[1]][s[4] + 1] += s[5] * (s[0] == 1 ? 1 : -1);
        dtRect[s[3] + 1][s[2]] += s[5] * (s[0] == 1 ? 1 : -1);
        dtRect[s[3] + 1][s[4] + 1] += s[5] * (s[0] == 1 ? -1 : 1);
    }

    for (int y = 0; y < N; y++) {
        dtx = 0;
        for (int x = 0; x < M; x++)
            dty[x] += dtRect[y][x];
        for (int x = 0; x < M; x++) {
            dtx += dty[x];
            cnt += board[y][x] + dtx > 0 ? 1 : 0;<br>
        }
    }
    return cnt;
}
```

## 링크
https://school.programmers.co.kr/learn/courses/30/lessons/92344
{% endraw %}