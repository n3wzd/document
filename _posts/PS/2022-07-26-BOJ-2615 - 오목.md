---
categories:
- BOJ
date: '2022-07-26'
title: '[BOJ] 2615 - 오목'
---

{% raw %}
> 실버 II<br>

## 문제
오목은 바둑판에 검은 바둑알과 흰 바둑알을 교대로 놓아서 겨루는 게임이다. 바둑판에는 19개의 가로줄과 19개의 세로줄이 그려져 있는데 가로줄은 위에서부터 아래로 1번, 2번, ... ,19번의 번호가 붙고 세로줄은 왼쪽에서부터 오른쪽으로 1번, 2번, ... 19번의 번호가 붙는다.

위의 그림에서와 같이 같은 색의 바둑알이 연속적으로 다섯 알을 놓이면 그 색이 이기게 된다. 여기서 연속적이란 가로, 세로 또는 대각선 방향 모두를 뜻한다. 즉, 위의 그림은 검은색이 이긴 경우이다. 하지만 여섯 알 이상이 연속적으로 놓인 경우에는 이긴 것이 아니다.

입력으로 바둑판의 어떤 상태가 주어졌을 때, 검은색이 이겼는지, 흰색이 이겼는지 또는 아직 승부가 결정되지 않았는지를 판단하는 프로그램을 작성하시오. 단, 검은색과 흰색이 동시에 이기거나 검은색 또는 흰색이 두 군데 이상에서 동시에 이기는 경우는 입력으로 들어오지 않는다.

### 입력
19줄에 각 줄마다 19개의 숫자로 표현되는데, 검은 바둑알은 1, 흰 바둑알은 2, 알이 놓이지 않는 자리는 0으로 표시되며, 숫자는 한 칸씩 띄어서 표시된다.

### 출력
첫줄에 검은색이 이겼을 경우에는 1을, 흰색이 이겼을 경우에는 2를, 아직 승부가 결정되지 않았을 경우에는 0을 출력한다. 검은색 또는 흰색이 이겼을 경우에는 둘째 줄에 연속된 다섯 개의 바둑알 중에서 가장 왼쪽에 있는 바둑알(연속된 다섯 개의 바둑알이 세로로 놓인 경우, 그 중 가장 위에 있는 것)의 가로줄 번호와, 세로줄 번호를 순서대로 출력한다.

## 해결
오목이 완성되는 경우를 찾는 `브루트포스` 문제. 탐색 순서를 적절히 설정하는 것이 중요하다.

먼저 보드판 19x19에서 1칸씩 탐색한다. 이때 탐색 순서는 다음과 같다.
1. x가 작은 순서대로 탐색
2. x가 같다면 y가 작은 순서대로 탐색

그 다음, 현재 칸 (x, y)에서 승리 조건을 탐색하는 Scan 함수에선 현재 위치로부터 4방향 (↗, →, ↘, ↓)으로 같은 색의 돌이 연속 5개인지 확인한다. (반대 방향은 이미 이전 칸에서 탐색되었으므로 검사하지 않아도 된다) 이때 6개 이상인 경우는 승리 조건이 아니라는 점을 주의해야 한다.

< 현재 위치 (x, y)에서 d 방향을 조사할 때 승리 조건 >

1. 현재 위치에서 d 방향으로 연속으로 같은 색 돌이 5개 존재해야 함
2. 5번째 돌에서 다음 칸에는 같은 색 돌이 없어야 함
3. 현재 위치에서 -d 방향으로 인접한 같은색 돌이 있으면 탐색하지 않음 (-d는 d의 역방향)
	- 이미 (x - d, y - d) 위치에서 이 조건을 탐색했기 때문

만약 승리 조건을 만족한다면 현재 위치를 출력하고 즉시 종료한다. (문제 조건에 따라 승리 조건을 만족하는 경우는 항상 1번만 존재한다) 만약 모든 칸 탐색이 끝났음에도 승리 조건을 만족하지 못하면 0을 출력한다.

## 코드
```
#include <iostream>
using namespace std;
const int SIZE = 19;
int board[21][21];
int dy[] = { -1, 0, 1, 1 };
int dx[] = { 1, 1, 1, 0 };

bool Scan(int x, int y, int c) {
	if (c == 0)
		return 0;
	for (int d = 0; d < 4; d++) {
		if (board[y + dy[d] * -1][x + dx[d] * -1] == c)
			continue;

		int sum = 0; bool isOver = 0;
		for (int i = 1; i <= 5; i++) {
			int nx = x + dx[d] * i, ny = y + dy[d] * i;
			if (c == board[ny][nx]) {
				if (i < 5)
					sum++;
				else
					isOver = 1;
			}
		}
		if (sum == 4 && !isOver) {
			cout << c << "\n" << y << " " << x;
			return 1;
		}
	}
	return 0;
}

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
	for (int y = 1; y <= 19; y++)
		for (int x = 1; x <= 19; x++)
			cin >> board[y][x];<br>

	for (int x = 1; x <= 19; x++)
		for (int y = 1; y <= 19; y++)
			if (Scan(x, y, board[y][x]))
				return 0;
		
	cout << 0;
	return 0;
}
```

## 링크
https://www.acmicpc.net/problem/2615
{% endraw %}