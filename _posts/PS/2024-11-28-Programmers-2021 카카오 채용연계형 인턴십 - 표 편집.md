---
categories:
- Programmers
date: '2024-11-28'
title: '[Programmers] 2021 카카오 채용연계형 인턴십 - 표 편집'
---

{% raw %}
> Lv. 3<br>

## 문제
업무용 소프트웨어를 개발하는 니니즈웍스의 인턴인 앙몬드는 명령어 기반으로 표의 행을 선택, 삭제, 복구하는 프로그램을 작성하는 과제를 맡았습니다. 세부 요구 사항은 다음과 같습니다

한 번에 한 행만 선택할 수 있으며, 표의 범위(0행 ~ 마지막 행)를 벗어날 수 없습니다. 이때, 다음과 같은 명령어를 이용하여 표를 편집합니다.

-   `"U X"`: 현재 선택된 행에서 X칸 위에 있는 행을 선택합니다.
-   `"D X"`: 현재 선택된 행에서 X칸 아래에 있는 행을 선택합니다.
-   `"C"`  : 현재 선택된 행을 삭제한 후, 바로 아래 행을 선택합니다. 단, 삭제된 행이 가장 마지막 행인 경우 바로 윗 행을 선택합니다.
-   `"Z"`  : 가장 최근에 삭제된 행을 원래대로 복구합니다.  **단, 현재 선택된 행은 바뀌지 않습니다.**

처음 표의 행 개수를 나타내는 정수 n, 처음에 선택된 행의 위치를 나타내는 정수 k, 수행한 명령어들이 담긴 문자열 배열 cmd가 매개변수로 주어질 때, 모든 명령어를 수행한 후 표의 상태와 처음 주어진 표의 상태를 비교하여 삭제되지 않은 행은 O, 삭제된 행은 X로 표시하여 문자열 형태로 return 하도록 solution 함수를 완성해주세요.

### 제한사항
-   5 ≤  `n`  ≤ 1,000,000
-   0 ≤  `k`  <  `n`
-   1 ≤  `cmd`의 원소 개수 ≤ 200,000
    -   `cmd`의 각 원소는  `"U X"`,  `"D X"`,  `"C"`,  `"Z"`  중 하나입니다.
    -   X는 1 이상 300,000 이하인 자연수이며 0으로 시작하지 않습니다.
    -   X가 나타내는 자연수에 ',' 는 주어지지 않습니다. 예를 들어 123,456의 경우 123456으로 주어집니다.
    -   `cmd`에 등장하는 모든 X들의 값을 합친 결과가 1,000,000 이하인 경우만 입력으로 주어집니다.
    -   표의 모든 행을 제거하여, 행이 하나도 남지 않는 경우는 입력으로 주어지지 않습니다.
    -   본문에서 각 행이 제거되고 복구되는 과정을 보다 자연스럽게 보이기 위해  `"이름"`  열을 사용하였으나,  `"이름"`열의 내용이 실제 문제를 푸는 과정에 필요하지는 않습니다.  `"이름"`열에는 서로 다른 이름들이 중복없이 채워져 있다고 가정하고 문제를 해결해 주세요.
-   표의 범위를 벗어나는 이동은 입력으로 주어지지 않습니다.
-   원래대로 복구할 행이 없을 때(즉, 삭제된 행이 없을 때) "Z"가 명령어로 주어지는 경우는 없습니다.
-   정답은 표의 0행부터 n - 1행까지에 해당되는 O, X를 순서대로 이어붙인 문자열 형태로 return 해주세요.

## 해결
중간 삭제가 발생하며, 인덱스 이동이 있는 자료 구조를 구현해야 합니다. 이상적인 자료 구조는 알 수 없지만, 중요한 제약 사항이 있습니다.
- 인덱스 이동량 총합이 제한되어 있습니다. 이동 최대치가 제한되어 있으므로 1칸씩 이동하는 방법이 가능합니다. => `연결 리스트`<br>
- 삭제, 복구는 선입후출로 이뤄집니다. 이전 위치를 기억해서 순차대로 복구할 수 있습니다. => `스택`<br>

필요한 자료 구조는 다음과 같습니다:
- 현재 행 위치: `p` 
- 각 행의 왼쪽, 오른쪽 위치: `left[x]`, `right[x]`
- 삭제된 행 번호 저장: `stack`

각 쿼리를 처리해봅시다.
- `U X`: `left[p]`를 통해 `p`를 `X`만큼 왼쪽으로 이동합니다.
- `D X`: `right[p]`를 통해 `p`를 `X`만큼 오른쪽으로 이동합니다.
- `C`: `p`에 위치한 행을 `stack`에 추가합니다. `right[left[p]]`, `left[right[p]]`을 업데이트합니다. `p`의 오른쪽이 존재하면 오른쪽, 그렇지 않으면 왼쪽으로 1칸 이동합니다.
- `Z`: `stack`에서 행 `x`를 꺼냅니다. 양 옆의 `right[left[x]]`, `left[right[x]]`을 `x`로 업데이트합니다.

마지막에는 `stack`에 저장된 원소들을 반환합니다.

## 코드
```
#include <string>
#include <vector>
#include <stack>
#define SIZE 1000001
using namespace std;
bool del[SIZE];
int left[SIZE], right[SIZE];
stack<int> stk;<br>

string solution(int n, int k, vector<string> cmds) {<br>
    int p = k;
    left[0] = right[n - 1] = -1;
    right[0] = 1, left[n - 1] = n - 2;
    for(int i = 1; i < n - 1; i++)
        left[i] = i - 1, right[i] = i + 1;
    for(auto cmd : cmds) {
        if(cmd[0] == 'U' || cmd[0] == 'D') {
            int d = stoi(cmd.substr(2, cmd.size() - 2));
            while(d--)
                p = cmd[0] == 'U' ? left[p] : right[p];
        }
        if(cmd[0] == 'C') {
            del[p] = 1; stk.push(p);
            if(left[p] != -1)
                right[left[p]] = right[p];
            if(right[p] != -1)
                left[right[p]] = left[p];
            p = right[p] != -1 ? right[p] : left[p];
        }
        if(cmd[0] == 'Z') {
            int d = stk.top(); stk.pop();
            del[d] = 0;
            if(left[d] != -1)
                right[left[d]] = d;
            if(right[d] != -1)
                left[right[d]] = d;
        }
    }
    string answer = "";
    for(int i = 0; i < n; i++)
        answer += del[i] ? "X" : "O";
    return answer;
}
```

## 링크
https://school.programmers.co.kr/learn/courses/30/lessons/81303
{% endraw %}