---
categories:
- Programmers
date: '2024-11-04'
title: '[Programmers] 2020 KAKAO BLIND RECRUITMENT - 외벽 점검'
---

{% raw %}
> Lv. 3<br>

## 문제
레스토랑을 운영하고 있는  **"스카피"**는 레스토랑 내부가 너무 낡아 친구들과 함께 직접 리모델링 하기로 했습니다. 레스토랑이 있는 곳은 스노우타운으로 매우 추운 지역이어서 내부 공사를 하는 도중에 주기적으로 외벽의 상태를 점검해야 할 필요가 있습니다.

레스토랑의 구조는  **완전히 동그란 모양**이고  **외벽의 총 둘레는 n미터**이며, 외벽의 몇몇 지점은 추위가 심할 경우 손상될 수도 있는  **취약한 지점들**이 있습니다. 따라서 내부 공사 도중에도 외벽의 취약 지점들이 손상되지 않았는 지, 주기적으로 친구들을 보내서 점검을 하기로 했습니다. 다만, 빠른 공사 진행을 위해 점검 시간을 1시간으로 제한했습니다. 친구들이 1시간 동안 이동할 수 있는 거리는 제각각이기 때문에, 최소한의 친구들을 투입해 취약 지점을 점검하고 나머지 친구들은 내부 공사를 돕도록 하려고 합니다. 편의 상 레스토랑의 정북 방향 지점을 0으로 나타내며, 취약 지점의 위치는 정북 방향 지점으로부터 시계 방향으로 떨어진 거리로 나타냅니다. 또, 친구들은 출발 지점부터 시계, 혹은 반시계 방향으로 외벽을 따라서만 이동합니다.

외벽의 길이 n, 취약 지점의 위치가 담긴 배열 weak, 각 친구가 1시간 동안 이동할 수 있는 거리가 담긴 배열 dist가 매개변수로 주어질 때, 취약 지점을 점검하기 위해 보내야 하는 친구 수의 최소값을 return 하도록 solution 함수를 완성해주세요.

### 제한사항
-   n은 1 이상 200 이하인 자연수입니다.
-   weak의 길이는 1 이상 15 이하입니다.
    -   서로 다른 두 취약점의 위치가 같은 경우는 주어지지 않습니다.
    -   취약 지점의 위치는 오름차순으로 정렬되어 주어집니다.
    -   weak의 원소는 0 이상 n - 1 이하인 정수입니다.
-   dist의 길이는 1 이상 8 이하입니다.
    -   dist의 원소는 1 이상 100 이하인 자연수입니다.
-   친구들을 모두 투입해도 취약 지점을 전부 점검할 수 없는 경우에는 -1을 return 해주세요.

## 해결
최소 인원을 배치해서 모든 취약점을 커버해야 합니다. 모든 경우를 탐색할 필요가 있으며, 탐색에는 중복이 존재합니다. => `원형 DP`<br>

현재 상태를 (취약점, 남은 친구 목록)으로 정의하며, 계산 값은 전체 취약점 커버가 가능할 때의 최소 인원입니다. (모든 인원을 투입해도 커버하지 못하면 무한대를 반환합니다.) 현재 취약점을 시작점으로 해서 인원을 투입했다면 해당 인원은 이동 거리만큼 연속한 취약점들을 커버합니다. (이동 방향은 시계 방향으로 고정합니다.) 다음 취약점 위치는 커버하지 못한 가장 가까운 취약점입니다. 커버할 취약점이 없다면 탐색을 종료합니다. 남은 친구 목록은 boolean 배열이므로 `비트마스킹`으로 구현합니다.

> DP(취약점, 친구 목록) = min(DP(친구 1 커버하고 남은 다음 취약점, 친구 1 제외한 남은 친구 목록) + 1,<br>
>                                                DP(친구 2 커버하고 남은 다음 취약점, 친구 2 제외한 남은 친구 목록) + 1, ...)<br>

이 탐색은 초기 시작점을 반드시 시작으로 해서 커버해야 한다는 것을 전제로 합니다. 따라서 초기 시작점이 중간에 포함되거나 끝점이 되는 경우는 고려되지 않습니다. (예: 1번째 취약점을 초기 시작점으로 하면, 마지막 취약점에서 1번째 취약점을 동시 커버하는 경우를 찾지 못합니다.)

현재 상태를 확장하여 (취약점, 남은 친구 목록, 마지막 취약점)으로 정의합니다. 최종 답은 모든 취약점을 초기 시작점으로 고려했을 때 최소 인원입니다. N번 취약점에서 1번 취약점으로 넘어가는 것을 간편하게 처리하기 위해 취약점 배열을 2배로 확장해줍니다. (예: n = 10이고 취약점 배열이 [1, 3, 5]이면, [1, 3, 5, 11, 13, 15])

## 코드
```
#include <vector>
using namespace std;
const int MAXN = 99999;
int N, cache[32][1 << 8][32];
vector<int> weak, dist;<br>

int DP(int n, int team, int L) {
    if (n >= L)
        return 0;
    if (cache[n][team][L] > 0)<br>
        return cache[n][team][L];
    cache[n][team][L] = MAXN;
    for (int i = 0; i < dist.size(); i++) {
        if (!(team & (1 << i))) {
            int next = n;
            while (next < L && weak[next] <= weak[n] + dist[i]) next++;
            cache[n][team][L] = min(cache[n][team][L], DP(next, team | (1 << i), L) + 1);
        }
    }
    return cache[n][team][L];
}

int solution(int n, vector<int> weakI, vector<int> distI) {<br>
    N = weakI.size(); weak = weakI, dist = distI;
    for (int i = 0; i < N; i++)
        weak.push_back(n + weak[i]);
    int res = DP(0, 0, N);
    for (int i = 1; i < N; i++)
        res = min(res, DP(i, 0, N + i));
    return res == MAXN ? -1 : res;
}
```

## 링크
https://school.programmers.co.kr/learn/courses/30/lessons/60062
{% endraw %}