---
categories:
- Programmers
date: '2024-11-27'
title: '[Programmers] 2023 현대모비스 알고리즘 경진대회 예선 - 상담원 인원'
---

{% raw %}
> Lv. 3<br>

## 문제
현대모비스는 우수한 SW 인재 채용을 위해 상시로 채용 설명회를 진행하고 있습니다. 채용 설명회에서는 채용과 관련된 상담을 원하는 참가자에게 멘토와 1:1로 상담할 수 있는 기회를 제공합니다. 채용 설명회에는 멘토  `n`명이 있으며, 1~`k`번으로 분류되는 상담 유형이 있습니다. 각 멘토는  `k`개의 상담 유형 중 하나만 담당할 수 있습니다. 멘토는 자신이 담당하는 유형의 상담만 가능하며, 다른 유형의 상담은 불가능합니다. 멘토는 동시에 참가자 한 명과만 상담 가능하며, 상담 시간은 정확히 참가자가 요청한 시간만큼 걸립니다.

참가자가 상담 요청을 하면 아래와 같은 규칙대로 상담을 진행합니다.

-   상담을 원하는 참가자가 상담 요청을 했을 때, 참가자의 상담 유형을 담당하는 멘토 중 상담 중이 아닌 멘토와 상담을 시작합니다.
-   만약 참가자의 상담 유형을 담당하는 멘토가 모두 상담 중이라면, 자신의 차례가 올 때까지 기다립니다.  **참가자가 기다린 시간은 참가자가 상담 요청했을 때부터 멘토와 상담을 시작할 때까지의 시간입니다.**
-   모든 멘토는 상담이 끝났을 때 자신의 상담 유형의 상담을 받기 위해 기다리고 있는 참가자가 있으면 즉시 상담을 시작합니다. 이때,  **먼저 상담 요청한 참가자가 우선됩니다.**

참가자의 상담 요청 정보가 주어질 때, 참가자가 상담을 요청했을 때부터 상담을 시작하기까지 기다린 시간의 합이 최소가 되도록 각 상담 유형별로 멘토 인원을 정하려 합니다.  **단, 각 유형별로 멘토 인원이 적어도 한 명 이상이어야 합니다.**

상담 유형의 수를 나타내는 정수  `k`, 멘토의 수를 나타내는 정수  `n`과 참가자의 상담 요청을 담은 2차원 정수 배열  `reqs`가 매개변수로 주어집니다. 멘토 인원을 적절히 배정했을 때 참가자들이 상담을 받기까지 기다린 시간을 모두 합한 값의 최솟값을 return 하도록 solution 함수를 완성해 주세요.

### 제한사항
-   1 ≤  `k`  ≤ 5
-   `k`  ≤  `n`  ≤ 20
-   3 ≤  `reqs`의 길이 ≤ 300
    -   `reqs`의 원소는 [`a`,  `b`,  `c`] 형태의 길이가 3인 정수 배열이며,  `c`번 유형의 상담을 원하는 참가자가  `a`분에  `b`분 동안의 상담을 요청했음을 의미합니다.
    -   1 ≤  `a`  ≤ 1,000
    -   1 ≤  `b`  ≤ 100
    -   1 ≤  `c`  ≤  `k`
    -   `reqs`는  `a`를 기준으로 오름차순으로 정렬되어 있습니다.
    -   `reqs`  배열에서  `a`는 중복되지 않습니다. 즉, 참가자가 상담 요청한 시각은 모두 다릅니다.

## 해결
변수가 많고 입력이 작으므로 모든 경우를 확인하는 방법이 가능합니다. 상담원을 배정하는 모든 경우를 찾고, 각 조합마다 총 대기 시간을 구하면 됩니다. 정답은 총 대기 시간의 최소입니다.

먼저 상담원을 배정합시다. 이 문제는 같은 원소를 `k`개의 집합으로 분할하는 경우와 같습니다. (이 집합은 공집합이 아닙니다.) 이는 `조합`으로 구할 수 있습니다. 모든 원소를 일렬로 나열하고, 그 사이에 같은 칸막이를 배치하는 것과 같습니다. 이때 경우의 수는 <sub>n-1</sub>C<sub>k</sub>입니다. (예외: `n` = `k`인 경우가 있습니다. 이때는 분할을 하지 않으면 됩니다.)
```
n = 6, k = 3
1 . 1 . 1 . 1 . 1 . 1
=> 5C3<br>
```

상담원의 조합이 정해졌다면, 총 대기 시간을 구합니다. 어떤 참가자가 있다면 대기 중인 상담원을 우선으로, 그렇지 않으면 가장 빨리 상담이 끝나는 상담원을 배정하는 것이 이득입니다. => `그리디`<br>

상담원마다 여유가 발생하는 시간을 구현해야 합니다. 가장 먼저 여유가 생기는 상담원을 찾아야 하며, 나중에 상담을 시작한 인원이 먼저 여유가 발생할 수 있습니다. 이는 `우선순위 큐`로 구현할 수 있습니다. 우선순위 큐는 상담원 여유 시작 시간을 오름차순으로 저장합니다. 유형 수만큼 우선순위 큐를 생성하고, 각 유형마다 상담원(초기값: 0)을 넣어줍니다. 그리고 모든 참가자를 순회하며 다음 과정을 따릅니다:

```
1. 현재 참가자 유형에 맞는 큐 가져오기
2. 큐에서 값 꺼내고 참가자 대기 시간 계산
	- 대기 시간 = 상담원 시간 - 참가자 시작 시간
	- 만약 대기 시간이 0 이상이면 총 대기 시간에 합산
3. 해당 상담원의 상담이 끝나는 시간을 큐에 넣기
	- 끝나는 시간 = 상담 시작 시간 + 상담에 걸리는 시간
	- 상담 시작 시간 = max(상담원 시간, 참가자 시작 시간)
```

## 코드
```
#include <vector>
#include <queue>
using namespace std;
int N, K, answer = 1e9;
vector<int> selected;<br>
vector<vector<int>> R;<br>

void combination(int start, int depth) {
    if (depth == K - 1) {
        priority_queue<int, vector<int>, greater<int>> pq[5];<br>
        int mento[5] = { selected.size() > 0 ? selected[0] : N, }, wait = 0;<br>
        for (int i = 1; i < K - 1; i++)
            mento[i] = selected[i] - selected[i - 1];
        if (K > 1)<br>
            mento[K - 1] = N - selected[K - 2];
        for (int i = 0; i < K; i++)
            for (int p = 0; p < mento[i]; p++)
                pq[i].push(0);
        for (auto r : R) {
            int s = pq[r[2] - 1].top(); pq[r[2] - 1].pop();
            wait += s - r[0] > 0 ? s - r[0] : 0;<br>
            pq[r[2] - 1].push(max(s, r[0]) + r[1]);
        }
        answer = min(answer, wait);
        return;
    }
    for (int i = start; i < N; i++) {
        selected.push_back(i);
        combination(i + 1, depth + 1);
        selected.pop_back();
    }
}

int solution(int k, int n, vector<vector<int>> reqs) {<br>
    N = n, K = k, R = reqs;
    combination(1, 0);
    return answer;
}
```

## 링크
https://school.programmers.co.kr/learn/courses/30/lessons/214288
{% endraw %}