---
categories:
- Cert
date: '2022-04-23'
title: '[정보처리기사] 2022-2회 정보처리기사 필기'
---

{% raw %}

## 소프트웨어 설계
### 소프트웨어 생명 주기, SDLC(Software Development Life Cycle)
#### 폭포수 모형(Waterfall Model)
- 가장 오래되고 가장 폭넓게 사용된 고전적 생명 주기 모형
- **한 단계가 끝나야만 다음 단계로 넘어가는** 선형 순차적 모형
- 단계별 정의 및 산출물이 명확
- 개발 중간에 요구사항의 변경이 용이하지 않음
- 유지보수단계에서 가장 많은 비용이 소모됨
- 타당성검토 → 계획 → 요구 분석 → 설계 → 구현(코딩) → 테스트(검사) → 유지보수

#### 프로토타입 모형(Prototype Model, 원형 모형)
- 견본(시제)품을 만들어 최종 결과물을 예측하는 모형
- 인터페이스 중점을 두어 개발
- 개발 중간에 요구사항의 변경이 용이

#### 나선형 모형(Spiral Model, 점진적 모형)
- 폭포수 모형과 프로토타입 모형의 장점에 위험 분석 기능을 추가한 모형
- 소프트웨어를 개발하면서 발생할 수 있는 위험을 관리하고 최소화하는 것이 목적
- **점진적 개발 과정 반복**으로 요구사항 추가 가능
- 정밀하고 유지보수 과정 필요 없음
- 비교적 대규모 시스템에 적합
- 요구사항이나 아키텍처를 이해하기 어렵다거나 중심이 되는 기술에 문제가 있는 경우 적합
- 계획 및 정의 → 위험 분석 → 공학적 개발 → 고객 평가

#### V 모델
- 폭포수 모델의 확장 형태
- 생명주기 단계별로 상응하는 테스트 단계가 존재
- V 형태로 진행 - 아래 방향으로 진행하다가 코딩 단계를 거치면서 위로 향함
- 테스트 중요시 - 적정 수준의 품질 보증
- 폭포수 모델에 비해 반복과 재처리 과정이 명확함
- 테스트 작업을 단계별로 구분하므로 책임 소재가 명확함
- Perry에 의해 제안되었으며 세부적인 테스트 과정으로 구성되어 신뢰도 높은 시스템을 개발하는데 효과적

#### 애자일 방법론
신속한 반복 작업을 통해 고객의 만족도를 개선하는 소프트웨어 개발 방식
- **개인과 개인 간의 상호작용**이 프로세스 및 툴보다 우선
- **작동하는 소프트웨어**가 포괄적인 문서보다 우선
- **고객과의 협업**이 계약 협상보다 우선
- **변화에 대응**하는 것이 계획을 따르는 것보다 우

### 스크럼(Scrum) 기법
- 팀이 중심이 되어 개발의 효율성을 높이는 애자일 방법론 기법
- 팀원 스스로가 스크럼 팀 구성
- 개발 작업에 관한 모든 것을 스스로 해결해야 함
- **스크럼 마스터(Scrum Master)**: 스크럼 프로세스를 따르고, 팀이 스크럼을 효과적으로 활용할 수 있도록 보장하는 역할 등을 맡음
- **제품 백로그(Product Backlog)**: 스크럼 팀이 해결해야 하는 목록으로 소프트웨어 요구사항, 아키텍처 정의 등이 포함
- **스프린트(Sprint)**: 하나의 완성된 최종 결과물을 만들기 위한 주기로 2 ~ 4주 정도의 기간으로 진행
- **속도(Velocity)**: 한 번의 스프린트에서 한 팀이 어느 정도의 제품 백로그를 감당할 수 있는지에 대한 추정치

### XP(eXtreme Programming)
- 짧은 주기의 반복을 통해 요구 변화에 신속하게 대응하여 위험을 줄이고 고객 관점의 고품질 SW를 빠르게 전달하는 애자일 방법론 기법
- 용기(Courage), 단순성(Simplicity), 의사소통(Communication), 피드백(Feedback), 존중(Respect)

#### XP의 기본원리
- Whole Team(전체 팀), Small Releases(소규모 릴리즈)
- Test-Driven Development(테스트 주도 개발), Continuous Integration(계속적인 통합)
- Collective Ownership(공동 소유권), Pair Programming(짝 프로그래밍)
- Design Improvement(디자인 개선) 또는Refactoring(리팩토링)

#### FDD(기능중심 개발, Feature-Driven Development)
- 애자일 방법론 기법
- Peter Coad가 제창하는 방법론으로써, UML을 이용한 설계 기법과도 밀접한 관련을 가진다.

### UI기본 원칙
- **직관성**: 누구나 쉽게 이해하고 사용할 수 있어야함
- **유효성**: 사용자의 목적을 정확하고 완벽하게 달성해야 함
- **학습성**: 누구나 쉽게 배우고 익힐 수 있어야함
- **유연성**: 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 함

### UI설계 도구
- **와이어프레임(Wireframe)**: 레이아웃을 협의하거나 공유하기 위해 사용
- **스토리보드(Story Board)**: 최종적으로 참고하는 작업 지침서, 작업 산출물 (디스크립션)
- **프로토타입(Prototype)**: 인터랙션을 적용해 실제 구현된 것처럼 테스트가 가능한 동적인 모형
- **목업(Mockup)**: 실제 화면과 유사한 정적인 모형
- **유스케이스(Use Case)**: 사용자 측면 요구사항을 다이어그램 형식으로 묘사 (유스케이스 명세서)

### 객체지향 분석 기법
- 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 클래스(객체), 이와 연관된 속성과 연산, 그들 간의 관계 등을 정의하여 모델링하는 작업을 의미
- 객체는 클래스로부터 인스턴스화되고, 이 클래스를 식별하는 것이 객체지향 분석의 주요한 목적

#### 객체지향 원리
- **일반화(Generalization)**:
	- 객체들에 있어 공통적인 성질들을 상위 객체로 정의하고, 특수화(specialization)된 객체들을 하위의 부분형(subtype) 객체로 정의하는 추상화 방법
	- 상속과 관련있음
- **추상화(Abstraction)**:
	- 현실 세계의 물체를 객체에 사상할 때에는 현실을 그대로 객체로서 표현하는 것이 아니고, 문제의 중요한 측면, 혹은 주목하고 싶은 문제의 측면을 강조
	- 불필요한 부분을 생략하고 객체의 가장 중요한 것에만 중점을 두어 간략화 시킨 것
- **캡슐화(Encapsulation)**
	- 객체의 자료와 행위를 하나로 묶고, 실제 구현 내용을 외부에 감추는 것
	- 캡슐화 된 객체의 행위는 외부에서 볼 때는 실제가 아닌 추상적인 것이 되므로 정보 은닉(information hiding)개념이 지켜짐
- **정보 은닉**
	- 객체가 캡슐화를 통하여 내부의 데이터나 오퍼레이션의 구현 내용을 감추는 것
	- 외부에서의 무분별한 접근을 허용하지 않음
- **집단화(Aggregation)**: 
	- 클래스들 사이의 부분-전체(part-whole) 또는 부분(is-a-part-of) 관계로 설명되는 연관성
	- 집단화는 여러 부속 객체들이 조립되어 하나의 객체가 구성되는 것을 의미
	- 컴퓨터 - 본체, 모니터, 키보드, 마우스 .. 이런씩으로 나누는 것

#### 객체지향 5원칙 (SOLID)
- **단일 책임의 원칙(SRP, Single Responsibility Principle)**: 하나의 모듈은 한 가지 책임을 가져야 한다는 것  
- **개방 폐쇄 원칙(Open-Closed Principle, OCP)**: 확장에 대해 열려있고 수정에 대해서는 닫혀있어야 한다는 원칙. 기존의 코드를 변경하지 않고(Closed), 기능을 수정하거나 추가할 수 있도록(Open) 설계해야 함
- **리스코프 치환 원칙 (Liskov Substitution Principle, LSP)**: 서브타입(하위 클래스, 자식 클래스)은 어디에서나 자신의 기반타입(상위 클래스, 부모클래스)으로 교체할 수 있어야 함
- **인터페이스 분리 원칙 (Interface segregation principle, ISP)**: 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 않아야 함 → 자신이 사용하지 않는 기능(인터페이스)에는 영향을 받지 않아야 함
- **의존 역전 원칙 (Dependency Inversion Principle, DIP)**: 의존 관계를 맺을 때, 변화하기 쉬운 것보단 변화하기 어려운 것에 의존해야 한다는 원칙

#### 럼바우의 객체 지향 분석 / 객체 모델링 기법(OMT) 
소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 객체지향 분석(Object-oriented Analysis) 기법
- 객체 모델링 - 객체 다이어그램
- 동적 모델링 - 상태도 (상태 다이어그램)
- 기능 모델링 - 자료 흐름도
- 객체 모델링 -> 동적 모델링 -> 기능 모델링

**객동기**

- 기능 모델링 설계 순서
	1. 입출력 결정
	2. 자료 흐름도 작성(기능 의존 관계를 서술)
	3. 기능의 내용을 상세히 기술
	4. 제약사항을 결정하고 최소화

#### 객체지향 분석 방법론
 **Coad-Yourdon 방법**: E-R 다이어그램을 사용하여 객체의 행위를 모델링하며, 객체 식별, 구조 식별, 주체 정의, 속성 및 관계 정의, 서비스 정의 등의 과정으로 구성되는 것
 **Booch 방법**: 미시적(Micro) 개발 프로세스와 거시적(Macro) 개발 프로세스를 모두 사용하는 분석 방법
 **Jacobson 방법**: 유스케이스(Use Case, 사용사례)를 강조하여 사용하는 분석 방법
 **Wirfs-Brocks 방법**: 분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행하는 분석 방법

### UML(Unified Modeling Language)
- 모델을 만드는 통합 표준 언어 (야매: 순서도같은 그림으로 표현하는 것이다)
- 스테레오 타입 객체 표현 - << >>

#### 사물(Things)
- 구조, 행동, 그룹

#### 관계(Relationships)
- **연관(Association, ㅡ)** = 클래스간 연결, 참조 관계
- **집합(Aggregation, ◇)** = 집합연관관계, 전체 소멸 시 부분은 사용가능
- **포함(Composition, ◆)** = 합성연관관계, 전체 소멸 시 부분도 소멸
- **일반화(Generalization, ㅡ▷)** = 상속, 상위-하위 관계
- **의존(Dependancy -->)** = 어떤 클래스 변화가 다른 클래스에 영향
- **실체화(Realization, --▷)** = 추상적인 인터페이스를 실제로 구현한 관계. 한 객체가 다른 객체에게 오퍼레이션을 수행하도록 지정하는 의미적 관계

#### 정적 다이어그램(Diagram)
- **클래스, 객체 데이터 구조**와 이것들의 관계를 그림으로 표현해서 소프트웨어 요소에서 **변하지 않는 논리적 구조**를 보여준다.
- **클래스 다이어그램(Class Diagram)**
	- 클래스: 동일한 속성과 행위를 수행하는 객체의 집합
		- 가장 윗부분: 클래스 이름
		- 중간 부분: 속성(클래스의 특징)
		- 마지막 부분: 연산(클래스가 수행하는 책임)
	- 접근 지시자
		- public: +
		- private: -
		- protected: #
		- package: ~
	- 연관 관계: 화살표, 실선
	- 일반화 관계: 삼각형+실선
	- 집합 관계: 마름모+실선
	- 의존 관계: 화살표, 점선
- **객체 다이어그램(Object Diagram)**
	- 클래스 다이어그램과 비슷하지만 클래스기 아닌 인스턴스에 중점
- **컴포넌트 다이어그램(Component)**
	- 시스템을 구성하는 소프트웨어의 조각, 임베디드 컨트롤러 등, 그들의 조직과 종속성을 보여준다.  
- **배치 다이어그램(Deployment)**
	- 시스템의 소프트웨어와 하드웨어 컴포넌트 간 관계 및 처리의 물리적 분배를 표시
- **복합체 구조 다이어그램(Composite Structure Diagram)**
	- 클래스의 내부 구조를 보여주기 위해 사용
- **패키지 다이어그램(Package Diagram)**
	- 패키지대으로 한 다이어그램 
- 컴포넌트, 배치 다이어그램은 구현 단계에서 사용된다.

#### 동적 다이어그램(Diagram)
- **실행 흐름**을 그림을 그리거라 실체의 상태가 어떻게 바뀌는지 그림으로 표현해서 소프트웨어 안의 **실체가 실행 도중 어떻게 변하는지** 보여준다.
- **유스케이스 다이어그램(Use Case Diagram)**
	- 시스템과 사용자의 상호작용을 다이어그램으로 표현한 것
	- **시스템(System)**: 만들고자 하는 프로그램. 사각형 틀
	- **액터(Actor)**: 시스템의 외부에 있고 시스템과 상호작용을 하는 사람. 원과 선을 조합하여 사람, 스틱맨으로 표현
	- **유스케이스(Usecase)**: 사용자 입장에서 바라본 시스템의 기능. 시스템이 액터에게 제공해야 하는 기능으로 시스템의 요구사항. 타원으로 표시
	- **관계(Relation)**: 액터와 유스케이스 사이의 의미있는 관계
		- **연관(Association)**: 유스케이스와 액터간의 상호작용이 있음 = 실선
		- **포함(Include)**: 하나의 유스케이스가 다른 유스케이스의 실행을 전제로 할 때 형성되는 의존 관계 = 점선, << include >>
		- **확장(Extend)**: 케이스와 확장대상 유스케이스 사이에 형성되는 의존 관계로, 해당 유스케이스에 부가적인 유스케이스를 실행할 수 있을 때의 관계. 기본 유스케이스 수행 시 특별한 조건을 만족할 때 수행하는 유스케이스 = 점선, << extend >>
	- **일반화 (Generalization)**: 유사한 유스케이스 또는 액터를 모아 추상화한 유스케이스 = 삼각형+실선
- **순차 다이어그램(Sequence Diagram)**
	- 시스템이 전달하는 메시지의 시간적 흐름을 나타내려고 하는 상호작용 다이어그램
	- **객체**: 시스템 객체
	- **생명선**: 상호작용에 참여하는 오브젝트. 활성 객체마다 가지는 x축에 수직한 선
	- **메시지**: 객체간 의사소통, 연결 기능을 담당. 선+화살표로 표시됨
	- **실행(활성) 박스**: 생명선 위에 그려지는 박스로, 메시지의 종료를 받음
- **커뮤니케이션 다이어그램(Communication Diagram)**
	- 요소들 간의 데이터 연결을 강조
	- 메시지에 번호를 붙여 메시지의 순서를 나타낸다.
- **상태 다이어그램(State Diagram)**
	- 객체의 행동, 상태를 중점으로 표현 
- **활동 다이어그램(Activity Diagram)**
	- 일련의 Activity들로 어떤 프로세스를 표현하는 다이어그램
- **상호작용 개요 다이어그램(Interaction Overview Diagram)**
	- 시스템 구성 요소들 사이의 상호작용을 표현하는 다이어그램
- **타이밍(Timing Diagram)**
	- 시간에 따라 표시하는 다이어그램

### NS(Nassi-Schneiderman) Chart
- 논리의 기술에 중점을 둔 도형식 표현 방법
- 전문성이 있어야 그리기 쉬움 (그리기 어려움)
- 연속, 선택 및 다중 선택, 반복 등의 제어논리 구조로 표현함
- 임의의 제어 이동이 어려움 → goto구조가 어려움
- 그래픽 설계 도구임, 상자 도표라고도 함
- 도형만 사용하며 **선은 사용하지 않음**
- 이해하기 쉽고 코드 변환이 용이
- 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는데 적합함

### 미들웨어(Middleware)
운영체제와 응용 프로그램 사이에서 추가적인 서비스를 제공하는 소프트웨어
- **DB(Database)**
	- 클라이언트에서 원격의 데이터베이스와 연결하기 위한 미들웨어, 2-Tier 아키텍처  
	- ODBC(마이크로소프트), IDAPI(볼랜드), Glue(오라클)
- **RPC(Remote Procedure Call,원격 프로시저 호출)**
	- 응용 프로그램의 프로시저를 사용해 원격 프로시저를 로컬 프로시저처럼 호출하는 방식의 미들웨어  
	- Entera(이큐브시스템스), ONC/RPC(OSF)
- **MOM(Message Oriented Middleware,메시지 지향 미들웨어)**
	- 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어  
	- MQ(IBM), Message Q(오라클), JMS(JCP)
- **TP-Monitor(Transaction Processing Monitor,트랜잭션 처리 모니터)**
	- 항공기나 철도 예약 업무 등과 같은 온라인 트랜잭션 업무에서 트랜잭션을 처리 및 감시하는 미들웨어
	- 사용자 수가 증가해도 빠른 응답 속도를 유지해야 하는 업무에 주로 사용됨  
	- tuxedo(오라클), tmax(티맥스소프트)
- **Legacyware(레거시웨어)**
	- 기존 애플리케이션에 새로운 업데이트된 기능을 덧붙이고자 할 때 사용되는 미들웨어
- **ORB(Object Request Broker,객체 요청 브로커)**
	- 객체 지향 미들웨어로 코바(CORBA)  표준 스펙을 구현한 미들웨어
	- 코바(CORBA; Common Object Request Broker Architecture): 네트워크에서 분산 프로그램 객체를 생성, 배포, 관리하기 위한 규격을 의미
	- Orbix(Micro Focus), CORBA(OMG)
- **WAS(Web Application Server,앱 애플리케이션 서버)**
	- 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어
	- HTTP 세션 처리를 위한 웹 서버 기능뿐만 아니라 미션-크리티컬한 기업 업무까지 JAVA, EJB 컴포넌트 기반으로 구현이 가능  
	- Web Logic(오라클), WebSphere(IBM), JEUS, Tomcat

### 분산 시스템(distributed system)
- 사용자가 보기에 하나의 시스템으로 보이는, 여러 개의 독립적인 컴퓨터들의 집합 
- 동일한 테스크를 처리하기 위해 각 컴퓨터는 네트워크상에서 서로 통신하며 협력한다.

### 소프트웨어 품질
#### 국제 제품 품질 표준
- ISO/IEC **9126**
	- 소프트웨어 품질 평가 모델
- ISO/IEC **12119**
- ISO/IEC **14598**:
	- 소프트웨어 평가 절차 모델
	- 반복성(Repeatability), 재현성(Reproducibility), 공정성(Impartiality), 객관성(Objectivity)
- ISO/IEC **25000**:
	- 위 3개 표준을 통합한 SW 품질 평가 통합 모델
	- System and Software Quality Requirements and Evaluation으로 줄여서 SQuaRE라고도 함
		- **2500n**: 품질 관리
		- **2501n**: 품질 모델
		- **2502n**: 품질 측정
		- **2503n**: 품질 요구
		- **2504n**: 품질 평가

#### 소프트웨어 품질 목표
- **기능성(Functionality)**
	- 사용자의 요구사항을 충족시키는 정도
	- 적절성(적합성), 정확성(Correctness), 상호 운용성, **보안성**, 호환성
- **신뢰성(Reliability)**
	- 정확하고 일관된 결과로 요구된 기능을 오류없이 수행하는 시스템 능력의 정도
	- 성숙성, 결함 허용성, 회복성
- **사용성(Usability)**
	- 사용자가 소프트웨어를 쉽게 배우고 사용할 수 있는가의 정도
	- 이해성, 학습성, 운용성, 친밀성
- **효율성(Efficiency)**
	- 최소한의 처리 시간과 기억 장소를 소유하여 요구된 기능을 수행하는 시스템 능력을 의미하는 정도
	- 시간 효율성, 자원 효율성
- **유지 보수성(Maintainability)**
	- 사용자의 기능 변경의 필요성을 만족하기 위하여 소프트웨어를 진화하는 것이 가능한 정도
	- 분석성, 변경성, 안정성, 시험성
- **이식성(Portability)**
	- 다양한 하드웨어 환경에서도 운용 가능하도록 쉽게 수정될 수 있는 정도
	- 적용성, 설치성, 대체성, 공존성
- **재사용성(Reusability)**
	- 개발된 기능을 다른 목적으로 사용하기 용이한 정도
- **무결성(Integrity)**
	- 허용하지 않은 사용이나 자료의 변경을 제어하는 정도
- **시험 용이성(Testability)**
	- 개선, 유지보수 등에 있어서 소프트웨어를 쉽게 검사할 수 있는가의 정도
- **유연성(Flexibility)**
	- 새로운 요구사항에 대해서도 쉽게 개선 및 적용 가능한 정도
- **상호 운용성(Interoperability)**
	- 다른 소프트웨어와 정보를 교환할 수 있는 정도

#### 국제 프로세스 품질 표준
- ISO/IEC **9001**
- ISO/IEC **12207**: 
	- 국제 표준 소프트웨어 생명 주기 프로세스로, 소프트웨어의 개발, 운영, 유지보수 등을 체계적으로 관리하기 위한 소프트웨어 생명 주기 표준을 제공
	- **기본 프로세스**: 획득, 공급, 개발, 운영, 유지보수
	- **지원 프로세스**: 문서화, 형상관리, 품질보증, 검증(Veri), 확인(Vali), 합동검토(Joint review), 감사, 문제해결
	- **조직 프로세스**: 관리, 기반구조(infrastructure), 개선, 교육훈련
- ISO/IEC **15504(SPICE)**:
	- 소프트웨어 개발 표준 중 소프트웨어의 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준
	- 프로세스 개선을 위해 개발 기관이 스스로 평가
	- 기관에서 지정한 요구조건의 만족여부를 개발 조직이 스스로 평가
	- 계약 체결을 위해 수탁 기관의 프로세스를 평가
		- **불완전**: 프로세스가 구현되지 않았거나 목적을 달성하지 못한 단계
		- **수행**: 프로세스가 수행되고 목적이 달성된 단계
		- **관리**: 정의된 자원의 한도 내에서 그 프로세스가 작업 산출물을 인도하는 단계
		- **확립**: 소프트웨어 공학 원칙에 기반하여 정의된 프로세스가 수행되는 단계
		- **예측**: 프로세스가 목적 달성을 위해 통제되고, 양적인 측정을 통해서 일관되게 수행되는 단계
		- **최적화**: 프로세스 수행을 최적화하고, 지속적인 개선을 통해 업무 목적을 만족시키는 단계
		- 불완전 → 수행 → 관리 → 확립 → 예측 → 최적화  

#### CMMI(Capability Maturity Model Integration)
소프트웨어 개발 업체들의 업무능력평가 기준을 세우기 위한 평가 모형. 조직차원의 성숙도를 평가하는 단계별 표현과 프로세스 영역별 능력도를 평가하는 연속적 표현이 있음
- **초기(Initial)**
	- 정의된 프로세스 없음
	- 작업자 능력에 따라 성공 여부 결정
- **관리(Managed)**
	- 규칙화된 프로세스
	- 특정한 프로젝트 내의 프로세스 정의 및 수행
- **정의(Defined)**
	- 표준화된 프로세스
	- 조직의 표준 프로세스를 활용하여 업무 수행
- **정량적 관리(Quantitatively Managed)**
	- 예측 가능한 프로세스
	- 프로젝트를 정량적으로 관리 및 통제
- **최적화(Optimizing)**
	- 지속적 개선 프로세스
	- 프로세스 역량 향상을 위해 지속적인 프로세스 개선

### 소프트웨어 아키텍처
- 외부에서 인식할 수 있는 특성이 담긴 소프트웨어의 골격이 되는 기본 구조
- 이해 관계자들의 품질 요구사항을 반영하여 품질 속성을 결정한다.

#### 추상화(Abstraction)
전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화 시키는 것
- **과정 추상화**: 자세한 수행 과정을 정의하지 않고, 전반적인 흐름만 파악
- **데이터 추상화**: 데이터의 세부적인 속성이나 용도를 정의하지 않고, 데이터 구조를 대표하는 표현으로 대체
- **제어 추상화**: 이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표하는 표현으로 대체

#### 아키텍처 설계 순서
설계 목표 설정 → 시스템 타입 결정 → 아키텍처 패턴 적용 →  서브시스템 구체화 → 검토

1.  설계 목표 설정 : 시스템의 개발 방향을 명확히 하기 위해 설계에 영향을 주는 비즈니스 목표, 우선순위 등의 요구사항을 분석하여 전체 시스템의 설계 목표를 설정
2.  시스템 타입 결정: 시스템과 서브시스템의 타입을 결정하고, 설계 목표와 함께 고려하여 아키텍처 패턴을 선택
3.  아키텍처 패턴 적용 : 아키텍처 패턴을 참조하여 시스템의 표준 아키텍처를 설계
4.  서브시스템 구체화 : 서브시스템의 기능 및 서브시스템 간의 상호작용을 위한 동작과 인터페이스를 정의
5.  검토 : 아키텍처가 설계 목표에 부합하는지, 요구사항이 잘 반영되었는지, 설계의 기본원리를 만족하는지 등을 검토

### 아키텍처 패턴
1. **레이어 패턴(Layers Pattern)**
	- 시스템을 계층(Layer)으로 구분하여 구성하는 고전적 방법
2. **클라이언트-서버 패턴(Client-Server Pattern)**
	- 하나의 서버 컴포넌트와 다수 클라이언트 컴포넌트로 구성되는 패턴
	- 클라이언트나 서버는 요청과 응답을 받기 위해 동기화 되는 경우를 제외하고는 서로 독립적
	- 컴포넌트(Component): 독립적인 업무 또는 기능을 수행하는 실행코드 기반으로 작성된 모듈
3. **파이프-필터 패턴(Pipe-Filter Pattern)**
	- 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화해 파이프를 통해 단방향으로 데이터를 전송하는 패턴
	- 필터 컴포넌트는 재사용성이 좋고, 추가가 쉬워 확장 용이
	- 필터 컴포넌트들을 재배치하여 다양한 파이프라인 구축 가능
	- UNIX의 쉘(Shell)
4. **모델-뷰-컨트롤러 패턴(Model-View-Controller, MVC Pattern)**
	- 서브시스템을 3개의 부분으로 구조화하는 패턴
	- 모델(**M**odel): 서브시스템의 핵심 기능과 데이터를 보관
	- 뷰(**V**iew): 사용자에게 정보를 표시
	- 컨트롤러(**C**ontroller): 사용자로부터 받은 입력 처리 / 뷰 제어 / UI 담당
	- 각 부분은 별도의 컴포넌트로 분리되어 있으므로 서로 영향을 받지 않고 개발 작업 수행
	- 한 개의 모델에 대해 여러 개의 뷰를 만들 수 있으므로 대화형 애플리케이션에 적합
5. **마스터-슬레이브 패턴(Master-Slave Pattern)**
	- 마스터 컴포넌트에서 슬레이브 컴포넌트로 분할한 후, 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업을 수행하는 패턴
	- 장애 허용 시스템(Fault Tolerance System), 병렬 컴퓨팅 시스템
6. **브로커 패턴(Broker Pattern)**
	- 컴포넌트와 사용자를 연결해주는 패턴
	- 분산 환경 시스템
7. **피어-투-피어 패턴(Peer-To-Peer Pattern)**
	- 피어를 하나의 컴포넌트로 간주하며, 각 피어는 서비스를 호출하는 클라이언트가 될 수도, 서비스를 제공하는 서버가 될 수도 있는 패턴
	- 멀티스레딩(Multi Threading) 방식 사용
8. **이벤트-버스 패턴(Event-Bus Pattern)**
	- 소스가 특정 채널에 이벤트 메시지를 발행하면, 해당 채널을 구독한 리스너들이 메시지를 받아 이벤트를 처리하는 방식
	- 이벤트를 생성하는 소스(Source), 이벤트를 수행하는 리스너(Listener), 이벤트의 통로인 채**널(Channel), 채널들을 관리하는 버스(Bus)
9. **블랙보드 패턴(Blackboard Pattern)**
	- 해결책이 명확하지 않은 문제를 처리하는데 유용한 패턴
	- 음성인식, 차량 식별, 신호 해석
10. **인터프리터 패턴(Interpreter Pattern)**
	- 특정 언어로 작성된 프로그램 코드를 해석하는 컴포넌트를 설계할 때 사용됨

### 디자인 패턴
객체 지향 프로그래밍 설계를 할 때 자주 발생하는 문제들을 피하기 위해 사용되는 패턴. 상황에 따라 자주 쓰이는 설계 방법을 정리한 코딩 방법론이다.

GoF(Gang of Four)이 유명하다.

#### 생성 패턴(Creational Pattern)
- **추상 팩토리(Abstract Factory)**:  구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴. 서로 연관, 의존하는 객체들을 그룹으로 생성해 추상적으로 표현. 
- **팩토리 메소드(Factory Method)**: 객체를 만들어 반환하는 함수를 (생성자 대신) 제공하여 초기화 과정을 외부에서 보지 못하게 숨기고 반환 타입을 제어하는 방법. 객체를 생성하기 위한 인터페이스를 정의하여, 어떤 클래스가 인스턴스화 될 것인지는 서브클래스가 결정하도록 하는 것 (Virtual-Constructor 패턴)
- **빌더(Builder)**: 인스턴스를 생성자를 통해 직접 생성하지 않고, 빌더라는 내부 클래스를 통해 간접적으로 생성하게 하는 패턴. 객체의 생성 과정과 표현 방법 분리 → 동일한 객체 생성에도 서로 다른 결과
- **프로토타입(Prototype)**: 원본 객체를 복제하는 방법
- **싱글톤(Singleton)**: 하나의 객체 → 하나의 인스턴스 (ex. 점수판, 시스템 오브젝트) 하나의 객체를 여러 프로세스가 동시에 참조할 수 없음

#### 구조 패턴(Structural Pattern)
- **어댑터(Adapter)**: 호환성이 없는 클래스 인터페이스를 이용할 수 있도록 변환해주는 패턴
- **브리지(Bridge)**: 구현부에서 추상층을 분리하여, 독립적으로 확장 및 다양성을 가지는 패턴
- **컴포지트(Composite)**: 여러 객체를 가진 복합, 단일 객체를 구분 없이 다룰 때 사용하는 패턴
- **데코레이터(Decorator)**: 상속을 사용하지 않고도 객체의 기능을 동적으로 확장해주는 패턴
- **퍼싸드(Facade)**: 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴 ex) 리모컨
- **플라이웨이트(Flyweight)**: 공유해서 사용함으로써 메모리를 절약하는 패턴
- **프록시(Proxy)**: 접근이 어려운 객체를 연결해주는 인터페이스 역할을 수행하는 패턴

**어브컴데퍼플프**

#### 행위 패턴(Behavioral Pattern)
- **책임 연쇄(Chain of Responsibility)**: 한 객체가 처리하지 못하면 다음 객체로 넘어가는 패턴
- **커맨드(Command)**: 요청에 사용되는 각종 명령어들을 추상, 구체 클래스로 분리하여 단순화함
- **인터프리터(Interpreter)**: 언어에 문법 표현을 정의하는 패턴
- **반복자(Iterator)**: 동일한 인터페이스를 사용하도록 하는 패턴
- **중재자(Mediator)**: 서로의 존재를 모르는 상태에서도 협력할 수 있게 하는 패턴
- **메멘토(Memento)**: 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴
- **옵서버(Observer)**: 관찰 대상의 변화를 탐지하는 패턴
- **상태(State)**: 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
- **전략(Strategy)**: 클라이언트에 영향을 받지 않는 독립적인 알고리즘을 선택하는 패턴
- **템플릿 메소드(Template Method)**: 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에 정의하는 패턴
- **방문자(Visitor)**: 필요할 때마다 해당 클래스에 방문해서 처리하는 패턴

### 요구 사항(Requirement)
- **기능 요구사항**: 기능, 입력, 출력, 저장, 수행
- **비기능 요구사항**: 성능, 품질, 제약사항, 호환성, 보안
- **요구사항 분석(Requirement Analysis)**: 소프트웨어 개발의 실제적인 첫 단계로 사용자의 요구에 대해 이해하는 단계
	- 청취와 인터뷰 질문 기술, 분석과 중재기술, 관찰 및 모델 작성 기술, 비용과 일정에 대한 제약설정, 타당성 조사, 요구사항 정의 문서화

#### 요구사항 개발 프로세스
1. 도출(Elicitation)/추출: 프로젝트 계획 단계에 정의한 문제의 범위 안에 있는 사용자의 요구를 찾는 단계
2. 분석(Analysis): 요구에 대한 정보를 수집하고 배경을 분석하여 이를 토대로 모델링
3. 명세(Specification): 도출된 기능과 특성을 글로 기록
4. 확인(Validation)/검증(Valification)

#### 요구사항 분석 기법
1.  **요구사항 분류**
	- 기능/비기능 분류
2.  **개념 모델링 생성 및 분석**
    - 요구사항을 더 쉽게 이해할 수 있도록 현실 세계 상황을 단순화, 개념적으로 표현
    - 객체 모델, 데이터 모델, 유스케이스 다이어그램, 데이터 흐름 모델, 상태 모델, 목표 기반 모델, 사용자 인터페이스, 애자일 방법 등 다양한 개념 모델 작성 가능
    - 모델링 표기는 주로 UML을 사용
3. **요구사항 할당**
    - 아키텍처 구성요소를 식별하는 활동
    - 다른 구성요소와 어떻게 상호작용하는지 분석 → 추가 요구사항 발견 가능
4. **요구사항 협상**
    - 두 이해관계 사이 상충될 경우 적절한 지점 합의하기 위한 기법
    - 각각 우선순위 부여 → 중요도 파악 가능 → 문제 해결 도움
5. **정형 분석**
    - 형식적으로 정의된 의미를 지닌 언어로 요구사항을 표현
    - 구문과 의미를 갖는 정형화된 언어를 사용하여 수학적 기호로 표현
    - 요구사항 분석의 마지막 단계

#### 요구사항 검증(Requirements Verification)
인터페이스 요구사항 검토 계획 수립 → 검토 및 오류 수정 → 베이스라인 설정

- **동료 검토(Peer Review)**: 요구사항 명세서 작성자가 내용을 직접 설명하고 동료들이 이를 들으면서 결함을 발견하는 검토 방법
- **워크 스루(Walk Through)**: 검토회의 전에 요구사항 명세서를 미리 배포하여 사전 검토한 후, 짧은 검토 회의를 통해 결함을 발견하는 검토 방법
- **인스펙션(Inspection)**: 요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 확인하면서 결함을 발견하는 검토 방법

#### 요구사항 명세(Requirement Specification)
분석된 요구사항을 바탕으로 모델을 작성하고 문서화하는 것
- **정형 명세 기법**
	- 수학적 원리 기반, 모델 기반
	- 수학적 기호, 정형화된 표기법
	- 요구사항을 정확하고 간결하게 표현 가능
	- 요구사항에 대한 결과가 작성자에 관계없이 일관성이 있으므로 완전성 검증이 가능함  
	- 표기법이 어려워 사용자가 이해하기 어려움
	- VDM, Z, Petri-net, CSP
- **비정형 명세 기법**
	- 상태/기능/객체 중심
	- 일반 명사, 동사 등의 자연어를 기반으로 서술 또는 다이어그램으로 작성
	- 자연어의 사용으로 인해 요구사항에 대한 결과가 작성자에 따라 다를 수 있어 일관성이 떨어지고, 해석이 달라질 수 있음  
	- 내용의 이해가 쉬어 의사소통이 용이함
	- FSM, Decision Table, ER 모델링, State Chart(SADT)

#### 요구사항 분석 자동화 도구
- **SREM**: TRW사가 우주 국방 시스템 그룹에 의해 실시간 처리 소프트웨어 시스템에서 요구사항을 명확히 기술하도록 할 목적으로 개발한 것으로, RSL과 REVS를 사용하는 자동화 도구
- **PSL/PSA**: 미시간 대학에서 개발한 것으로 PSL과 PSA를 사용하는 자동화 도구
- **HIPO**: 시스템의 분석 및 설계나 문서화할 때 사용되는 하향식 기법으로 시스템 실행 과정의 입력, 처리, 출력의 기능을 나타내고, 종류로는 가시적 도표, 총체적 도표, 세부적 도표가 있음. 기능과 자료의 의존 관계를 동시에 표현할 수 있으며, 보기 쉽고, 변경, 유지 보수가 용이함
- **SADT**: SoftTech사에서 개발된 것으로 구조적 요구분석을 하기 위해 블록 다이어그램을 채택한 자동화 도구
- **TAGS**: 시스템 공학 방법 응용에 대한 자동 접근 방법으로, 개발 주기의 전 과정에 이용할 수 있는 통합 자동화 도구

### 응집도(Cohesion)
- 모듈의 내부 요소들의 서로 관련되어 있는 정도
- 응집도는 높을수록(↑) Good = 독립적인 모듈
- 아래로 갈수록 응집도가 높다.

1. **우연적 응집도(Coincidental Cohesion)**: 모듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우의 응집도
2. **논리적 응집도(Logical Cohesion)**: 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도
3. **시간적 응집도(Temporal Cohesion)**: 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도
4. **절차적 응집도(Procedural Cohesion)**: 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도
5. **통신적(교환적) 응집도(Communication Cohesion)**: 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도
6. **순차적 응집도(Sequential Cohesion)**: 모듈 내 하나의 활동으로부터 나온 출력 데이터(출력값)를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도
7. **기능적 응집도(Functional Cohesion)**: 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도

**우논시절통순기**

### 결합도(Coupling)
- 모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계를 의미
- 결합도는 낮을수록(↓) Good = 독립적인 모듈
- 아래로 갈수록 결합도가 낮다.

1. **내용 결합도(Content Coupling)**: 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도
2. **공통 결합도(Common Coupling)**: 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도 (전역 변수)
3. **외부 결합도(External Coupling)**: 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때의 결합도 (순차적)
4. **제어 결합도(Control Coupling)**: 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호를 이용하여 통신하거나 제어 요소를 전달하는 결합도
5. **스탬프 결합도(Stamp Coupling)**: 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도
6. **자료 결합도(Data Coupling)**: 어떤 모듈이 다른 모듈을 호출하면서 매개 변수(파라미터)나 인수로 데이터를 넘겨주고, 호출 받은 모듈은 받은 데이터에 대한 처리 결과를 다시 돌려주는 결합도

**내공외제스자**

### CASE(Computer-Aided Software Engineering)
- 소프트웨어 개발 과정의 일부 또는 전체를 **자동화**하기 위한 도구
- 표준화된 개발 환경 구축 및 문서 자동화 기능 제공
- 작업 과정 및 데이터 공유를 통해 작업자 간의 커뮤니케이션 증대
- 주요기능: S/W 라이프 사이클 전 단계의 연결, 그래픽 지원, 다양한 소프트웨어 개발 모형 지원

#### CASE 도구
- **상위 CASE**: 계획수립, 요구분석, 기본설계 단계를 다이어그램으로 표현. 모순 검사, 오류 검증, 자료흐름도 작성 지원
- **중위 CASE**: 상세 설계 작업, 화면 출력 작성 지원
- **하위 CASE**: 시스템 명세서, 소스 코드 생성 지원

### 협약에 의한 설계 (Design by Contract)
-   클래스에 대한 여러 가정을 공유하도록 명세한 것
-   소프트웨어 컴포넌트에 대한 정확한 인터페이스 명세를 위하여  선행조건,  결과조건,  불변조건을 나타내는 설계 방법

#### 협약에 의한 설계의 세 가지 타입
-   선행조건(Precondition): 오퍼레이션이 호출되기 전에 참이 되어야 하는 조건
-   결과조건(Postcondition): 오퍼레이션이 수행된 후 만족되어야 하는 조건
-   불변조건(Invatiant): 클래스 내부가 실행되는 동안 항상 만족하여야 하는 조건 (ex. 리스트에 있는 노드가 항상 오름차순으로 되어야 함)

### 코드 인스펙션
- 소스 코드를 대상으로 자동화된 도구를 통해 수행하는 정적 분석 기법
- 장애(Failure) 보다는 결함(Defects)를 발견하는 것이 주안점이다.
- 실제 프로그램을 실행시키는 동적 테스트 전, 조기에 결함을 발견할 수 있다.
- 동적 테스트로 발견할 수 없는 종류의 결함들을 발견할 수 있다.

### 자료 흐름도(DFD; Data Flow Diagram)
- 시스템 구성요소인 프로세스와 프로세스 간 데이터 흐름을 표현하는 주요도구
- 구조적 분석 기법에 이용된다.
- 시간 흐름을 명확하게 표현하지 않는다.
- 버블(Bubble)차트라고도 한다.
- **Process**: 자료를 처리하는 시스템. 처리, 기능, 변환, 버블이라고도 함. 타원으로 표시된다.
- **Terminator**: 시스템과 교신하는 외부 개체로, 입출력 담당. 사각형으로 표시된다.
- **Data Store**: 자료 저장소. 평행선 2개로 표시된다.
- **Data Flow**: 데이터의 이동을 표시. 화살표로 표시된다.

#### DFD 작성 지침
- 자료는 처리를 거쳐 변환될 때마다 새로운 명칭을 부여해야 한다.
- 자료흐름도의 최하위 처리(process)는 소단위명세서를 갖는다.
- 어떤 처리(process)가 출력자료를 산출하기 위해서는 필요한 자료가 반드시 입력되어야 한다.
- 상위단계의 처리(Process)와 하위 자료흐름도의 자료 흐름은 서로 일치돼야 한다.

### 소프트웨어 재사용 방법
- **합성 중심(Composition-Based)**: 전자 칩과 같은 소프트웨어 부품, 즉 블록(모듈)을 만들어서 끼워 맞추는 방법으로 소프트웨어를 완성시키는 재사용 방법 (블록 구성 방법)
- **생성 중심(Generation-Based)**: 추상화 형태로 쓰여진 명세를 구체화하여 프로그램을 만드는 방법 (패턴 구성 방법)

### 정형 데이터
- **정형 데이터(Structured data)**: 데이터베이스의 정해진 규칙(Rule)에 맞게 데이터를 들어간 데이터 중에 수치 만으로 의미 파악이 쉬운 데이터
- **비정형 데이터(Unstructured data)**: 정해진 규칙이 없어서 값의 의미를 쉽게 파악하기 힘든 데이터. 텍스트, 음성, 영상이 비정형 데이터에 속한다.
-**반정형 데이터(Semi-structured data)**: 약한 정형 데이터. 대표적으로 HTML이나 XML이 있다.

### 공통 모듈
- **정확성(Correctness)**: 시스템 구현 시 해당 기능이 필요하다는 것을 알 수 있도록 정확히 작성
- **명확성(Clarity)**: 해당 기능에 대해 일관되게 이해되고, 한 가지로 해석될 수 있도록 즉, 중의적으로 해석되지 않도록 명확하게 작성
- **완전성(Completeness)**: 시스템 구현을 위해 필요한 모든 것을 기술
- **일관성(Consistency)**: 공통 기능들 간 상호 충돌이 발생하지 않도록 작성
- **추적성(Traceability)**: - 기능에 대한 요구사항의 출처, 관련 시스템 등의 관계를 파악할 수 있도록 작성

#### 재사용(Reuse) 규모에 따른 분류
- 함수와 객체, 컴포넌트, 애플리케이션

### 코드
- **순차(순서) 코드(Sequence Code, 일련 번호 코드)**
	- 일정 기준에 따라서 최초의 자료부터 차례로 일련번호를 부여하는 방법
	- ex) 1, 2, 3, 4, …
- **블록 코드(Block Code, 구분 코드)**
	- 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호를 부여하는 방법
	- ex) 1001-1100: 총무부, 1101-1200: 영업부
- **10진 코드(Decimal Code, 도서 분류식 코드)**
	- 0~9까지 10진 분할하고, 다시 각각에 대해 10진 분할하는 방법을 필요한 만큼 반복하는 방법
	- ex) 1000: 공학, 1100: 소프트웨어 공학, 1110: 소프트웨어 설계
- **그룹 분류 코드(Group Classification Code)**
	- 일정 기준에 따라 대분류, 중분류, 소분류 등으로 구분하고, 각 그룹 안에서 일련번호를 부여하는 방법
	ex) 1-01-001: 본사-총무부-인사계, 2-01-001: 지사-총무부-인사계
- **연상 코드(Mnemonic Code, 기호 코드)**
	- 명칭이나 약호와 관계있는 숫자나 문자, 기호를 이용하여 코드를 부여하는 방법
		-ex) TV-40: 40인치 TV, L-15-220: 15W 220V 램프
- **표의 숫자 코드(Significant Digit Code, 유효 숫자 코드)**
	- 길이, 넓이, 부피, 지름, 높이 등의 물리적 수치를 그대로 코드에 적용시키는 방법
	- ex) 120-720-1500: 두께X폭X길이가 120X720X1500인 강판
- **합성 코드(Combined Code)**
	- 2개 이상의 코드를 조합하여 만드는 방법
	- ex) 연상 코드+순차 코드 → KE-711: 대한항공 711기, AC-253: 에어캐나다 253기
- **코드 부여 체계**
	- 이름만으로 개체의 용도와 적용 범위를 알 수 있도록 코드를 부여하는 방식
	- 각 개체에 유일한 코드 부여하여 개체들의 식별 및 추출을 용이하게 함
	- 코드를 부여하기 전 각 단위 시스템의 고유한 코드와 개체를 나타내는 코드가 정의되야 함
	ex) PJC-COM-003: 전체 시스템 단위의 3번째 공통 모듈
	ex) PY3-MOD-010: PY3라는 단위 시스템의 10번째 모듈

### fan-in & fan-out
시스템 복잡도 최적화를 위해서는 팬인은 높게, 팬아웃은 낮게 설계해야 한다.

#### fan-in
- **어떤 모듈을 제어(호출)하는 모듈의 수 = 트리의 위쪽(parent) 노드 개수**
- 하나의 모듈이 제어받는 상위 모듈의 수  
- 게이트가 수용할 수 있는 최대 입력의 수
  
#### fan-out
- **어떤 모듈의 의해 제어(호출)되는 모듈의 수 = 트리의 아래쪽(child) 노드 개수**
- 하나의 모듈이 제어하는 하위 모듈의 수  
- 출력 단자에 접속하여 신호를 추출할 수 있는 최대 허용 출력 수

### 자료 사전
자료, 자료들의 집합, 자료의 흐름, 자료 저장소와 그것들의 관계-범위-단위를 구체적으로 명시하는 것

#### 자료 사전 기호
- **= 자료의 정의**: ~로 구성되어 있다(is composed of)
- **+ 자료의 연결**: 그리고(and)
- **( ) 자료의 생략**: 생략 가능한 자료(Optional)
- **[ | ]자료의 선택**: 또는(or)
- **{ } 자료의 반복**: 자료 반복(Iteration of)
- **(별 2개) 자료의 설명**: 주석(Comment)

### 실시간 시스템 설계시 고려사항
- 인터럽트 처리와 문맥교환  
- 멀티태스킹과 멀티프로세싱에 의해 나타나는 병렬성  
- 태스크들간의 정보교환과 동기화  
- 자료와 통신속도의 다양성  
- 타이밍 제약조건의 표현  
- 오류처리와 고장복구를 위한 특별한 요구  
- 비동기 처리  
- 운영체제, 하드웨어 및 외부시스템 구성요소들간의 필수적이며 피할 수 없는 결합

### 소프트웨어 유지보수
- 소프트웨어를 직접 운용하며 잔존 버그 등을 찾고 추가 개선사항을 도출한다.
- 하드웨어, 환경 변화에 따라 소프트웨어를 적응 및 유지시킨다.
- 시간과 비용이 가장 많이 투입된다.
- **수정 보수(Corrective Maintenance)**
	- 소프트웨어 구축 시 테스트 단계에 미처 발견하지 못한 잠재적인 오류를 찾아 수정한다.
	- 수리 보수, 수정 보수, 정정 보수, 하자 보수라고도 한다.
- **적응 보수(Adaptive Maintenance)**
	- 운영체제, 하드웨어와 같은 프로그램 환경변화에 맞추기 위해 수행하는 유지보수
- **향상 보수(Perfective Maintenance)**
	- 기존 기능과 다른 새로운 기능을 추가하거나, 기존 기능을 개선 등
	- 소프트웨어 확장 및 리모델링
	- 유지보수 활동 중 가장 자원이 많이 소모되는 활동
- **예방 보수(Preventive Maintenance)**
	- 장래에 유지보수성 또는 신뢰성을 보장하기 위해 선재적으로 하는 유지보수
	- 소프트웨어의 잠재적인 오류발생에 대비하여 미리
	- S/W 재공학 관점에서 가장 연관 깊은 유지보수 유형

### 소프트웨어 재공학
- 기존 소프트웨어를 버리지 않고 기능을 개선시키거나 기능을 새로운 소프트웨어로 재활용하는 등 소프트웨어 재사용 공법
- 소프트웨어의 유지보수성과 품질을 향상시킬 수 있음
- 부작용을 미연에 발견하여 위험부담 제거 및 복구비용 절감
- 예방 유지보수 측면에서 소프트웨어 위기 해결
- **분석(Analysis)**
	- 기존 소프트웨어 명세를 확인하여 동작을 이해하고 재공학 대상을 선정
	- 재공학 가치판단 및 재공학 여부 판단
- **재구성(Restructuring)**
	- 소프트웨어 구조를 향상시키기 위해 코드를 재구성
	- 소프트웨어의 기능과 외적인 동작은 변경되지 않음
- **역공학(Reverse Engineering)**
	- 소프트웨어 동작 과정 및 설계 정보를 재발견 혹은 재생성
	- 소프트웨어를 구성하는 원시 코드를 복구하는 작업
	- 원시 코드로부터 설계정보 추출 및 절차 설계표현, 프로그램과 데이터 구조 정보 추출
	- 역공학의 가장 오래된 형태는 재문서화
- **이관(Migration)**
	- 기존 소프트웨어를 다른 운영체제, 하드웨어, 프레임워크 등에서 사용할 수 있도록 변환
	- 재구성 또는 재개발을 통한 새로운 소프트웨어에 기존
- **재사용(Reuse)**

### 3P
- 사람(People)
- 과정(Process)
- 제품(Product) - Task Framework의 고려와 가장 연관

### 연계 시스템 구성
- **송신 시스템**
	- 운영 데이터베이스, 애플리케이션으로부터 데이터 추출 및 생성
	- 인터페이스 테이블(I/F Table; Interface Table) 또는 파일(xml, csv, text)로 변환하여 송신
- **수신 시스템**	
	- 수신한 인터페이스 테이블 또는 파일(File)를 데이터로 변환하여 운영 데이터베이스에 적재
- **중계 서버**
	- 송수신 시스템 사이에 데이터 송수신과 송수신 현황 모니터링 역할
	- 성능과 보안의 품질 특성 중 보안이 더 중요하거나 송수신 시스템이 위치한 네트워크가 상이한 경우 주로 활용


## 소프트웨어 개발
### 애플리케이션 테스트
- 애플리케이션에 잠재되어 있는 결함을 찾아내는 일련의 행위 또는 절차
- **확인(Validation)**: 개발된 소프트웨어가 고객의 요구사항을 만족시키는지 
- **검증(Verification)**: 소프트웨어가 기능을 정확히 수행하는지 

#### 애플리케이션 테스트의 기본 원리
- 테스팅은 결함이 존재함을 밝히는 것: 결함을 줄일 순 있지만, 결함이 없다고는 증명할 수 없음
- 완벽한 테스팅은 불가능: 무한 경로, 무한 입력 값으로 인한 어려움
- 개발 초기에 테스팅 시작: 테스팅 기간 단축, 재작업 감소로 개발 기간 단축 및 결함 예방
- 결함 집중: 20%의 모듈에서 80%의 결함 발견, **파레토(Pareto) 법칙**
- 살충제 패러독스: 동일한 테스트 케이스에 의한 반복적 테스트는 새로운 버그를 찾지 못함
- 테스팅은 정황에 의존적: 소프트웨어 성격에 맞게 테스트 실시
- 오류-부재의 궤변: 요구사항을 충족시켜주지 못한다면, 결함이 없다고 해도 품질이 높다 볼 수 없음

### 개발 단계에 따른 애플리케이션 테스트
#### 단위 테스트(Unit Test)
- 코딩 직후 **최소 단위인 모듈이나 컴포넌트에 초점**을 맞춰 테스트 하는 것
- 사용자의 요구사항을 기반으로 한 기능성 테스트를 최우선으로 수행
- 명세 기반 테스트, 구조 기반 테스트 중 주로 구조 기반 테스트를 시행함

#### 통합 테스트(Integration Test)
- 단위 테스트가 완료된 모듈들을 결합하여 **하나의 시스템으로 완성시키는 과정**에서의 테스트를 의미
- 모듈 간 또는 통합된 컴포넌트 간의 상호 작용 오류 검사
- 빅뱅 테스트, 상향식 테스트(ex. Cluster, Driver), 하향식 테스트(ex. Stub)

### 시스템 테스트(System Test)
- **개발된 소프트웨어가 컴퓨터 시스템에서 완벽하게 수행**되는가를 점검하는 테스트
- 실제 사용 환경과 유사하게 만든 테스트 환경에서 테스트 수행해야 함
- 기능적 요구사항(블랙박스 테스트), 비기능적 요구사항(화이트박스 테스트)

### 인수 테스트(Acceptance Test)
- 개발한 소프트웨어가 사용자의 요구사항을 충족하는지에 중점을 두는 테스트
- **알파 테스트**: 통제된 환경에서 사용자가 개발자와 함께 확인하면서 행하는 테스트 기법
- **베타 테스트**: 통제되지 않은 환경에서 여러 명의 사용자가 행하는 테스트 기법 (게임 베타 테스터)

### 애플리케이션 테스트의 분류
#### 프로그램 실행 여부에 따른 테스트
- **정적 테스트**:
	- **프로그램을 실행하지 않고** 명세서나 소스 코드를 대상으로 분석하는 테스트
	- 워크 스루, 인스펙션, 코드 검사
- **동적 테스트**: 
	- **프로그램을 실행하여** 오류를 찾는 테스트
	- 화이트박스 테스트, 블랙박스 테스트

#### 테스트 기반에 따른 테스트
- **명세 기반 테스트**:
	- 사용자의 요구사항에 대한 명세를 빠짐없이 테스트 케이스로 만들어 구현하고 있는지 확인하는 테스트
	- 동등 분할, 경계값 분석(블랙박스 테스트)
- **구조 기반 테스트**:
	- 소프트웨어 내부의 논리 흐름에 따라 테스트 케이스를 작성하고 확인하는 테스트
	- 구문 기반, 결정 기반, 조건 기반(화이트박스 테스트)
- **경험 기반 테스트**:
	- 테스터의 경험을 기반으로 수행하는 테스트
	- 에러 추정, 체크 리스트, 탐색적 테스팅

#### 시각에 따른 테스트
- **검증(Verification) 테스트**:
	- 개발자의 시각에서 제품의 생산 과정을 테스트하는 것
	- 단위 테스트, 통합 테스트, 시스템 테스트
- **확인(Validation) 테스트**:
	- 사용자의 시각에서 생산된 제품의 결과를 테스트하는 것
	- 인수 테스트(알파 테스트, 베타 테스트)

#### 목적에 따른 테스트
- **회복(Recovery) 테스트**: 시스템에 여러가지 결함을 주어 실패하도록 한 후 올바르게 복구되는지를 확인하는 테스트
- **안전(Security) 테스트**: 시스템 보호 도구가 불법적인 침입으로부터 시스템을 보호할 수 있는지를 확인하는 테스트
- **강도(Stress) 테스트**: 과부하 시에도 소프트웨어가 정상적으로 실행되는지 확인하는 테스트
- **성능(Performance) 테스트**: 실시간 성능이나 전체적인 효율성을 진단하는 테스트
- **구조(Structure) 테스트**: 소프트웨어 내부의 논리적인 경로, 소스 코드의 복잡도 등을 평가하는 테스트
- **회귀(Regression) 테스트**: 소프트웨어의 변경 또는 수정된 코드에 새로운 결함이 없음을 확인하는 테스트
- **병행(Parallel) 테스트**: 변경된 소프트웨어와 기존 소프트웨어에 동일한 데이터를 입력하여 결과를 비교하는 테스트

#### 테스트 커버리지 유형
- **구문 커버리지**: 프로그램 내 모든 문장을 적어도 한 번 이상 실행하는 것을 기준으로 수행하는 테스트 커버리지
- **결정 커버리지**: 결정 조건 내 전체 조건식이 최소한 참/거짓 한 번의 값을 가지도록 측정하는 테스트 커버리지
- **조건 커버리지**: 전체 조건식 결과와 관계없이 관계없이 각 개별 조건식이 참/거짓 한 번 모두 갖도록 개별 조건식을 조합하는 테스트 커버리지
- **조건/결정 커버리지**: 전체 조건식이 참/거짓 한 번씩 가지면서, 개별 조건식이 참/거짓 모두 한 번씩 갖도록 조합하는 테스트 커버리지
- **변경/조건 결정 커버리지**: 각 개별 조건식이 다른 개별 조건식의 영향을 받지 않고 전체 조건식의 결과에 독립적으로 영향을 주도록 함으로써 조건/결정 커버리지를 향상시킨 테스트 커버리지
- **다중 조건 커버리지**: 결정 조건 내 모든 개발 조건식의 모든 가능한 조합을 100% 보장하는 테스트 커버리지

### 화이트박스 테스트, 블랙박스 테스트
#### 화이트박스 테스트(White Box Test)
- **모듈 안의 내용(작동)을 직접 볼 수 있음 = 내부 코드 확인 가능**
- 내부의 논리적인  모든 경로를 테스트해 테스트 케이스를 설계
- 소스 코드(Source Code)의 모든 문장을 한번 이상 수행함으로써 진행됨
- 선택, 반복 등의 부분들을 수행함으로써 논리적 경로 점검
- 논리흐름도, 루프구조, 순환복잡도 검사 가능

#### 화이트박스 테스트 종류
- **기초 경로 검사(Base Path Testing)**
	- 대표적인 화이트박스 테스트 기법
	- 수행 가능한 모든 경로 검사
	- 테스트 측정 결과는 실행 경로의 기초를 정의하는 지침으로 사용
- **제어 구조 검사**
	- **조건 검사(Condition Testing)**: 논리적 조건을 테스트하는 기법
	- **루프 검사(Loop Testing)**: 반복(Loop) 구조에 맞춰 테스트하는 기법
	- **데이터 흐름 검사(Data Flow Testing)**: 프로그램에서 변수의 정의와 변수 사용의 위치에 초점을 맞춰 테스트하는 기법

#### 블랙박스(Black Box Test) 
- **모듈 안에서 어떤 일(작동)이 일어나는지 알 수 없음 = 내부 코드 확인 불가**
- 소프트웨어가 수행할 특정 기능을 알기 위해 각 기능이 완전히 작동되는 것을 입증하는 테스트로 기능 테스트라고도 함
- 소프트웨어 인터페이스에서 실시되는 테스트

#### 블랙박스 테스트 종류
- **동치 분할 검사(Equivalence Partitioning Testing)**: 프로그램의 입력 조건에 타당한 입력 자료와 타당하지 않은 입력 자료의 개수를 균등하게 해 테스트 케이스를 정하고, 해당 입력 자료에 맞는 결과가 출력되는지 확인하는 기법(동등 분할 기법)
- **경계값 분석(Boundary Value Analysis)**: 입력 조건의 중간값보다 경계값에서 오류가 발생될 확률이 높다는 점을 이용해 입력 조건의 경계값을 테스트 케이스로 선정해 검사하는 기법
- **원인-효과 그래프 검사(Cause-Effect Graphing Testing)**: 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음 효용성이 높은 테스트 케이스를 선정해 검사하는 기법
- **비교 검사(Comparison Testing)**: 여러 버전의 프로그램에 동일한 테스트 자료를 제공해 동일한 결과가 출력되는지 테스트하는 기법
- **오류 예측 검사(Error Guessing)**: 다른 블랙박스 테스트 기법으로 찾아낼 수 없는 오류를 찾아내는 일력의 보충적 검사 기법(데이터 확인 검사)

### 통합 테스트 
#### 상향식 통합 테스트(Bottom Up Integration Test)
- 프로그램의 **하위 모듈에서 상위 모듈 방향으로 통합**하면서 테스트하는 기법
- 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹인 **클러스터(Cluster)**  필요
- 하위 모듈들을 클러스터(Cluster)로 결합 → 더미 모듈인 **드라이버(Driver)** 작성 → 통합된 클러스터 단위로 테스트 → 테스트 완료 후 클러스터는 프로그램 구조의 상위로 이동해 결합하고 드라이버는 실제 모듈로 대체됨

#### 하향식 통합 테스트(Top Down Integration Test)
- 프로그램의 **상위 모듈에서 하위 모듈 방향으로 통합**하면서 테스트하는 기법
- 깊이 우선 통합법, 넓이 우선 통합법 사용
- 테스트 초기부터 사용자에게 시스템 구조를 보여줄 수 있음
- 상위 모듈에서는 테스트 케이스 사용하기 어려움
- 주요 제어 모듈은 작성된 프로그램을 사용, 주요 제어 모듈의 종속 모듈은 **스텁(Stub)** 으로 대체 → 깊이 우선 또는 넓이 우선 등의 통합 방식에 따라 하위 모듈인 스텁(Stub)들이 한 번에 하나씩 실제 모듈로 교체됨 → 모듈이 통합될 때마다 테스트 실시 → 새로운 오류가 발생하지 않음을 보증하기 위해 회귀 테스트 실시

#### 혼합식 통합 테스트
- 하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합을 사용해 최적의 테스트를 지원하는 방식
- **샌드위치(Sandwich)** 통합 테스트 방법

### 테스트 방법
#### 테스트 케이스(Test Case)
- 구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 입력 값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서
- 명세 기반 테스트(블랙박스 테스트)의 설계 산출물에 해당
- 미리 설계해두면 테스트 오류 방지 및 테스트 수행 자원의 낭비를 줄일 수 있음
-  테스트 케이스 자동 생성 도구를 이용하여 테스트 데이터를 찾아내는 방법: 입력 도메인 분석, 랜덤(Random) 테스트, 자료 흐름도

#### 테스트 시나리오(Test Scenario)
- 테스트 케이스를 적용하는 순서에 따라 여러 개의 테스트 케이스들을 묶은 집합
- 테스트 케이스들을 적용하는 구체적인 절차를 명세한 문서
-시스템별, 모듈별, 항목별 등과 같이 여러 개의 시나리오로 분리해 작성
-사용자의 요구사항과 설계 문서 등을 토대로 작성

#### 테스트 오라클(Test Oracle)
- 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값을 대입해 비교하는 활동
- 제한된 검증: 모든 테스트 케이스에 적용할 수 없음
- 수학적 기법: 값을 수학적 기법을 이용해 구할 수 있음
- 자동화 기능: 프로그램 실행, 결과 비교, 커버리지 측정 등을 자동화할 수 있음
- 참(True) 오라클: 모든 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하는 오라클, 발생된 모든 오류를 검출할 수 있음
- 샘플링(Sampling) 오라클: 특정한 몇몇 테스트 케이스의 입력 값들에 대해서만 기대하는 결과를 제공하는 오라클
- 휴리스틱(Heuristic, 추정) 오라클: 샘플링 오라클을 개선한 오라클, 특정 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하고 나머지 입력 값들에 대해서는 추정으로 처리하는 오라클
- 일관성(Consistent) 검사 오라클: 변경이 있을 때 테스트 케이스의 수행 전과 후의 결과 값이 동일한지를 확인하는 오라클

#### 테스트 하네스(Test Harness)
- **테스트 드라이버(Test Driver)**: 테스트 대상의 하위 모듈을 호출하고 모듈 테스트 수행 후의 결과를 도출하는 상향식(Bottom Up) 간이 소프트웨어 도구. 
- **테스트 스텁(Test Stub)**: 테스트 대상의 상위 모듈을 대신하는, 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 하향식(Top Down) 도구.
- **테스트 슈트(Test Suites)**: 테스트 대상 컴포넌트나 모듈 등 시스템에 사용되는 테스트 케이스의 집합
- **테스트 케이스(Test Case)**: 사용자의 요구사항을 정확하게 준수했는지 확인하기 위한 입력 값, 실행 조건, 기대 결과 등으로 만들어진 테스트 항목 명세서
- **테스트 스크립트(Test Script)**: 자동화된 테스트 실행 절차에 대한 명세서
- **목 오브젝트(Mock Object)**: 사전에 사용자의 행위를 조건부로 입력해 두면, 그 상황에 맞는 예정된 행위를 수행하는 객체

### 빌드 자동화 도구
소스 코드를 소프트웨어로 변환하는 과정에 필요한 전처리(Preprocessing), 컴파일(Complie) 등의 작업들을 수행하는 소프트웨어

 **Ant(Another Neat Tool)**
- 아파치 소프트웨어 재단에서 개발한 소프트웨어
- 자바 프로젝트의 공식적인 빌드 자동화 도구
- XML 기반의 빌드 스크립트를 사용
- 정해진 규칙이나 표준이 없어 개발자가 모든 것을 정의
- 스크립트의 재사용이 어려움

 **Maven**
- 아파치 소프트웨어 재단에서 Ant의 대안으로 개발
- 규칙이나 표준이 존재해 예외 사항만 기록됨
- 컴파일과 빌드를 동시에 수행할 수 있음
- 의존성(Dependency)을 설정하여 라이브러리를 관리

 **Gradle**
- 기존의 Ant와 Maven을 보완해 개발된 빌드 자동화 도구
- 안드로이드 스튜디오(안드로이드 앱 개발)의 공식 빌드 도구
- Maven과 동일하게 의존성(Dependency) 활용
- 그루비(Groovy) 기반의 빌드 스크립트 사용
- 플러그인을 설정하면, JAVA, C/C++, Python 등의 언어도 빌드 가능
- 실행할 처리 명령들을 모아 태스크(Task)로 만든 후 태스크 단위로 실행
- 이전에 사용했던 태스크를 재사용하거나 다른 시스템의 태스크를 공유할 수 있는 빌드 캐시 기능 지원 → 빌드의 속도 향상

 **Jenkins**
- JAVA 기반의 오픈 소스 형태로 가장 많이 사용되는 빌드 자동화 도구
- 서블릿 컨테이너에서 실행되는 서버 기반 도구
- SVN, Git 등 대부분의 형상 관리 도구와 연동 가능
- 친숙한 Web GUI  제공
- 여러 대의 컴퓨터를 이용한 분산 빌드나 테스트 가능

### 소프트웨어 패키징
- **패키지**: 모듈별로 생성한 실행 파일들을 묶은 배포용 설치 파일
- 개발자가 아닌 사용자를 중심으로 진행
- 다양한 사용자의 요구사항 반영
- 운영체제(OS), CPU, 메모리 등에 필요한 최소 환경을 정의
- 하드웨어와 함께 관리될 수 있도록 Managed Service형태로 제공
- 기능 식별 → 모듈화 → 빌드 진행 → 사용자 환경 분석 → 패키징 및 적용 시험 → 패키징 변경 개선 → 배포

#### 패키징 고려사항
- 패키징 시 사용자에게 배포되는 SW이므로 보안 고려
- 사용자 편의성을 위한 복잡성 및 비효율성 문제 고려
- 제품 SW종류에 적합한 암호화 알고리즘 적용
- 다양한 이기종 연동 고려

### 릴리즈 노트(Release Note)
- **릴리즈 노트(Release Note)**: 개발 과정에서 정리된 릴리즈 정보를 소프트웨어의 고객과 공유하기 위한 문서
- 개선된 작업이 있을 때마다 관련 내용을 릴리즈 노트에 담아 제공
- 개발팀에서 제공하는 소프트웨어 사양에 대한 최종 승인을 얻은 후 문서화되어 제공
- 릴리즈 노트 작성 순서: 모듈 식별 → 릴리즈 정보 확인 → 릴리즈 노트 개요 작성 → 영향도 체크 → 정식 릴리즈 노트 작성 → 추가 개선 항목 식별

#### 추가 버전 작성 시 고려사항
- 베타 버전이 출시되거나 긴급한 버그 수정, 업그레이드와 같은 자체 기능 향상, 사용자 요청 등의 특수한 상황이 발생하는 경우 추가로 작성
- 버그 번호를 포함한 모든 수정된 내용을 담아 릴리즈 노트 작성
- 추가나 수정된 경우 자체 기능 향상과는 다른 별도의 릴리즈 버전 출시하고 릴리즈 노트 작성

### 디지털 저작권 관리(DRM; Digital Right Management)
디지털 콘텐츠의 전 과정에 걸쳐 사용되는 디지털 콘텐츠 관리 및 보호 기술

#### 저작권 관리 구성 요소
- **콘텐츠 제공자(Contents Provider)**: 콘텐츠를 제공하는 저작권자
- **콘텐츠 분배자(Contents Distributor)**: 암호화된 콘텐츠를 유통하는 곳이나 사람
- **콘텐츠 소비자(Customer)**: 콘텐츠를 구매해서 사용하는 주체
- **패키저(Packager)**: 콘텐츠를 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램
- **클리어링 하우스(Clearing House)**: 키 관리, 저작권에 대한 사용 권한, 라이선스 발급, 사용량에 따른 결제관리 등을 수행하는 곳
- **DRM 컨트롤러(DRM Controller)**: 배포된 콘텐츠의 이용 권한을 통제하는 프로그램
- **보안 컨테이너(Security Container)**: 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치

#### 디지털 저작권 관리(DRM)의 기술 요소
- **암호화(Encryption)**: 콘텐츠 및 라이선스를 암호화하고 전자서명을 할 수 있는 기술
- **키 관리(Key Management)**: 콘텐츠를 암호화한 키에 대한 저장 및 분배 기술
- **식별 기술(Identification)**: 콘텐츠에 대한 식별 체계 표현 기술
- **저작권 표현(Right Expression)**: 라이선스의 내용 표현 기술
- **암호화 파일 생성(Packager)**: 콘텐츠를 암호화된 콘텐츠로 생성하기 위한 기술
- **정책 관리(Policy Management)**: 라이선스 발급 및 사용에 대한 정책 표현 및 관리 기술
- **크랙 방지(Tamper Resistance)**: 크랙에 의한 콘텐츠 사용 방지 기술
- **인증(Authentication)**: 라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술

### 형상 관리(Configuration Management)
#### 소프트웨어 패키징의 형상 관리(SCM; Software Configuration Management)
- 형상 관리는 소프트웨어의 개발 과정에서 **소프트웨어의 변경 사항을 관리**하기 위해 개발된 일련의 활동임
- 소프트웨어 개발의 전 단계에 적용되는 활동이며, 유지보수 단계에서도 수행
- 소프트웨어의 변경 사항을 체계적으로 추적하고 통제할 수 있음
- 제품 소프트웨어에 대한 무절제한 변경 방지
- 진행 정도를 확인하기 위한 기준으로 사용될 수 있음
- 형상 관리를 통해 이전 리비전이나 버전에 대한 정보에 접근 가능하여 배포본 관리에 유용
- 프로젝트 계획, 분석서, 설계서, 프로그램, 테스트 케이스 모두 관리 대상
- 불필요한 사용자의 소스 수정 제한
- 동일한 프로젝트에 대해 여러 개발자 동시 개발 가능
- 개발비용하고 상관이 없음

#### 형상 관리 기능
- **형상 식별**: 형상 관리 대상에 이름과 관리 번호를 부여하고, 계층(Tree) 구조로 구분하여 수정 및 추적이 용이하도록 하는 작업
- **형상 통제(변경 관리)**: 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선(베이스 라인, Base line)이 잘 반영될 수 있도록 조정하는 작업
- **형상 감사**: 기준선(베이스 라인)의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인하는 작업
- **형상 기록(상태 보고)**: 형상의 식별, 통제, 감사 작업의 결과를 기록, 관리하고 보고서를 작성하는 작업
- **버전 제어**: 소프트웨어 업그레이드나 유지 보수 과정에서 생성된 다른 버전의 형상 항목을 관리하고, 이를 위해 특정 절차와 도구(Tool)를 결합시키는 작업

#### 모듈화
- **정보 은닉(Information Hiding)**: 어렵거나 변경 가능성이 있는 모듈을 타 모듈로부터 은폐
- **분할과 정복(Divide & Conquer)**: 복잡한 문제를 분해, 모듈 단위로 문제 해결
- **데이터 추상화(Data Abstraction)**: 각 모듈 자료 구조를 액세스하고 수정하는 함수내에 자료 구조의 표현 내역을 은폐
- **모듈 독립성(Module Inpendency)**: 낮은 결합도와 높은 응집도

### 소프트웨어 버전 등록
- **저장소(Repository)**: 최신 버전의 파일들과 변경 내역에 대한 정보들이 저장되어 있는 곳
- **가져오기(Import)**: 버전 관리가 되고 있지 않은 아무것도 없는 저장소(Repository)에 처음으로 파일을 복사하는 것
- **체크아웃(Check-Out)**: 프로그램을 수정하기 위해 저장소(Repository)에서 파일을 받아오는 것
- **체크인(Check-In)**: 체크아웃 한 파일의 수정을 완료한 후, 저장소(Repository)의 파일을 새로운 버전으로 갱신하는 것
- **커밋(Commit)**: 체크인을 수행할 때 이전에 갱신된 내용이 있는 경우에는 충돌(Confilct)을 알리고 diff도구를 이용해 수정한 후, 갱신을 완료함
- **동기화(Update)**: 저장소에 있는 최신 버전으로 자신의 작업 공간(로컬/지역 저장소)을 동기화하는 것
- Import → Check-Out → Commit → Update → Diff

### 버전 관리 도구
#### 공유 폴더 방식
- 버전 관리 자료가 로컬 컴퓨터의 공유 폴더에 저장되어 관리되는 방식
- 개발자들은 개발이 완료된 파일을 약속된 공유 폴더에 매일 복사함
- 담당자는 공유 폴더의 파일을 자기 PC로 복사해 컴파일 한 후 이상 유무 확인
- 파일의 변경 사항을 데이터베이스에 기록하며 관리
- SCCS, RCS, PVCS, QVCS

#### 클라이언트/서버 방식
- 버전 관리 자료가 중앙 시스템(서버)에 저장되어 관리되는 방식
- 서버의 자료를 개발자별로 자신의 PC(클라이언트)로 복사해 작업한 후 변경된 내용을 중앙 서버에 반영
- 모든 버전 관리는 서버에서 수행됨
- 하나의 파일을 서로 다른 개발자가 작업할 경우 경고 메시지 출력
- 서버에 문제가 생기면 다른 개발자와의 협업 및 버전 관리 작업은 중단됨
- CVS, SVN(Subversion)

#### 분산 저장소 방식
- 하나의 원격 저장소와 분산된 개발자 PC의 로컬 저장소에 함께 저장되어 관리되는 방식
- 개발자별로 원격 저장소의 자료를 자신의 로컬 저장소로 복사해 작업한 후 변경 된 내용을 로컬 저장소에서 우선 반영(Commit)한 다음 이를 원격 저장소에 반영(Push)
- 원격 저장소에 문제가 생겨도 로컬 저장소의 자료를 이용해 작업 가능
- 로컬 저장소에서 작업을 수행할 수 있어 처리속도가 빠름
- Git, Bitkeeper

#### SVN(Subversion)
- CVS를 개선한 것으로 아파치 소프트웨어 재단에서 2000년 발표함
- 모든 개발 작업은 trunk 디렉터리에서 수행되며, 추가 작업은 branches 디렉터리 안에 별도의 디렉터리를 만들어 작업을 완료한 후 trunk 디렉터리와 병합(merge)
- 커밋(Commit)할 때마다 리비전(Revision)이 1씩 증가
- 서버는 주로 유닉스(UNIX)  사용
- 오픈 소스로 무료사용 가능
- CVS의 단점이었던 파일이나 디렉터리의 이름 변경, 이동 등이 가능

#### Git
- 리누스 토발즈(Linus Torvalds)가 2005년 리눅스 커널 개발에 사용할 관리 도구로 개발한 이후 주니오 하마노(Junio Hamano)에 의해 유지 보수되고 있음
- 원격 저장소는 여러 사람들이 협업을 위해 버전을 공동 관리하는 곳으로, 자신의 버전 관리 내역을 반영(Push)하거나 다른 개발자의 변경 내용을 가져올 때(Fetch) 사용
- 로컬 저장소는 개발자들이 본인의 실제 개발을 진행하는 장소로 버전 관리가 수행됨
- 브랜치(Branch)를 이용하면 기본 버전 관리 틀에 영향을 주지 않으면서 다양한 형태의 기능 테스팅 가능
- 파일의 변화를 스냅샷(Snapshot)으로 저장
- 스냅샷은 이전 스냅샷의 포인터를 가지므로 버전의 흐름 파악 가능

### 제품 소프트웨어 매뉴얼(Manual)
- 제품 소프트웨어 개발 단계부터 적용한 기준이나 패키징 이후 설치 및 사용자 측면의 주요 내용 등을 문서로 기록한 것
- **사용자 중심**의 기능 및 방법을 나타낸 설명서와 안내서.

#### 제품 소프트웨어 설치 매뉴얼
- 사용자가 제품을 구매한 후 최초 설치시 참조하는 매뉴얼.
- 제품 소프트웨어 개요, 설치 관련 파일, 설치 절차, 설치 아이콘, 삭제 방법, 설치 버전 및 작성자, 고객 지원 방법 및 FAQ, 준수 정보, 제한 보증 포함.
- 목차 및 개요, 문서 이력 정보, 설치 매뉴얼 주석, 설치 도구의 구성, 설치 위치 지정으로 구성
- 설치를 위한 환경 체크 항목: 사용자 환경, 응용 프로그램, 업그레이드 버전, 백업 폴더 확인
- 작성 순서: 개요 및 기능 식별→UI 분류→설치 파일/ 백업 파일 확인→삭제 절차 확인→이상 유형 확인→최종 매뉴얼 적용

#### 제품 소프트웨어 사용자 매뉴얼
-   제개발이 완료된 제품 소프트웨어를 고객에게 전달하기 위한 형태로 패키징하고, 설치와 사용에 필요한 제반 절차 및 환경 등 전체 내용을 포함하는 문서
-  목차 및 개요, 문서 이력 정보, 사용자 매뉴얼 주석, 기록 항목, 기본 사항, 고객 지원 방법 및 FAQ, 준수 정보, 제한 보증 포함.
- 작성 순서: 작성 지침 정의→사용자 매뉴얼 구성요소 정의→구성요소별 내용 작성→사용자 매뉴얼 검토

### 애플리케이션 성능 분석
#### 애플리케이션 성능
- **처리량(Throughput)**: 일정 시간 내 애플리케이션이 처리하는 일의 양
- **응답 시간(Response Time)**: 애플레이케이션에 요청을 전달한 시간부터 응답이 도착할 때까지 걸린 시간
- **경과 시간(Turn Around Time)**: 애플리케이션에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간
- **자원 사용률(Resource Usage)**: 애플리케이션이 의뢰한 작업을 처리하는 동안의 CPU 사용량, 메모리 사용량, 네트워크 사용량 등 자원 사용률

#### 애플리케이션 성능 저하 원인 분석
- DB에 필요 이상의 많은 데이터를 요청한 경우
- 커넥션 풀(Connection Pool)의 크기를 너무 작거나 크게 설정한 경우
- JDBC나 ODBC 같은 미들웨어를 사용한 후 종료하지 않아 연결 누수가 발생한 경우
- 대량의 파일을 업로드하거나 다운로드해 처리 시간이 길어진 경우

#### 클린 코드(Clean Code) 작성 원칙
- 가독성
- 단순성
- 의존성 배제
- 중복성 최소화
- 추상화

#### 소스 코드 품질분석 도구의 종류
- 정적 분석 도구: pmd, cppcheck, checkstyle, SonarQube, ccm, cobertuna
- 동적 분석 도구: Avalanche, Valgrind

### 모듈 연계
#### EAI(Enterprise Application Integration)
기업 내 각종 애플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션
- **포인트 투 포인트(Point to Point)**: 점 대 점으로 연결하는 방식, 변경 및 재사용이 어려움
- **허브 앤 스포크(Hub & Spoke)**: 단일 접점인 허브(Hub) 시스템을 통해 데이터를 전송하는 중앙 집중형 방식, 확장 및 유지보수가 용이하지만 허브 장애 발생 시 시스템 전체에 영향을 미침
- **메시지 버스(Message Bus, ESB방식)**: 애플리케이션 사이에 미들웨어를 둬 처리하는 방식, 확장성이 뛰어나며 대용량 처리가 가능
- **하이브리드(Hybrid)**: Hub & Spoke(그룹 내)와 Message Bus(그룹 간)의 혼합 방식, 데이터 병목 현상을 최소화할 수 있음. 필요한 경우 한 가지 방식으로 EAI구현이 가능

#### ESB(Enterprise Service Bus)
- 애플리케이션 간 연계, 데이터 변환, 웹 서비스 지원 등 표준 기반의 인터페이스를 제공하는 솔루션
- 애플리케이션 통합 측면에서 EAI와 유사하지만 애플리케이션 보다는 서비스 중심의 통합을 지향
- 결합도(Coupling)를 약하게(Loosely)  유지함
- 관리 및 보안 유지가 쉽고, 높은 수준의 품질 지원이 가능

### 인터페이스 구현
- 애플리케이션 영역에서 인터페이스 형식에 맞춘 데이터 포맷을 인터페이스 대상으로 전송하고 이를 수신 측에서 파싱(Parsing)해 해석하는 방식
- 주로 JSON이나 XML형식의 데이터 포맷을 사용해 인터페이스를 구현
- **JSON(JavaScript Object Notation)**: 속성-값 쌍(Attribut-Value Pairs)으로 이뤄진 데이터 객체를 전달하기 위해 사람이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷
- **XML(eXtensible Markup Language)**: 특수한 목적을 갖는 마크업 언어를 만드는 데 사용되는 다목적 마크업 언어, 웹 페이지의 기본 형식인 HTML의 문법이 각 웹 브라우저에서 상호 호환적이지 못하다는 문제와 SGML(Stand Generalized Markup Language)의 복잡함을 해결하기 위해 개발됨

#### 인터페이스 엔티티를 이용한 인터페이스 구현
- 인터페이스가 필요한 시스템 사이에 별도의 인터페이스 엔티티로 상호 연계하는 방식
- 일반적으로 인터페이스 테이블을 엔티티로 활용
- 송, 수신 인터페이스 테이블의 구조는 상황에 따라 서로 다르게 설계할 수도 있음

### 인터페이스 보안 기능
- 네트워크(Network), 애플리케이션(Application), 데이터베이스(Database) 영역
- **스니핑(Sniffing)**: 네트워크의 중간에서 남의 패킷 정보를 도청하는 해킹 유형
- **시큐어 코딩(Secure Coding)**: 소프트웨어 개발 과정에서 지켜야 할 일련의 보안 활동
ex) 입력 데이터 검증 표현, 보안 기능, 시간 및 상태, 에러 처리, 코드 오류, 캡슐화, API 오용

#### 네트워크 영역 솔루션
- **IPSec**
	- 통신 세션의 각 IP패킷을 암호화하고 인증하는 안전한 인터넷 프로토콜(IP) 통신을 위한 인터넷 프로토콜 스위트
	- **SA(Security Association)**: IPSec을 사용하는 두 Peer간의 협약
	- **SP(Security Policy)**: 일종의 패킷 필터링 정책
	- **AH(Authentication Header)**: IP Extension Header로서 IP Packet에 대한 인증을 제공한다.
	- **ESP(Encapsulating Security Payload)**: 새로운 데이터 IP Packet을 만들고 기존 IP Packet을 Data Payload에 넣어 감싸는 방식. **대칭키(양방향) 암호화 사용**
	- **IKE(Internet key Exchange)**: IPSec에서 키 교환에 사용되는 프로토콜. UDP 500 포트를 사용한다
	- **전송 모드(Transport Mode)**: IP 패킷 전체를 보호하는 것이 아니라 IP 헤더를 제외한 IP 패킷의 페이로드(Payload)만을 보호
	- **터널 모드(Tunneling Mode)**: IP 패킷 전체를 보호. 암호화된 패킷에 IP 패킷에 IPSec 헤더를 추가하여 라우팅을 수행한다.
- **SSL(Secure Sockets Layer)**
	- 웹사이트와 브라우저 사이(또는 두 서버 사이)에 전송되는 데이터를 암호화하여 인터넷 연결을 보호하기 위한 표준 기술
	- **기본 포트는 22**
	- 키를 통한 인증은 클라이언트의 공개키를 서버에 등록해야 한다.
	- 서로 연결되어 있는 컴퓨터 간 원격 명령실행이나 셀 서비스 등을 수행한다.
- **S-HTTPS**: 웹상에서 네트워크 트래픽을 암호화하는 주요 방법

### 인터페이스 구현 검증 도구
- **xUnit**: Java(Junit), C++(Cppunit), .Net(Nunit) 등 다양한 언어를 지원하는 단위 테스트 프레임워크
- **STAF**: 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크 
- **FitNesse**: 웹 기반 테스트케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크
- **NTAF**: STAF의 장점인 재사용 및 확장성과 FitNesse의 장점인 협업 기능을 통합한 NHN(Naver)의 테스트 자동화 프레임워크
- **Selenium**: 다양한 브라우저 및 개발 언어를 지원하는 웹 애플리케이션 테스트 프레임워크
- **watir**: Ruby 언어를 사용하는 애플리케이션 테스트 프레임워크

### 정형 기술 검토
S/W 개발 산출물 대상 요구사항 일치여부, 표준 준수 및 결함 발생여부를 검토하는 정적 분석기법

#### 목적
-   산출물 요구사항 일치여부
-   시큐어코딩 등 규칙 준수
-   결함발생 여부 검토
-   결함 해결방안 도출

#### 원칙
-   검토될 제품에 대한 체크 리스트를 개발
-   자원과 시간 일정을 할당
-   문제 영역을 명확히 표현하고 의제를 제한
-   제품의 검토에만 집중
-   검토의 과정과 결과를 재검토
-   논쟁과 반박을 제한
-   참가자의 수를 제한
-   사전 준비를 강요하고 사전에 작성한 메모들을 공유
-   모든 검토자들을 위해 의미있는 훈련을 진행
-   해결책이나 개선책에 대해서 논하지 않음

### 시스템의 구성 요소
- 입력(Input)
- 출력(Output)
- 처리(Process): 입력된 자료를 변환, 가공
- 제어(Control): 시스템의 기본 요소들이 각 과정을 올바르게 행하는지 감독
- 피드백(Feedback): 처리된 결과를 측정하고 목표에 도달되었는가를 검사하여, 불충분시 다시 입력함

### 정렬 알고리즘

**37, 14, 17, 40 ,35**

 **선택 정렬**
1.  주어진 리스트 중에 최소값을 찾는다.
2.  그 값을 맨 앞에 위치한 값과 교체한다(패스(pass)).
3.  맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다.
=> PASS 1회당 정렬 안된 가장 작은 수가 앞쪽으로

- **PASS 1**  **37, 14**, 17, 40, 35 → **14, 37**, 17, 40, 35

1번째 37를 제외한 14, 17, 40, 35 중 가장 작은 수(14)와 37을 선택해서 바꿈

- **PASS 2**  14, **37, 17**, 40, 35 → 14, **17, 37**, 40, 35

1, 2번째 14, 37를 제외한 17, 40, 35 중 가장 작은 수(17)와 37을 선택해서 바꿈

- **PASS 3**  14, 17, **37**, 40, **35** → 14, 17, **35**, 40, **37** (정답)

1, 2, 3번째 14, 17, 37를 제외한 40, 35 중 가장 작은 수(35)와 37을 선택해서 바꿈

 **버블 정렬**
- 두 인접한 원소를 검사하여 정렬하는 방법
=> PASS 1회당 정렬 안된 가장 큰 수가 뒤쪽으로

- **PASS 1**  **37, 14**, 17, 40, 35 → **14, 37**, 17, 40, 35

1번째 37와 2번째 14를 비교해서 1번째(37) > 2번째(14)가 참이라면 바꿈

 14, **37, 17**, 40, 35 → 14, **17, 37**, 40, 35 (정답)

2번째 37와 3번째 17를 비교해서 2번째(37) > 3번째(17)가 참이라면 바꿈

3번째 37와 4번째 40을 비교해서 3번째(37) > 4번째(40)가 거짓이므로 종료(끝)

 **삽입 정렬**
- 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입
=> PASS 1회당 현재 수가 자신의 위치를 찾아감

- **PASS 1**  37, **14**, 17, 40, 35 → **14**, 37, 17, 40, 35

2번째 14를 앞의 1번째 37과 비교해서 수가 더 작다면 바꿔 삽입함

- **PASS 2**  14, 37, **17**, 40, 35 → 14, **17**, 37, 40, 35

3번째 17을 앞의 2번째 37, 1번째 14와 비교해서 수가 더 작다면 바꿔 삽입함

- **PASS 3**  14, 17, 37, **40**, 35

4번째 40을 앞의 3번째 37, 2번째 17, 1번째 14 비교해서 수가 더 작다면 바꿔 삽입함

- **PASS 4**  14, 17, 37, 40, **35** → 14, 17, **35**, 37, 40 (정답)

5번째 35를 앞의 4번째 40, 3번째 37, 2번째 17, 1번째 14와 비교해서 수가 더 작다면 바꿔 삽입함

- **퀵 정렬**: 피벗(pivot)으로 리스트를 불균등하게 분할 정복하는 방법.

### 트리
 **차수(Degree)**: 노드의 차수는 해당 노드의 child 개수, 트리의 차수는 child 개수의 최댓값
 **단말 노드(Terminal Node) = Leaf Node**: child 개수가 0인 노드

#### 트리 순회
- **전위 순회(PreOrder Traversal)**: Root → Left → Right
- **중위 순회(InOrder Traversal)**: Left → Root → Right
- **후위 순회(PostOrder Traversal)**: Left → Right → Root

### Stack Overflow & Underflow
- Overflow: 스택 공간이 가득 찼는데 데이터를 추가하려고 할 때 발생
- Underflow: 스택 공간에 데이터가 없는데 데이터를 꺼내려고 할 때 발생

### 전위식(prefix) & 후위식(postfix)
**(A + B)**
- **전위식(prefix)**: 괄호 기준 연산자가 왼쪽 => **+ A B**
- **후위식(postfix)**: 괄호 기준 연산자가 왼쪽 => **A B +**

### 순환 복잡도(Mccabe Cyclomatic Complexity)
**V(G) = E(Edge) - N(Node) + 2**

## 데이터베이스 구축
### 데이터베이스 
- **릴레이션(Relation) = 테이블(Table)**
- **열(Column) = 속성(Attribute) = 필드(Field)**
- **행(Row) = 튜플(Tuple) = 레코드(Record)**
- **속성의 수 = 디그리(Degree), 차수**
- **튜플의 수 = 카디널리티(Cardinality)**
- **도메인(Domain)** = 하나의 속성(Attribute, 애트리뷰트)이 가질 수 있는 같은 타입 원자(Atomic)값들의 집합

### SQL(Structured Query Language)
#### DDL(Data Define Language, 데이터 정의어)
- DOMAIN(도메인), SCHEMA(스키마), TABLE(테이블), VIEW(뷰), INDEX(인덱스)를 정의하거나 변경 또는 삭제할 때 사용하는 언어
- CREATE, ALTER, DROP

#### DML(Data Manipulation Language, 데이터 조작어)
- 데이터베이스 사용자가 응용 프로그램이나 질의어를 통해 저장된 데이터를 실질적으로 처리하는 데 사용하는 언어
- SELECT, INSERT, DELETE, UPDATE

#### DCL(Data Control Language, 데이터 제어어)
- 데이터의 무결성, 보안, 회복, 병행수행 제어 등을 정의하는 데 사용되는 언어
- 데이터베이스 관리자(DBA)가 데이터 관리를 목적으로 사용
- COMMIT, ROLLBACK, GRANT, REVOKE

### WHERE 조건
- **BETWEEN**
가격(PRICE)이 50000 보다 크거나 같고 80000 보다 작거나 같음
→ PRICE **BETWEEN** 50000 **AND** 80000
= **PRICE >= 50000 AND PRICE <= 80000**
- **LIKE**
이름(NAME)이 ‘정보’로 시작되는 문자열
→ NAME LIKE ‘정보%’
이름(NAME)이 ‘정보’로 끝나는 문자열
→ NAME LIKE ‘%정보’

### 관계대수
- 관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게(How) 유도하는가를 기술하는 절차적인 언어
- 질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시한다.

#### 순수관계 연산자
- **Select(선택) = σ**: 조건(Predicate)을 만족하는 튜플들의 부분 집합(수평 연산)
- **Project(추출) = π**: 속성들의 부분 집합, 중복은 제거됨(수직 연산)
- **Join(조인) = ▷◁**: 두 개의 릴레이션이 공통으로 가지고 있는 속성을 이용하여 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산 = 두 개의 릴레이션의 연관된 튜플들을 결합
- **Division(나누기) = ÷**: R릴레이션에서 S릴레이션의 속성 도메인 값과 일치하는 R릴레이션의 튜플들을 찾아내는 연산
	- R ÷ S = R에서 S의 모든 tuple에 속하는 tuple들을 가져오고, S의 컬럼을 제외한다

#### 일반집합 연산자
- **Union(합집합) = ∪**: 두 개의 릴레이션의 합이 추출되고, 중복은 제거됨
- **Intersection(교집합) = ∩**: R릴레이션과 S릴레이션의 중복되는 값들만 추출
- **Difference(차집합) = —**: R릴레이션에서 S릴레이션에 중복되지 않는 값들만 추출
- **Cartesian Product(교차곱) = Х**: 두 릴레이션의 가능한 모든 튜플들의 집합. 차수(Degree)는 더하고, 카디널리티(Cardinality)는 곱해서 값을 구함

### 관계해석(Relational Calculus)
- 원하는 정보가 무엇(What)이라는 것만 정의하는 비절차적 특성
- 튜플 관계해석, 도메인 관계해석
- 기본적으로 관계해석과 관계대수는 관계 데이터베이스를 처리하는 기능과 능력면에서 동등
- 관계대수로 표현한 식은 관계해석으로 표현할 수 있음
- **OR 연산 = V**: 원자식 간 “또는”이라는 관계로 연결
- **AND 연산 = ∧**: 원자식 간 “그리고”라는 관계로 연결
- **NOT 연산 = ㄱ**: 원자식에 대해 부정
- **전칭 정량자(Universal Quantifier) = ∀**: 모든 가능한 튜플 “For All”
- **존재 정량자(Existential Quantifier) = ∃**: 어떤 튜플 하나라도 존재 “There Exists”

### 키(Key)
데이터베이스에서 튜플들을 서로 구분할 수 있는 기준이 되는 속성(Attribute)

#### 후보키(Candidate Key) 
- 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합, 즉 기본키로 사용할 수 있는 속성들, 모든 릴레이션에는 반드시 하나 이상의 후보키가 존재
- 릴레이션에 있는 모든 튜플에 대해 **유일성**과 **최소성**을 만족시켜야 함
 **유일성**(Unique): 하나의 키 값으로 하나의 튜플만을 유일하게 식별할 수 있어야 함
 **최소성**(Minimality): 모든 레코드들을 유일하게 식별하는 데 꼭 필요한 속성으로만 구성되어야 함

#### 기본키(Primary Key)
- 후보키 중에서 특별히 선정된 주키(Main Key)로, 중복된 값과 NULL값을 가질 수 없음
- 후보키의 성질인 유일성과 최소성을 가지며 튜플을 식별하기 위해 반드시 필요한 키

#### 대체키(Alternate Key)
- 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키를 의미

#### 슈퍼키(Super Key)
- 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키
- 모든 튜플에 대해 유일성은 만족시키지만, 최소성은 만족시키지 못함

#### 외래키(Foreign Key)
- 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합
- 참조되는 릴레이션의 기본키와 대응돼 릴레이션 간의 참조 관계를 표현

### 트랜잭션의 특성 (ACID)
- **원자성(Atomicity)**: 트랜잭션 연산을 데이터베이스 모두에 반영되든지 아니면 전혀 반영되지 않아야 함(All or Nothing)
- **일관성(Consistency)**: 트랜잭션이 실행을 성공적으로 완료할 시 일관성 있는 데이터베이스 상태를 유지
- **독립성(Isolation, 격리성)**: 둘 이상 트랜잭션 동시 실행 시 한 개의 트랜잭션만 접근이 가능하여 간섭 불가
- **영속성(Durability)**: 성공적으로 완료된 트랜잭션 결과는 영구적으로 반영됨

### CRUD
#### CRUD 분석
- CRUD: 생성(Create), 읽기(Read), 갱신(Update), 삭제(Delete)
- CRUD 분석은 데이터베이스 테이블에 변화를 주는 트랜잭션의 CRUD 연산에 대해 CRUD 매트릭스를 작성하여 분석하는 것

#### CRUD 매트릭스
- 행에는 프로세스를, 열에는 테이블을, 행과 열이 만나는 위치에는 프로세스가 테이블에 발생시키는 변화를 표시하는 상관 분석표 
- Create, Read, Update, Delete, ‘C > D > U > R’의 우선순위 적용
- 테이블, 프로세스에 C, R, U, D가 모두 없는 경우
- 테이블에 C 또는 R이 없는 경우 (프로세스는 하나만 있어도 돌아감)

### 무결성(Integrity)
데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제 값이 일치하는 정확성을 의미
- **개체 무결성(Entity Integrity, 실체 무결성)**
	- 테이블의 기본키를 구성하는 어떤 속성(Attribute)도 널(NULL)값이나 중복 값을 가질 수 없음
	- 기본키의 속성 값이 널(NULL)값이 아닌 원자 값을 갖는 성질
- **도메인 무결성(Domain Integrity, 영역 무결성)**
	- 릴레이션 내의 튜플들이 각 속성(Attribute)의 도메인에 지정된 값 만을 가져야 함
- **참조 무결성(Referential Integrity)**
	- 외래키 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일해야 함
	- 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정
- **사용자 정의 무결성(User-Defined Integrity)**
	- 속성 값들이 사용자가 정의한 제약 조건에 만족해야 함
- **데이터 무결성 강화**
	- 애플리케이션: 데이터 생성, 수정, 삭제 시 무결성 조건을 검증하는 코드를 데이터를 조작하는 프로그램 내에 추가
	- 데이터베이스 트리거: 트리거 이벤트에 무결성 조건을 실행하는 절차형 SQL을 추가
	- 제약 조건: 데이터베이스에 제약 조건을 설정해 무결성을 유지

#### 참조 무결성 유지
- **RESTRICT** : 개체를 변경/삭제할 때 다른 개체가 변경/삭제할 개체를 참조하고 있을 경우 변경/삭제가 취소
- **CASCADE** : 개체를 변경/삭제할 때 다른 개체가 변경/삭제할 개체를 참조하고 있을 경우  함께 변경/삭제
- **NO ACTION**: MYSQL에서는 RESTRICT와 동일
- **SET NULL**: 개체를 변경/삭제할 때 다른 개체가 변경/삭제할 개체를 참조하고 있을 경우  참조하고 있는 값은 NULL로 세팅

### 정규화(Normalization), 반정규화(Denormalization)
- 하나의 종속성이 하나의 릴레이션에 표현될 수 있도록 분해해가는 과정
- 데이터베이스의 논리적 설계 단계에서 수행 (개념적 X)

#### 정규화
- 정보의 무손실, 분리의 원칙, 데이터의 중복성 감소
- 데이터 구조의 안정성 및 무결성을 유지
- 어떠한 릴레이션이라도 데이터베이스 내에서 표현 가능하게 만듦
- 효과적인 검색 알고리즘 생성 가능
- 데이터 중복을 배제해 이상(Anomaly)의 발생 방지 및 자료 저장 공간의 최소화
- 개체와 속성의 누락 여부 확인 가능
- 데이터 삽입 시 릴레이션을 재구성할 필요성을 줄임

#### 이상(Anomaly)
정규화를 거치지 않아 데이터베이스 내에 데이터들이 불필요하게 중복되어 릴레이션 조작 시 예기치 못하게 발생하는 곤란한 현상
 **삽입 이상(Insertion Anomaly)**: 릴레이션에 데이터를 삽입할 때 의도와 상관없이 원하지 않은 값들도 함께 삽입되는 현상
 **삭제 이상(Deletion Anomaly)**: 릴레이션에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 현상
 **갱신 이상(Update Anomaly)**: 릴레이션에서 튜플에 있는 속성 값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상

#### 정규화 과정
- **1NF(제1정규형)**: 릴레이션에 속한 모든 도메인(Domain)이 **원자 값(Atomic Value)만**으로 되어 있는 정규형
- **2NF(제2정규형)**: 릴레이션 R이 1NF고, 기본키가 아닌 모든 속성이 기본키에 대해 **완전 함수적 종속을 만족**하는, **부분적 함수 종속을 제거**한 정규형
- **3NF(제3정규형)**: 릴레이션 R이 2NF고, 기본키가 아닌 모든 속성이 기본키에 대해 **이행적 함수 종속 관계를 만족하지 않는** 정규형
- **BCNF(Boyce-Codd 정규형)**: 릴레이션 R에서 **모든 결정자가 후보키**인 정규형, 모든 BCNF가 종속성을 보존하는 것은 아님 (강한 제3정규형, 보이스/코드 정규형)
- **4NF(제4정규형)**: 릴레이션 R에 **다치 종속이 성립**하는 경우. R의 모든 속성이 A에 함수적 종속 관계를 만족하는 정규형
- **5NF(제5정규형)**: 릴레이션 R의 **모든 조인 종속이 R의 후보키**를 통해서만 성립되는 정규형

①  비정규 릴레이션
▼ 도메인이 원자값
②  1NF (제1정규형)
▼ 부분적 함수 종속 제거
③  2NF (제2정규형)
▼ 이행적 함수 종속 제거
④ 3NF (제3정규형)
▼ 결정자이면서 후보키가 아닌 것 제거
⑤ BCNF (Boyce-Dodd 정규형)
▼ 다치 종속 제거
⑥  4NF (제4정규형)
▼ 조인 종속성 이용
⑦  5NF (제5정규형/, PJ/NF)

#### 함수적 종속(FD, Functional Dependency)
- **완전 함수적 종속(Full Functional Dependency)**: 완전 함수적 종속이란, 종속자가 기본키에만 종속되며, 기본키가 여러 속성으로 구성되어 있을경우 기본키를 구성하는 모든 속성이 포함된 기본키의 부분집합에 종속된 경우
- **부분 함수적 종속(Partial Functional Dependency)**: 릴레이션에서 종속자가이 기본키가 아닌 다른 속성에 종속되거나, 기본키가 여러 속성으로 구성되어 있을경우 기본키를 구성하는 속성 중 일부만 종속되는 경우  
- **이행적 함수 종속(Transitive Functional Dependecy)**: A → B이고 B → C일 때 A → C를 만족하는 관계

#### 반정규화
- 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로 **의도적으로 정규화 원칙을 위배**하는 행위
- 정규화된 엔티티, 속성, 관계를 시스템의 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법
- 그러나 데이터의 일관성 및 정합성이 저하될 수 있음

#### 반정규화 방법
- **테이블 통합**: 1:1 관계 | 1:N 관계 | 슈퍼타입/서브타입 테이블 통합
- **테이블 분할**: 수평 분할, 수직 분할 → 기본키의 유일성 관리가 어려워짐
- **중복 테이블 추가**: 집계 테이블 | 진행 테이블 | 특정 부분만을 포함하는 테이블 추가
- **중복 속성 추가**: 자주 사용하는 속성을 하나 더 추가하는 것

### 인덱스
- 데이터 레코드를 빠르게 접근하기 위해 <키 값, 포인터>쌍으로 구성된 데이터 구조

#### 인덱스 컬럼 선정
- 인덱스 컬럼의 분포도(Selectivity)가 10~15%  이내인 컬럼
- 가능한 한 수정이 빈번하지 않는 컬럼
- ORDER BY, GROUP BY, UNION이 빈번한 컬럼
- 분포도가 좋은 컬럼은 단독 인덱스로 생성
- 인덱스들이 자주 조합되어 사용되는 컬럼은 결합 인덱스로 생성

#### 설계 시 고려사항
- 새로 추가되는 인덱스는 기존 엑세스 경로에 영향을 미칠 수 있음
- 지나치게 많은 인덱스는 오버헤드(Overhead)  발생
- 넓은 범위 인덱스 처리 시 오히려 전체 처리보다 많은 오버헤드를 발생시킴
- 인덱스만의 추가적인 저장 공간이 필요
- 인덱스와 테이블 데이터의 저장 공간이 분리되도록 설계

#### 인덱스 종류
- **클러스터드 인덱스**(Clustered Index) / **넌클러스터드 인덱스**(Non-Clustered Index)
- **트리 기반 인덱스**: 인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것
- **비트맵 인덱스**: 인덱스 컬럼의 데이터를 Bit 값인 0, 1로 변환해 인덱스 키 사용
- **함수 기반 인덱스**: 컬럼에 특정 함수나 수식을 적용해 산출된 값을 사용하는 것
- **비트맵 조인 인덱스**: 다수의 조인된 객체로 구성된 인덱스
- **도메인 인덱스**: 개발자가 필요한 인덱스를 직접 만들어 사용하는 것 (확장형 인덱스)

#### 순차 파일의 구성
- 기본 구역(Prime Area)
- 색인 구역(Index Area)
- 오버플로 구역(Overflow Area)


### 데이터베이스 동시성(병행) 제어
다중 프로그램의 이점을 활용하여 동시에 여러개의 트랜잭션을 병행 수행할 때 실행되는 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않도록 트랜잭션 간의 상호 작용을 제어하는 기술  
 
#### 병행 제어 목적
- 데이터베이스의 종류를 최대화한다.
- 시스템의 활용도를 최대화한다.
- 사용자에 대한 응답 시간을 최소화한다.
- 단위 시간당 트랜잭션 처리 건수를 최대화한다.
- 데이터베이스의 일관성을 유지한다.
 
#### 병행 제어 기법
- **로킹(Locking)기법**
	- 잠금(Lock)을 설정한 트랜잭션이 해제(Unlock)할 때까지 독점적으로 사용할 수 있게 상호배제 기능을 제공하는 기법
	- 로킹 단위 = 로킹의 대상이 되는 객체의 크기
	- **로킹이 작을수록**: 병행 수준은 뛰어나지만, 로크의 수가 증가하며 관리가 어려움 → 오버헤드 多
	- **로킹이 클수록**: 병행 수준은 낮아지지만, 로크의 수는 감소하며 관리가 쉬움 → 오버헤드 小
- **2단계 로킹(2PL; 2Phase Locking)**
	- 모든 트랜잭션들이 잠금(Lock)과 해제(Unlock) 연산을 확장 단계와 수축 단계로 구분하여 수행하는 기법
- **낙관적 검증(최적 병행 수행기법)**
	- 트랜잭션이 어떠한 검증도 수행하지 않고, 일단 트랜잭션을 수행하고, 트랜잭션 종료 시 검증을 수행하여 데이터베이스에 반영하는 기법
- **타임스탬프 오더링(Timestamp Ordering)**
	- 시스템에서 생성하는 고유 번호인 시간스탬프를 트랜잭션에 부여하는 것으로 트랜잭션 간의 순서를 미리 선택하고 동시성 제어의 기준으로 사용하는 직렬화 기법
- **다중 버전 제어(MVCC; Multi Version Concurrency Control)**
	- 트랜잭션의 타임스탬프와 접근하려는 데이터의 타임스탬프를 비교하여 직렬가능성이 보장되는 적절한 버전을 선택하여 접근하도록 하는 기법

### 뷰(View)
- 기본 테이블로부터 유도된,  이름을 가지는 가상 테이블로 기본 테이블과 같은 형태의 구조를 사용하며, 조작도 기본 테이블과 거의 같음
- 데이터의 논리적 독립성을 제공
- 가상 테이블이기 때문에 물리적으로 구현되어 있지 않지만 사용자에게 있는 것처럼 간주됨 → 저장장치 내에 논리적으로 존재
- 정의된 뷰로 다른 뷰를 정의할 수 있음
- 뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제됨

#### 뷰의 장, 단점
 장점
- 논리적 데이터 독립성 제공
- 접근 제어를 통한 자동 보안 제공
- 사용자 데이터 관리 용이

 단점
- 독립적인 인덱스를 가질 수 없음
- 뷰의 정의를 ALTER로 변경할 수 없음 → DROP하고 새로 CREATE해야 함
- 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신, 연산에 제약이 따름

### Recovery
트랜잭션들을 수행하는 도중 장애로 인해 손상 된 데이터베이스를 손상되기 이전의 정상적인 상태로 복구시키는 작업
- **Abort**: 트랜잭션이 취소된 상태

### 데이터베이스 설계 순서
- **요구 조건 분석**
	- 요구 조건 명세서 작성
- **개념적 설계(정보 모델링, 개념화)**
	- 독립적인 개념 스키마 모델링, 트랜잭션 모델링
	- E-R 다이어그램 모델
- **논리적 설계(데이터 모델링)**
	- 목표 DBMS에 맞는(종속적인) 논리 스키마 설계
	- 트랜잭션 인터페이스 설계, 테이블 설계(RDB),
	- 논리적 데이터베이스 구조로 매핑(Mapping),
	- 스키마의 평가 및 정제
- **물리적 설계(데이터 구조화)**
	- 목표 DBMS에 맞는(종속적인) 물리적 구조의 데이터로 변환
	- 저장 레코드, 접근 경로 설계
- **구현**
	- 목표 DBMS의 DDL(데이터 정의어)로 데이터베이스 생성,
	- 트랜잭션 작성

### 스키마 종류
- **개념 스키마**: 조직체 전체를 관장하는 입장에서 DB를 정의한 것. 데이터 베이스의 전체적인 논리적 구조
- **내부 스키마**: 물리적인 저장장치 입장에서 DB가 저장되는 방법을 기술한 것. 데이터 베이스의 물리적 저장구조를 정의
- **외부 스키마**: 사용자나 응용 프로그래머가 개인의 입장에서 필요한 데이터베이스의 논리적 구조. 실세계에 존재하는 데이터들을 어떤 형식, 구조, 배치 화면을 통해 사용자에게 보여줄 것인지 정의

### DBMS분석 고려사항
- 무결성(가용성)  
- 일관성(상호호환성)  
- 회복  
- 보안  
- 효율성(성능)  
- 데이터베이스 확장

### 데이터 모델
#### 데이터 모델 구성 요소
- **개체(Entity)**: 데이터베이스에 표현하려는 것으로 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체
- **속성(Attribute)**: 데이터의 가장 작은 논리적 단위로서 파일 구조상의 데이터 항목 또는 데이터 필드에 해당
- **관계(Relationship)**: 개체 간의 관계 또는 속성 간의 논리적인 연결을 의미

#### 데이터 모델 표시 요소
- **구조(Structure)**: 논리적으로 표현된 개체들 간의 관계를 표시함
- **연산(Operation)**: 데이터베이스에 저장된 실제 데이터를 처리하는 방법을 표시함
- **제약조건(Constraint)**: 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건을 표시함

#### 데이터 모델 분류
- **개념적 설계**
	- 현실 세계에 대한 인간의 이해를 돕기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정
	- 논리적 설계 이전에 수행
	- E-R(Entity-Relation) 모델
- **논리적 설계**
	- 개념적 모델링 과정에서 얻은 개념적 구조를 컴퓨터가 이해하고 처리할 수 있는 컴퓨터 세계의 환경에 맞도록 변환하는 과정
	- 단순히 데이터 모델이라고 하면 논리적 데이터 모델을 의미
	- 논리적 데이터 모델로 변환, 트랜잭션 인터페이스 설계, 스키마의 평가 및 정제
- **물리적 설계**
	- 목표 DBMS에 맞는 물리적 구조를 설계
	- 저장 레코드 양식설계, 레코드 집중의 분석 및 설계, 접근 경로 설계와 관계

### 분산 데이터베이스
- 논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 연결된 여러 개의 컴퓨터 사이트(Site)에 분산돼 있는 데이터베이스

#### 분산 데이터베이스의 구성 요소
- 분산 처리기: 자체적으로 처리 능력을 가지며, 지리적으로 분산되어 있는 컴퓨터 시스템
- 분산 데이터베이스: 지리적으로 분산되어 있는 데이터 베이스, 해당 지역의 특성에 맞게 구성된 데이터 베이스
- 통신 네트워크: 분산 처리기들을 통신망으로 연결해 논리적으로 하나의 시스템처럼 작동할 수 있도록 하는 통신 네트워크

#### 분산 데이터베이스의 목표
- **위치 투명성(Location Transparency)**: 데이터베이스의 실제 위치를 알 필요 없이 단지 데이터베이스의 논리적인 명칭만으로 액세스할 수 있음
- **중복 투명성(Replication Transparency, 복제 투명성)**: 동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용하고, 시스템은 자동으로 여러 자료에 대한 작업을 수행
- **병행 투명성(Concurrency Transparency)**: 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않음
- **분할 투명성(Division Transparency)**: 하나의 논리적 릴레이션이 여러 단편으로 분할되어 각 단편의 사본이 여러 시스템에 저장되어 있음을 인식할 필요가 없음
- **장애 투명성(Failure Transparency)**: 트랜잭션, DBMS, 네트워크, 컴퓨터 장애가 발생해도 트랜잭션을 정확하게 처리하고 데이터 무결성을 보장함

#### 분산 데이터베이스의 장, 단점
**장점**
- 지역 자치성이 높음
- 자료의 공유성 향상
- 분산 제어 가능
- 시스템 성능 향상
- 중앙 컴퓨터의 장애가 전체 시스템에 영향을 끼치지 않음
- 효용성과 융통성이 높음
- 신뢰성 및 가용성이 높음
- 점진적 시스템 용량 확장이 용이

**단점**
- DBMS가 수행할 기능이 복잡
- 데이터베이스 설계가 어려움
- 소프트웨어 개발 비용 증가
- 처리 비용 증가
- 잠재적 오류 증가 (사이트 간의 오류 발생률 높음) → 보안의 어려움

#### 분산 데이터베이스 설계
애플리케이션이나 사용자가 분산되어 저장된 데이터에 접근하게 하는 것을 목적

 분산 설계 방법
- 테이블 위치 분산: 테이블을 각기 다른 서버에 분산시켜 배치하는 방법
- **분할**(Fragmentation): 테이블의 데이터를 분할하여 분산시키는 것
- **할당**(Allocation): 동일한 분할을 여러 개의 서버에 생성하는 방법

### 로그(Log) 회복 기법
 **지연 갱신 기법(Deferred Update)**
- 트랜잭션이 부분 완료 상태에 이르기까지 발생한 모든 변경 내용을 로그 파일에만 저장하고, 데이터베이스에는 **COMMIT**이 발생할 때까지 **저장을 지연**하는 기법
- 트랜잭션이 실패할 경우 UNDO없이 로그 단순 폐기
- **REDO**

 **즉시 갱신 기법(Immediate Update)**
- 트랜잭션 수행 도중 데이터를 변경하면 변경 정보를 로그 파일에 저장하고, 부분 완료되기 전이라도 모든 변경 내용을 **즉시 데이터베이스에 반영**하는 기법
- 로그 파일을 참조해 **미완료된 변경**에 대해 **UNDO를 우선 실행**한 후, 완료된 변경에 대해 REDO 실행 (UNDO는 **COMMIT된 지점이 없음**)
- **UNDO**

### 시스템 카탈로그(System Catalog)
- 사용자를 포함해 DBMS에서 지원하는 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지 관리하는 시스템 테이블
- 좁은 의미로는 카탈로그를 데이터 사전(Data Dictionary)이라고도 함
- 시스템 카탈로그에 저장된 정보를 메타 데이터(Meta-Data)라고 함
- 사용자와 시스템 모두 접근할 수 있음
- 일반 이용자도 SQL을 이용해 내용을 검색할 수 있음
- INSERT, DELETE, UPDATE문으로 카탈로그를 갱신할 수 없음
- DBMS에 따라 상이한 구조를 갖음
- 카탈로그는 DBMS가 스스로 생성하고 유지함
- 사용자가 SQL문을 실행시켜 변화를 주면 시스템이 자동으로 갱신함

#### 데이터 디렉터리(Data Directory, 사전 관리기)
- 데이터 사전(Data Dictionary)에 수록된 데이터를 실제로 접근하는 데 필요한 정보를 관리 유지하는 시스템
- 시스템만 접근할 수 있음

### 파티션 설계
데이터베이스에서 테이블, 인덱스를 파티션으로 나누는 것
- **범위분할(Range Partitioning)**: 지정한 열의 값을 기준으로 분할
- **해시분할(Hash Partitioning)**: 해시 함수에 따라 데이터 분할
- **리스트분할(List Partitioning)**: 미리 정해진 그룹핑 기준에 따라 분할
- **조합분할(Composite Partitioning)**: 범위분할 이후 해시 함수를 적용

### 데이터 웨어하우스(Data Warehouse)
- 데이터 분석, 데이터 마이닝, 인공지능 및 머신러닝을 지원하기 위해 서로 다른 소스의 데이터를 하나의 데이터 저장소로 집계하는 시스템
- **OLAP(Online Analytical Processing)**: 데이터 웨어하우스와 같이 통합되고 중앙집중적인 데이터 저장소에서 대량의 데이터를 고속으로 다차원 분석을 수행하기 위한 소프트웨어
	- Drill-down: 분석할 항목에 대해 한 차원의 계층 구조를 따라 단계적으로 요약된 형태의 데이터로부터 구체적인 내용의 상세 데이터로 접근하는 기능
	- Pivoting: 보고서의 행, 열, 페이지 차원을 바꾸어 볼 수 있는 기능
	- Slicing: 다차원 데이터 항목들을 다양한 각도에서 조회하고 자유롭게 비교하는 기능
	- Dicing: slicing하고 동일하지만 slicing을 더 쪼개는 형태
	- Roll-up: 작은 단위에서 큰 단위로 집계 수행

### 병렬 데이터베이스의 분할
- **범위 분할**: 분할 키 값이 범위 내에 있는지 여부로 구분
- **목록 분할**: 특정 컬럼의 특정 값을 기준으로 분할
- **해시 분할**: 해시 함수로 분할
- **합성 분할**: 여러 분할 사용
- **라운드로빈 분할**: 행의 고른 분포를 원할 때 사용

## 프로그래밍 언어 활용
### 웹 서버(Web Server)
-   다수의 마이크로프로세서를 동시에 사용하여 데이터 처리를 고속으로 수행하는 DB

###  웹 애플리케이션 서버(WAS; Web Application Server)
- 정적인 콘텐츠를 처리하는 웹 서버(Web Server)와 반대됨
- 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어(=소프트웨어)
- 데이터 접근, 세션 관리, 트랜잭션 관리 등을 위한 라이브러리를 제공
- -Apache Tomcat, IBM WebSphere, Oracle WebLogic, JEUS, JBoss, Jetty, Resin 등등

### 스크립트 언어
- HTML 문서 안에 직접 프로그래밍 언어를 삽입하여 사용하는 것으로, 기계어로 컴파일 되지 않고 별도의 번역기가 소스를 분석하여 동작하게 하는 언어
- 클라이언트의 웹 브라우저에서 해석되어 실행되는 클라이언트용 언어와, 서버에서 해석되어 실행된 후 결과만 클라이언트로 보내는 서버용 스크립트 언어
- **클라이언트용 언어**: JavaScript 
- **서버용 스크립트 언어**: ASP, JSP, PHP, Python, Basic

### 프레임워크
- ‘뼈대’, ‘골조’를 의미하는데, 소프트웨어에서는 특정 기능을 수행하기 위해 필요한 클래스나 인터페이스 등을 모아둔 집합체를 뜻함.
- 반제품 상태의 제품을 토대로 도메인별로 필요한 서비스 컴포넌트를 사용하여 재사용성 확대와 성능을 보장 받을 수 있게 하는 개발 소프트웨어

#### 프레임워크의 특성
- **모듈화(Modularity)**: 프레임워크는 캡슐화를 통해 모듈화를 강화하고 설계 및 구현의 변경에 따른 영향을 최소화함으로써 소프트웨어의 품질을 향상시킴
- **재사용성(Reusability)**: 프레임워크는 재사용 가능한 모듈들을 제공함으로써 개발자의 생산성을 향상시킴
- **확장성(Extensibility)**: 프레임워크는 다형성(Polymorphism)을 통한 인터페이스 확장이 가능하여 다양한 형태와 기능을 가진 애플리케이션 개발이 가능함
- **제어의 역흐름(Inversion of Control)**: 개발자가 관리하고 통제해야 하는 객체들의 제어를 프레임워크가 관리함으로써 생산성 향상시킴

### 테일러링
- 프로젝트 상황에 맞추어 사전에 정의된 개발 방법론 절차, 기법, 산출물 등을 수정하여 적용하는 기법
- 관리 측면에서의 목적 중 하나는 최단기간에 안정적인 프로젝트 진행을 위한 사전 위험을 식별하고 제거하는 것
- 기술적 측면에서의 목적 중 하나는 프로젝트에 최적화된 기술 요소를 도입하여 프로젝트 특성에 맞는 최적의 기법과 도구를 사용하는 것
 **수행절차**: 프로젝트 특징 정의 → 표준 프로세스 선정 및 검증 → 상위 수준의 커스터마이징 → 세부 커스터마이징 → 테일러링 문서화

#### 테일러링 고려사항
- **내부적 요건**: 목표 환경, 요구사항, 프로젝트 규모, 보유 기술, 구성원 능력, 납기/비용
- **외부적 요건**: 법적 제약사항, 국제 표준 품질기준

### IP 주소(Internet Protocol Address)
- 인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소
- 숫자로 8비트씩 4부분, 총 32비트로 구성됨

#### 클래스
- **A** Class: 국가나 대형 통신망에 사용 = 0.0.0.0 ~ 127.255.255.255, 0xxxxxxx
- **B** Class: 중대형 통신망에 사용 = 128.0.0.0 ~ 191.255.255.255, 10xxxxxx
- **C** Class: 소규모 통신망에 사용 = 192.0.0.0 ~ 223.255.255.255, 110xxxxx
- **D** Class: 멀티캐스트용으로 사용 = 224.0.0.0 ~239.255.255.255
- **E** Class: 실험적 주소이며 공용되지 않음 = 240.0.0.0 ~ 255.255.255.255

#### 서브네팅(Subnetting)
- 할당된 네트워크 주소를 다시 여러 개의 작은 네트워크로 나누어 사용하는 것
- **서브넷 마스크(Subnet Mask)**: 4바이트의 IP 주소 중 네트워크 주소와 호스트 주소를 구분하기 위한 비트
- 클래스별로 네트워크와 호스트 주소의 길이가 다르다.
- IP주소에 서브넷 마스크를 **AND 연산**하면 Network ID를 얻는다.
- IP주소에서 Network ID를 제외한 부분은 Host ID이다.
- **Network Address** = Host ID의 최솟값 (ex. 00000000)
- **Broadcast Address** = Host ID의 최댓값 (ex. 11111111)
- **200.1.1.0/24** **네트워크**를 FLSM 방식을 이용하여 **10개의 subnet**으로 나누고 ip subnet -zero를 적용했다. 이때 서브네팅된 네트워크 중 **10번째 네트워크의 broadcast IP 주소**는?
	1. IP 뒤에 있는 숫자(24)는 **기본 서브넷 마스크** 왼쪽 비트 수를 의미 = 11111111.11111111.11111111.00000000
	2. Host ID에서 왼쪽은 서브넷 영역, 오른쪽은 호스트 영역
	3. 서브넷 주소 비트 수 = floor(log~2~(서브넷 개수-1)+1) -> 10개의 서브넷의 주소 비트 수는 4
	4. 새로운 서브넷 마스크 = 11111111.11111111.11111111.11110000
	5. 10번째 네트워크(=서브넷) => 0번부터 카운트 -> 1001|xxxx
	6. broadcast 주소이므로 최댓값이다 => 10011111 = 159
	7. **200.1.1.0.159**
	8. 호스트 개수(=사용 가능한 IP) 주의사항 - Network, Broadcast는 제외하고 계산

#### IPv6(Internet Protocol version 6)
- 현재 사용하고 있는 IP 주소 체계인 IPv4의 주소 부족 문제를 해결하기 위해 개발됨
- **128비트의 긴 주소**를 사용하고, IPv4에 비해 자료 전송 속도가 빠름
- 기본 **헤더의 길이가 40바이트(octet)**의 고정
- 임의로 큰 크기의 패킷을 주고 받을 수 있다. (cf. IPv4의 패킷 크기 = 64KB)
- 인증성, 기밀성, 데이터 무결성의 지원으로 보안 문제 해결 가능
- IPv4와 호환성이 뛰어나고, IPv6 확장 헤더로 네트워크 기능 확장이 용이함
- 자동으로 네트워크 환경구성이 가능
- 멀티미디어의 실시간 처리가 가능
- Traffic Class, Flow Label을 이용하여 등급별, 서비스별로 패킷을 구분할 수 있어 품질 보장
- 주소 자동 설정(Auto Configuration) 기능을 통해 손쉽게 이용자의 단말을 네트워크에 접속시킬 수 있음
- (**QoS**; Quality of Service)이 용이
- 유니캐스트(Unicast), 멀티캐스트(Multicast), 애니캐스트(Anycast)

### MAC 통신
- **유니캐스트(Unicast)**: 출발지와 목적지가 정확한 일대일 통신
- **브로드캐스트(Broadcast)**: 같은 네트워크에 있는 모든 장비를 보내는 통신
- **멀티캐스트(Multicast)**: 특정 그룹을 지정해서 해당 그룹원에서 보내는 방식
- **애니캐스트(Anycast)**: 가장 가까운 Node와 통신
- IPv4: 유니캐스트(Unicast), 멀티캐스트(Multicast), 브로드캐스트(Broadcast)
- IPv6: 유니캐스트(Unicast), 멀티캐스트(Multicast), 애니캐스트(Anycast)

### OSI(Open System Interconnection 참조 모델
- **응용 계층(Application Layer, 7)**:
	- 사용자와 네트워크 간 응용서비스 연결, 데이터 생성
	- HTTP, FTP, TELNET, SMTP / SNTP, DNS
- **표현 계층(Presentation Layer, 6)**
	- 구문 검색, 코드 변환, 암/복호화, 데이터 압축, 문맥 관리 기능
	- JPEG, MPEG
- **세션 계층(Session Layer, 5)**
	- 연결 접속(유지), 동기 제어, 동기점(대화)
	- SSH, TLS
- **전송 계층(Transport Layer, 4)**
	- 종단간(End to End) 신뢰성 있는 데이터 전송, 흐름 제어(슬라이딩 윈도우), 오류 및 혼잡 제어
	- TCP / UDP, RTCP → **세그먼트(Segment)**
- **네트워크 계층(Network Layer, 3)**
	- 단말기 간 데이터 전송을 위한 최적화된 경로(라우팅) 제공
	- 패킷에 발신지와 목적지의 논리 주소를 추가
	- IP, ICMP, IGMP, ARP, RARP, RIP, OSPF → **패킷(Packet)**
- **데이터 링크 계층(Data Link Layer, 2)**
	- 인접 시스템(노드) 간 물리적 연결을 이용해 데이터 전송, 동기화, 오류 및 흐름제어, 오류검출 및 재전송
	- HDLC, PPP, LLC, MAC → **프레임(Frame)**
- **물리 계층(Physical Layer, 1)**
	- 매체 간의 전기적, 기능적, 절차적 기능 정의
	- RS-232C, X.21 → 비트(Bit)

### 네트워크 관련 장비
- **게이트웨이(Gateway)**: 전 계층(1~7계층)의 프로토콜 구조가 다른 네트워크의 연결 수행
- **라우터(Router)**: 브리지와 같이 LAN과 LAN의 연결 기능에 데이터 전송의 최적 경로를 선택할 수 있는 기능이 추가된 것 → 네트워크 계층
- **스위치(Switch)**: 브리지와 같이 LAN과 LAN을 연결하여 훨신 더 큰 LAN을 만드는 장치, 하드웨어 기반으로 처리해서 전송 속도가 빠름 → 데이터 링크 계층
- **브리지(Bridge)**: LAN과 LAN을 연결하거나 LAN안에서의 컴퓨터 그룹을 연결하는 기능 수행, MAC 브리지라고도 함 → 데이터 링크 계층
- **리피터(Repeater)**: 신호가 왜곡되거나 약해질 경우 원래의 신호 형태로 재생하여 다시 전송하는 역할 수행 → 물리 계층
- **허브(Hub)**: 한 사무실이나 가까운 거리의 컴퓨터들을 연결하는 장치 → 물리 계층

### 프로토콜(Protocol)
- 서로 다른 기기들 간의 데이터 교환을 원활하게 수행할 수 있도록 표준화시켜 놓은 통신 규약

#### 프로토콜의 기본 요소
- **구문(Syntax)**: 전송하고자 하는 데이터의 형식, 부호화, 신호 레벨 등을 규정
- **의미(Semantics)**: 두 기기 간의 효율적이고 정확한 정보 전송을 위한 협조 사항과 오류 관리를 위한 제어 정보를 규정
- **타이밍(Timing)**: 두 기기 간의 통신 속도, 메시지의 순서 제어 등을 규정

### TCP/IP
#### TCP
- OSI 7계층의 전송(Transport) 계층(4계층)에 해당
- 신뢰성 있는 연결형 서비스 제공
- 패킷의 다중화, 순서 제어, 오류 제어, 흐름 제어 기능 제공
- 스트림(Stream) 전송 기능 제공
- TCP 헤더 크기는 기본 20byte. (TCP options을 포함하면 TCP 헤더의 크기는 최대 60byte)

#### TCP 헤더
- **Source port, Destination port**: 세그먼트의 출발지와 목적지. 각각 16 bits
- **Sequence Number**: 바이트 단위로 부여되는 전송하는 데이터의 순서. 32 bits
- **Acknowledgment Number**: 받은 수신자가 예상하는 다음 시퀀스 번호. 32 bits
- **Data Offset**: 전체 세그먼트 중에서 헤더가 아닌 데이터가 시작되는 위치. 최대 60바이트
- **Window Size**: 한번에 전송할 수 있는 데이터의 양. 최대 크기는 64KB
- **Checksum**: 데이터를 송신하는 중에 발생할 수 있는 오류를 검출하기 위한 값. 16 Bits
	1. 전송할 데이터를 16 Bits씩 나눠서 모두 더함
	2. 자리올림이 있으면 맨 오른쪽(1의 자리)에 더함
	3. 전체적으로 1의 보수(부호 반전)을 취함

#### IP
- OSI 7계층의 네트워크(Network) 계층(3계층)에 해당
- 데이터 그램을 기반으로 하는 비연결형 서비스 제공
- 패킷의 분해/조립, 주소 지정, 경로 선택 기능(Routing)  제공

#### TCP/IP의 구조
- **응용 계층(A), 표현 계층(P), 세션 계층(S) = 응용 계층**
	- 응용 프로그램 간의 **데이터 송, 수신** 제공
	- HTTP, FTP, TELNET, SMTP / SNTP, DNS
- **전송 계층(T) = 전송 계층**
	- 호스트들 간의 **신뢰성** 있는 통신 제공
	- TCP / UDP, RTCP
- **네트워크 계층(Ne) = 인터넷 계층**
	- 데이터 전송을 위한 주소 지정, **경로 설정(Routing)**  제공
	- IP, ICMP, IGMP, ARP, RARP, RIP, OSPF
- **데이터 링크 계층(Da), 물리 계층(Phy) = 네트워크 액세스 계층**
	- **실제 데이터(프레임)**를 송, 수신하는 역할
	- Ethernet, IEEE 802, HDLC, X.25, RS-232C, ARQ

#### 응용 계층의 주요 프로토콜
- **HTTP(Hypertext Transfer Protocol)**: HTML 문서를 송, 수신하기 위한 표준 프로토콜
- **FTP(File Transfer Protocol)**: 파일을 주고받을 수 있는 원격 파일 전송 프로토콜
- **TELNET**: 멀리 떨어져 있는 컴퓨터에 접속하여 자신의 컴퓨터처럼 사용할 수 있도록 해주는 서비스 → 가상의 터미널 기능 수행
- **SMTP(Simple Mail Transfer Protocol)**: 전자 우편을 교환하는 서비스
- **SNTP(Simple Network Management Protocol)**: TCP/IP의 네트워크 관리 프로토콜로, 라우터(Ne), 허브(Phy) 등 네트워크 정보를 네트워크 관리 시스템에 보내는 데 사용되는 표준 통신 규약
- **DNS(Domain Name System)**: 도메인 네임을 IP 주소로 매핑(Mapping, 연결)하는 시스템

#### 전송 계층의 주요 프로토콜
- **TCP(Transmission Control Protocol)**
	- 신뢰성 있는 연결형 서비스 제공
	- 순서 제어, 오류 제어, 흐름 제어 기능 제공 → 투명성
	- 스트림(Stream) 전송 기능 제공
	- 양방향 연결(Full Duplex Connection)형 서비스 제공
	- 가상 회선 연결 형태의 서비스 제공
- **UDP(User Datagram Protocol)**
	- 신뢰성보다는 속도가 중요시되는 네트워크에서 사용
	- 실시간 전송에 유리함
	- 데이터 전송 전에 연결을 설정하지 않는 비연결형 서비스 제공
	- TCP에 비해 단순한 헤더 구조를 가지므로, 오버헤드 적음
	- UDP 헤더: Source Port, Destination Port, Length, Checksum, Data
- **RTCP(Real-Time Control Protocol)**
	- 패킷의 전송 품질을 제어하기 위한 제어 프로토콜
	- 세션에 참여한 각 참여자들에게 주기적으로 제어 정보 전송 
	- 데이터 패킷과 제어 패킷의 다중화(Multiplexing) 제공 → 하위 프로토콜
	- 최소한의 제어와 인증 기능만을 제공하고 항상 32비트의 경계로 끝남

#### 인터넷 계층의 주요 프로토콜
- **IP(Internet Protocol)**
	- 전송할 데이터에 주소를 지정하고, 경로 설정 기능을 함
	- 비연결형인 데이터그램 방식을 사용해 신뢰성 보장 X
- **ICMP(Internet Control Message Protocol)**: IP와 조합하여 통신중에 발생하는 오류의 처리와 전송 경로 변경 등을 위한 제어 메시지를 관리하는 역할을 하며, 헤더는 8Byte로 구성됨
- **IGMP(Internet Group Management Protocol)**: 멀티캐스트를 지원하는 호스트나 라우터 사이에서 멀티캐스트 그룹 유지를 위해 사용됨
- **ARP(Address Resolution Protocol)**: 호스트의 IP 주소를 호스트와 연결된 네트워크 접속 장치의 물리적 주소(MAC Address)로 바꿈 **(IP 주소 → MAC 주소)**
- **RARP(Reverse Address Resolution Protocol)**: ARP와 반대로 물리적 주소(MAC Address)를 IP 주소로 변환하는 기능을 함 **(MAC 주소 → IP 주소)**

#### 네트워크 액세스 계층의 주요 프로토콜
- **Ethernet(IEEE 802.3)**: CSMA/CD 방식의 LAN
- **IEEE 802**: LAN을 위한 표준 프로토콜
- **HDLC**: 비트 위주의 데이터 링크 제어 프로토콜
- **X.25**: 패킷 교환망을 통한 DTE와 DCE 간의 인터페이스를 제공하는 프로토콜
- **RS-232C**: 공중 전화 교환망(PSTN)을 통한 DTE와 DCE 간의 인터페이스를 제공하는 프로토콜
- IEEE 802.5: Token Ring
- IEEE 802.4: Token Bus

### 배치 프로그램(Batch Program)
사용자와의 상호 작용 없이 여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하는 것
- **이벤트성 배치**: 특정 조건(이벤트)을 설정해두고 조건이 충족될 때만 수행
- **On-Demand 배치**: 사용자 요청 시 수행
- **정기 배치**: 일, 주, 월과 같이 정해진 기간에 정기 수행

#### 필수 요소
- **대용량 데이터**: 대량의 데이터를 가져오거나, 전달하거나, 계산 등의 처리가 가능해야 함
- **자동화**: 심각한 오류가 발생하는 상황을 제외하고는 사용자의 개입 없이 수행돼야 함
- **견고성**: 잘못된 데이터나 데이터 중복 등의 상황으로 중단되는 일 없이 수행돼야 함
- **안정성/신뢰성**: 오류가 발생하면 오류의 발생 위치, 시간 등을 추적할 수 있어야 함
- **성능**: 다른 응용 프로그램(애플리케이션)의 수행을 방해하지 않아야 하고, 지정된 시간 내에 처리가 완료돼야 함

#### 배치 스케줄러(Batch Scheduler), 잡 스케줄러(Job Scheduler)
일괄 처리 작업이 설정된 주기에 맞춰 자동으로 수행되도록 지원해주는 도구

 **스프링 배치(Spring Batch)**
- Spring 프레임워크의 특성을 그대로 가져와 스프링이 가지고 있는 다양한 기능들을 모두 사용할 수 있는 오픈 소스 프레임워크
- 주요 구성 요소: Job, Job Launcher, Job Repository, Step

 **쿼츠(Quartz)**
- Spring 프레임워크로 개발되는 응용 프로그램들의 일괄 처리를 위한 다양한 기능을 제공하는 오픈 소스 라이브러리
- 주요 구성 요소: Job, Job Detail, Trigger, Scheduler

### 프로세스(Process)
- 일반적으로 프로세서(처리기, Processor), 즉 CPU에 의해 처리되는 사용자 프로그램, 시스템 프로그램인 실행중인 프로그램을 의미하며 작업(Job), 태스크(Task)
- **PCB(Process Control Block,** **프로세스 제어 블록)**: 프로세스 고유 식별자, 프로세스의 현재 상태, 프로그램 카운터, CPU 레지스터 정보, 스케줄링 및 프로세스의 우선순위, 계정 정보, 
입출력 상태 정보, 메모리장치 관리 정보, 포인터

#### 프로세스 상태 전이 관련 용어
- **디스패치(Dispatch)**: 준비 상태에서 대기하고 있는 프로세스 중 하나가 프로세서를 할당받아 실행 상태로 전이되는 과정 => 준비(Ready) → 실행(Run)
- **Wake Up**: 프로세스가 대기 상태에서 준비 상태로 전이되는 과정 => 대기(Wait) → 준비(Ready)
- **스풀링(Spooling)**: 나중에 한꺼번에 입, 출력하기 위해 디스크에 저장하는 과정

#### 문맥 교환(Context Switching)
하나의 프로세스에서 다른 프로세스로 CPU가 할당되는 과정에서 발생되는 것

### 스케줄링(Scheduling)
프로세스가 생성되어 실행될 떄 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업
- **장기 스케줄링(작업 스케줄링,상위 스케줄링)**: 어떤 프로세스가 시스템의 자원을 차지할 수 있도록 할 것인가를 결정하여 준비상태 큐로 보내는 작업 → 작업 스케줄러에 의해 수행됨
- **중기 스케줄링**: 어떤 프로세스들이 CPU를 할당받을 것인지 결정하는 작업
- **단기 스케줄링(프로세서 스케줄링,하위 스케줄링)**: 프로세스가 실행되기 위해 CPU를 할당받는 시기와 특정 프로세스를 지정하는 작업 → 프로세서 스케줄링 및 문맥 교환은 프로세서 스케줄러에 의해 수행됨

#### 선점(Preemptive) 스케줄링
- 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 선점할 수 있는 기법
- 우선순위가 높은 프로세스 빠르게 처리 가능
- 빠른 응답 시간을 요구하는 대화식 시분할 시스템(Time Sharing System)에 사용됨
- 많은 오버헤드 발생
- 선점이 가능하도록 일정 시간 배당에 대한 인터럽트용 타이머 클록 필요
- Round Robin, SRT(Shortest Remaining Time), MLQ(Multi-Level Queue), MFQ

#### 비선점(Non-Preemptive) 스케줄링
- 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 선점할 수 없는 기법
- CPU를 할당 받으면 해당 프로세스가 완료될 때까지 CPU 사용
- 모든 프로세스에 대한 요구를 공정하게 처리 가능
- 프로세스 응답 시간의 예측 용이
- 일괄 처리 방식에 적합
- 중요한 작업(짧은 작업)이 중요하지 않은 작업(긴 작업)을 기다리는 경우 발생 → 가뭄 현상
- 우선순위(Priority), 기한부(Deadline), FCFS(FIFO), SJF(Shortest Job First), HRN

#### HRN(Highest Response-ratio Next)
SJF 기법의 가뭄 현상을 보완하기 위한 방식으로, 대기 시간이 긴 프로세스일 경우 우선순위가 높음(=우선 순위의 값이 큼)
→ 우선순위 = (대기시간 + 서비스시간) / 서비스시간

### 파일 디스크립터(File Descriptor)
 - 운영체제가 필요로 하는 파일에 대한 정보를 갖고 있는 제어 블록을 의미하며, 파일제어블록(File Control Block)이라고도 함
- 파일마다 독립적으로 존재하며, 시스템에 따라 다른 구조를 가질 수 있음
- 보통 보조기억장치 내에 저장되어 있다가 해당 파일이 Open될 때 주기억장치로 옮겨짐
- 파일 디스크립터는 파일시스팀에 관리하므로 사용자가 직접 참조할 수 없음

### 프로세스 배치
- **first-fit**: 가장 처음에 넣을 수 있는 곳에 프로세스 배치
- **best-fit**: 배치했을 때 내부 단편화 크기가 가장 적은 위치에 배치
- **worst-fit**: 배치했을 때 내부 단편화 크기가 가장 큰 위치에 배치

### Thrasing
- Page Fault가 빈번하게 발생하여 페이지 교체하는 시간이 길어지는 현상
- Thrasing을 방지하려면 각 프로세스가 필요로 하는 최소한의 프레임 갯수를 보장해주어야 한다.

#### Thrasing 해결 방법
- **Working Set**: 지역성(locality)을 기반으로 일정 시간 동안 자주 참조하는 페이지 집합
- **PFF(Page Fault Frequency)**: 페이지폴트(page fault)빈도를 조절하는 방법

### 교착 상태(Deaklock)
두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태

#### 교착 상태의 조건
1.  **상호배제(Mutual exclusion)**: 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구
2. **점유대기(Hold and wait)** : 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다림
3. **비선점 스케줄링(No preemption)**: 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없음
4. **Circular wait** : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있음

#### 은행원 알고리즘(Banker's algorithm)
교착 상태를 회피하거나 탐지할 때 사용하는 알고리즘 => 회피(Avoidance) 기법 사용

### Python - range
연속된 숫자(정수)를 생성 (end번 원소는 포함 안함)
=> range(start, end, step)
- **range(stop)**
**range(10)** =  **0, 1, 2, 3, 4, 5, 6, 7, 8, 9**
- **range(start, stop)**
**range(1, 11)** =  **1, 2, 3, 4, 5, 6, 7, 8, 9, 10** 
- **range(start, stop, step)**
**range(0, 20,  2)** = **0, 2, 4, 6, 8, 10, 12, 14, 16, 18**
**range(20, 0,  -2)** = **20, 18, 16, 14, 12, 10, 8, 6, 4, 2**

다음과 같이 사용 가능. 인자 생략 시 기본 값은 start는 0, end는 배열 길이-1, step은 1이다. 
=> a[start : end : step]
- a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
a[:7:2] = [0, 20, 40, 60]

### UNIX 명령어
- **cat**: 파일 내용 화면 표시, 커널 버전 확인 = **TYPE** (Windows 명령어)
- chdir: 현재 사용할 디렉터리의 위치 변경 = **CD** (Windows 명령어)
- **chmod**: 파일의 사용 허가 지정, 파일의 속성 변경 = ATTRIB (Windows)
- **chown**: 소유자 변경
- **uname**: 실행 중인 운영 체제에 대한 이름, 버전, 기타 자세한 정보를 출력
- **pwd**: 현재 작업 중인 디렉터리의 이름을 출력
- cp: 파일 복사
- rm: 파일 삭제
- exec: 새로운 프로세스 수행
- find: 파일 찾기
- **fork**: 새로운 프로세스 생성, 하위 프로세스 호출 및 프로세스 복제 명령
- **fsck**: 파일 시스템 검사 및 보수
- **ls**: 현재 디렉터리 내의 파일 목록 확인 = **DIR** (Windows 명령어)
- mount/unmount: 파일 시스템 마운팅/마운팅 해제
- **umask**
	- 파일이나 디렉터리 생성 시 초기 접근권한을 설정할 때
	- 사용 초기 파일의 권한은 666이고 디렉터리는 777
	- **최대 권한 - umask값 = 파일 권한**

### UNIX Bash
- getenv, printenv: 환경 변수 값 확인
- putenv: 환경 변수 추가/수정
- setenv: 환경변수 설정
- set
    - 사용자 환경 변수 설정 및 조회
- export
    - 사용자 환경 변수를 전역 변수로 설정
    - 매개변수 없이 쓰일 경우 현재 설정된 환경변수들이 출력

### UNIX Shell
- 사용자의 명령어를 인식하여 프로그램을 호출하고, 명령을 수행하는 명령어 해석기
- 주기억장치에 상주하지 않고, 명령어가 포함된 파일 형태로 존재하며 보조 기억장치에서 교체 처리가 가능
- 시스템과 사용자 간의 인터페이스 역할을 담당
- 파이프라인 기능 지원 및 입, 출력 재지정을 통해 입, 출력의 방향 변경 가능
- 여러 종류의 쉘이 있음
- DOS의 COMMAND.COM과 같은 기능 수행
- 반복적인 명령 프로그램을 만드는 프로그래밍 기능을 제공
- 초기화 파일을 이용해 사용자 환경을 설정하는 기능을 제공
- 쉘 프로그램 실행을 위한 프로세스와 메모리 관리는 쉘이 담당하지 않음

### 리눅스 로그파일
- **wtmp**
	- 성공한 로그인/로그아웃 정보를 담고 있는 로그파일
	- var/log/wtmp에 위치
	- last 명령어 사용
- **utmp**
	- 현재 로그인 사용자 상태 정보를 담고 있는 로그파일
	- var/run/utmp
	- w, who, finger 명령어 사용
- **btmp**
	- 실패한 로그인 정보를 담고 있는 로그파일
	- /var/log/btmp
	- lastb 명령어 사용
- **last log**
	- 마지막으로 성공한 로그인 정보를 담고있는 로그파일
	- var/log/lastlog
	- lastlog 명령어 사용

### JAVA  - Boolean vs Int
-  C와 달리 java에서는 boolean과 int가 구분된다.
- ex. if(1), while(y--) => 오류 발생

### 가상주소 변환
- (b, offset)
물리 주소 = base[b] + offset

### PHP 연산자
- **@** : 함수 사용시 발생되는 오류메시지를 표시하지 않음
- **<>** : 값이 서로 같지 않을 때 (**!=**)
- **=** : 값을 지정할 때 사용
- **==** : 두 값이 같은지 확인
- **===** : 두 값이 같고, 형식도 같은지 확인
- **::** : new 지시자로 class를 미리 객체화 시켜놓지 않고, 사용하는 시점에서 객체가 생성되고 지정된 method가 실행되도록 하는 접근자

### 코드 오류
- **생략 오류(Omission error)**
	- 입력 시 한 자리를 빼놓고 기록한 경우
	- (1234 -> 123)
- **필사 오류(Transcription error)**
	- 입력 시 임의의 한 자리를 잘못 기록한 경우
	- (1234 -> 1235)
- **전위 오류(Transposition error)**
	- 입력 시 좌우 자리를 바꾸어 기록한 경우
	- (1234 -> 1243)
- **이중 오류(Double Transposition error)**
	- 전위 오류가 두 가지 이상 발생한 경우
	- (1234 -> 2143)
- **추가 오류(Addition error)**
	- 입력 시 한 자리 추가로 기록한 경우
	- (1234 -> 12345)
- **임의 오류(Random error)**
	- 위의 오류가 두 가지 이상 결합하여 발생한 경우
	- (1234 -> 12367)

### IEEE 802.11
무선 근거리 통신망(Local Area Network)을 위한 컴퓨터 무선 네트워크에 사용되는 기술
- IEEE 802.11a - OFDM 기술을 사용해 최고 54Mbps까지의 전송 속도를 지원
- IEEE 802.11b - CSMA/CA 기술의 구현 과정에서 6-7Mbps 정도의 효율
- IEEE 802.11g - a 규격과 전송 속도가 같지만 2.4GHz 대역 전파를 사용
- IEEE 802.11n - 2.4GHz 대역과 5GHz 대역을 사용하며 최고 600Mbps 까지의 속도를 지원
- IEEE 802.11d - 지역 간 로밍용 확장 기술 (2001)
- **IEEE 802.11e** - QoS, 패킷 버스팅 등 기능 확장 기술 (2005)
- IEEE 802.11f - 인터 엑세스 포인트 프로토콜
- IEEE 802.11h - 유럽용 5GHz 대역 전송방식 (2004)
- IEEE 802.11i - 보안 확장 (2004)
- IEEE 802.11j - 일본용 전송 방식 (2004)
- IEEE 802.11k - 전파 자원 측정 확장 기술 (2008)
- IEEE 802.11p - 빠르게 움직이는 운송 수단을 위한 무선 접속 기술
- IEEE 802.11r - 빠른 로밍 (2008)
- IEEE 802.11s - ESS 메쉬 네트워킹
- IEEE 802.11t - 무선 성능 예측(WPP)
- IEEE 802.11u - 802.11 기반이 아닌 네트워크와의 상호 연동 (2011)
- IEEE 802.11v - 무선 네트워크 관리
- IEEE 802.11w - 보호된 관리 프레임 (2009)

## 정보시스템 축 관리
### 소프트웨어 개발 방법론
#### 구조적 방법론
- 정형화된 분석 절차에 따라 사용자 요구사항을 파악하여 문서화하는 처리중심의 방법론
- 타당성 검토 → 계획 → 요구사항 분석 → 설계 → 구현 → 테스트 → 유지보수 단계

#### 정보공학 방법론
- 정보 시스템의 개발을 위해 계획, 분석, 설계, 구축에 정형화된 기법들을 상호 연관성 있게 통합 및 적용하는 자료(Data) 중심의 방법론 → 대규모 정보 시스템 구축 적합

#### 객체지향 방법론
- 현실 세계의 개체(Entity)를 기계의 부품처럼 하나의 객체(Object)로 만들어, 소프트웨어를 개발할 때 기계의 부품을 조립하듯이 객체들을 조립해서 필요한 소프트웨어를 구현하는 방법론
 구성 요소: 객체(Object), 클래스(Class), 메시지(Message), 메서드(Method) 등
 기본 원칙: 캡슐화, 상속성, 다형성, 추상화, 정보 은닉

#### 컴포넌트 기반(CBD; Component Based Design) 방법론
- 기존의 시스템이나 소프트웨어를 구성하는 컴포넌트를 조합하여 하나의 새로운 애플리케이션을 만드는 방법론
- 컴포넌트 및 소프트웨어의 재사용이 가능하여 시간과 노력을 절감할 수 있음
- 새로운 기능 추가가 쉬운 확장성
- 개발 기간 단축으로 인한 생산성 향상

#### 애자일(Agile) 방법론
- 애자일은 ‘민첩한’, ‘기민한’이라는 의미로, 고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발 과정을 진행하는 방법론

### 프로젝트 관리
- 주어진 기간 내에 최소의 비용으로 사용자를 만족시키는 시스템을 개발하기 위한 전반적인 활동
- 계획 관리: 프로젝트 계획, 비용 산정, 일정 계획, 조직 계획
- 품질 관리: 품질 통제, 품질 보증
- 위험 관리: 위험 식별, 위험 분석 및 평가, 위험 관리 계획, 위험 감시 및 조치

### 정보보안의 요소
- **기밀성(Confidentiality)**: 시스템 내의 정보와 자원은 인가된 사용자에게만 **접근** 허용
- **무결성(Integrity)**: 시스템 내의 정보는 오직 인가된 사용자만 **수정**할 수 있음
- **가용성(Avaliability)**: 인가받은 사용자는 언제라도 사용 가능
- **인증성(Authentication)**: 임의 정보에 접근할 수 있는 객체의 자격이나 객체의 내용을 검증하는데 사용되는 성질
- **부인방지(Non-repudiation)**: 데이터를 송, 수신한 자가 송, 수신 사실을 부인할 수 없도록 송, 수신 증거 제공

### 암호 알고리즘
#### 양방향
- **개인키 암호 방식**(Private Key Encryption, 비밀키 암호 방식, **대칭키**)
	- 동일한 키로 데이터를 암호화하고 복호화 함
	- 비밀키는 DB 사용 권한이 있는 사용자만 나눠 가짐
	- **블록 암호화**:
		- 블록 단위로 동작
		- **DES**: 블록 크기는 **64비트**, 키 길이는 56비트
		- **AES**: 블록 크기는 128비트, 키 길이에 따라 128, 192, 256으로 분류
		- **SEED**: 블록 크기는 128비트, 키 길이에 따라 128, 256으로 분류
		- **ARIA**: 블록 크기는 128비트, 키 길이에 따라 128, 192, 256으로 분류
	- **스트림 암호화**: 
		- 비트/바이트/단어들을 순차적으로 암호화
		- **RC4**, LFSR
- **공개키 암호방식** (Public Key Encryption, **비대칭키**)
	- 데이터를 암호화할 때 사용하는 키(공개키)는 DB 사용자에게 공개하고, 복호화 할 때의 키(비밀키)는 관리자가 관리하는 방법
	- 송신자는 수신자의 공개키로 문서를 암호화
	- 키 분배가 용이하고, 관리해야 할 키 개수가 적다
		- **RSA**: 소인수 분해(소수) 문제 활용
		- Diffie-Hellman

**대칭키**
- 암호화/복호화 속도가 빠름
- 알고리즘이 단순함
- 파일의 크기가 작음
- 관리해야 할 키의 수가 많음

**비대칭키**
- 키의 분배가 용이
- 관리해야 할 키의 수가 적음
- 암호화/복호화 속도가 느림
- 알고리즘이 복잡함
- 파일의 크기가 큼

#### 단방향
- **해시**
	- 임의의 길이의 입력 데이터나 메시지를 고정된 길이의 값이나 키로 변환하는 것
	- 해시 알고리즘을 해시 함수라고 부르며, 해시 함수로 변환된 값이나 키를 해시값 또는 해시키라 부름
	- 데이터의 암호화, 무결성 검증을 위해 사용될 뿐만 아니라 정보보호의 다양한 분야에서 활용됨 
	- **SHA** 시리즈, **MD4**, **MD5**, N-NASH, SNEFRU, HAVAL
	- **Salt**: 암호공격을 막기 위해 똑같은 패스워드들이 다른 암호 값으로 저장되도록 추가되는 값

#### 해싱함수(Hashing Function) 종류
- **Division (제산법)**: 레코드키로 해시표의 크기보다 큰 수 중에서 가장 작은소수로 나눈 나머지를 홈 주소로 삼는 방식
- **Mid – Square (제곱법)**: 레코드키 값을 제곱한 후 그 중간 부분의 값을 홈주소로 삼는 방식
- **Digit Analysis (숫자 분석법)**: 키 값을 이루는 숫자의 분포를 분석하여 비교적 고른 자리를 필요한 만큼 택해서 홈 주소로 삼는 방식
- **Radix Conversion (기수 변환법)**: 키 숫자의 진수를 다른 진수로 변환시켜 주소 크기를 초과한 높은 자릿수를 절단하고, 이를 다시 주소 범위에 맞게 조정하는 방법
- **Folding (중첩법)**: 레코드키값을 여러부분으로 나눈 후 각 부분의 값을 더하거나 XOR(배타적 논리합)한 값을 홈주소로 삼는 방식
- **Pseudo Random (난수 생성법)**: 난수(Random Number)를 발생시켜 나온 값을 홈 주소로 삼는 방식
- **Algebraic Coding(대수적 코딩)**: 키 값을 이루고 있는 각 자리의 비트 수를 한 다항식의 계수로 간주하고, 이 다항식을 해시표의 크기에 의해 정의된 다항식으로 나누어 얻은 나머지 다항식의 계수를 홈 주소로 삼는 방식

#### 해시 충돌
- 해시함수의 입력값은 무한하지만 출력값의 가짓수는 유한하므로 해시충돌은 반드시 발생 (*비둘기집 원리)  
- 클러스터링(Clustering) : 연속된 레코드에 데이터가 몰리는 현상  
- 오버플로우(Overflow) : 해시 충돌이 버킷에 할당된 슬롯 수보다 많이 발생하면 더 이상 버킷에 값을 넣을 수 없는 현상
- 버킷(Bucket):  하나의 주소를 갖는 파일의 한 구역. 버킷의 크기는 같은 주소에 포함될 수 있는 레코드의 수
- 슬롯(Slot): 한개의 레코드를 저장 할 수 있는 공간. 한 버킷 안에 여러개의 슬롯이 있다.
- 동의어(Synonym) : 동일한 홈 주소로 인하여 충돌이 일어난 레코드의 집합
- **체이닝(Chaining)**: 버킷 내에 연결리스트를 할당하여 버킷에 데이터를 삽입. 버킷이 꽉 차더라도 연결리스트로 계속 늘려가기에 데이터의 주소값은 바뀌지 않음 (Close)
- **개방주소법(Open Addressing)**: 해시 충돌이 일어나면 다른 버킷에 데이터를 삽입하는 방식 (데이터의 주소값이 바뀜) 선형방법(Linear Method)이라고도 함
- **폐쇄 주소법**: 충돌이 일어난 레코드들을 별도의 오버플로우 영역에 저장하고 chain(pointer)으로 홈 버킷에 연결하는 방법
- **재해싱**: 해시 충돌 시 새로운 해싱 함수로 해시 테이블의 크기를 늘리고, 늘어난 해시 테이블의 크기에 맞추어 테이블 내의 모든 데이터를 다시 해싱

### 하향식 비용 산정 기법
- 과거의 유사한 경험을 바탕으로 전문 지식이 많은 개발자들이 참여한 회의를 통해 비용을 산정하는 비과학적인 방법

#### 전문가 감정 기법
- 조직 내에 있는 경험이 많은 **두 명 이상의 전문가**에게 비용 산정을 의뢰하는 기법
- 새로운 프로젝트에는 과거의 프로젝트와 다른 요소들이 있다는 것을 간과할 수 있음
- 새로운 프로젝트와 유사한 프로젝트에 대한 경험이 없을 수 있음
- 개인적이고 주관적일 수 있음

#### 델파이 기법
- 전문가 감정 기법의 주관적인 편견을 보완하기 위해 **한 명의 조정자**와 여러 전문가의 의견을 종합하여 산정하는 기법

### 상향식 비용 산정 기법
- 프로젝트의 세부적인 작업 단위별로 비용을 산정한 후 집계하여 전체 비용을 산정하는 방법

#### LOC(원시 코드 라인 수, source Line Of Code) 기법
- 소프트웨어 각 기능의 원시 코드 라인 수의 **비관치, 낙관치, 기대치**를 측정하여 **예측치**를 구하고 이를 이용하여 비용을 산정하는 기법
- LOC기법에 의하여 예측된 **총 라인 수가 50,000라인**, 프로그래머의 **월 평균 생산성이 200라인**, 개발에 참여할 **프로그래머가 10인** 일 때, **개발 소요 기간**은? → ( 50,000 / 200 ) / 10 = **25개월**

#### 개발 단계별 인월수(Effort Per Task) 기법
 LOC 기법을 보완하기 위한 기법으로, 각 기능을 구현시키는 데 필요한 노력을 생명 주기의 각 단계별로 산정함, LOC 기법보다 더 정확함

#### COCOMO(Constructive Cost Model) 모형
- 보헴(Boehm)이 제안한 것으로, 원시 프로그램의 규모인 LOC에 의한 비용 산정 기법
- 비용 견적의 강도 분석 및 비용 견적의 유연성이 높아 소프트웨어 개발비 견적에 널리 통용되고 있음
- 같은 규모의 프로그램이라도 그 성격에 따라 비용이 다르게 산정됨
- 비용 산정 결과는 프로젝트를 완성하는 데 필요한 노력(Man-Month)로 나타남

#### **COCOMO의 소프트웨어 개발 유형**
- **조직형(Organic)**: 기관 내부에서 개발된 중, 소규모의 소프트웨어로 일괄 자료 처리나 과학 기술 계산용, 비즈니스 자료 처리용으로 **5만(50KDSI) 라인 이하**의 소프트웨어를 개발하는 유형
- **반분리형 (Semi-Detached)**: 트랜잭션 처리 시스템이나 운영체제, 데이터베이스 관리 시스템 등의 **30만(300KDSI) 라인 이하**의 소프트웨어를 개발하는 유형
- **내장형 (Embedded)**: 최대형 규모의 트랜잭션 처리 시스템이나, 운영체제 등의 **30만(300KDSI) 라인 이상**의 소프트웨어를 개발하는 유형

#### **COCOMO 모형의 종류**
- **기본형 COCOMO (Basic)**: 소프트웨어의 크기(생산 코드 라인 수)와 개발 유형만을 이용하여 비용을 산정하는 모형
- **중간형 COCOMO (Intermediate)**: 기본형 COCOMO의 공식을 토대로 사용하나, 제품, 컴퓨터, 개발요원, 프로젝트 특성의 15가지 요인에 의해 비용을 산정하는 모형
- **발전형 COCOMO (Detailed)**: 중간형 COCOMO를 보완하여 만들어진 방법으로, 개발 공정별로 보다 자세하고 정확하게 노력을 산출하여 비용을 산정하는 모형 (→ 소프트웨어 환경과 구성 요소가 사전에 정의되어 있어야 하며, 개발 과정의 후반부에 주로 적용함)

#### Putnam 모형
- 소프트웨어 생명 주기의 전 과정 동안에 사용될 **노력의 분포를 가정**해주는 모형
- 푸트남(Putnam)이 제안한 것으로 생명 주기 예측 모형이라고도 함
- 시간에 따른 함수로 표현되는 Rayleigh-Norden 곡선의 노력 분포도를 기초로 함
- 대형 프로젝트의 노력 분포 산정에 이용되는 기법
- 개발 기간이 늘어날수록 프로젝트 적용 인원의 노력이 감소함

→ **SLIM**: Rayleigh-Norden 곡선과 Putnam 예측 모형을 기초로 개발된 자동화 추정 도구

#### 기능점수(FP; Function Point) 모형
- 알브레히트(Albrecht)가 제안한 것으로, 소프트웨어의 기능을 증대시키는 요인별로 가중치를 부여하고, 요인별 가중치를 합산하여 **총 기능점수를 산출**하며 총 기능점수와 영향도를 이용하여 기능점수(FP)를 구한 후 이를 이용해서 비용을 산정하는 기법
- 자료 입력(입력 양식), 정보 출력(출력 보고서), 명령어(사용자 질의수), 데이터 파일, 필요한 외부 루틴과의 인터페이스
- 경험을 바탕으로 단순, 보통, 복잡한 정도에 따라 가중치를 부여
- 영향도와 가중치의 합을 이용하여 실질기능점수를 계산

→ **ESTIMACS**: 다양한 프로젝트와 개인별 요소를 수용하도록 FP 모형을 기초로 개발된 자동화 추정 도구

### LAN
- **근거리 통신망(LAN; LocalArea Network)**
	- 비교적 가까운 거리에 있는 컴퓨터, 프린터, 테이프 등과 같은 자원을 연결하여 구성하며 주로 자원 공유의 목적으로 사용
	- 사이트 간의 거리가 짧아 데이터의 전송 속도가 빠르고, 에러 발생율이 낮음
	- 주로 **버스형, 링형 구조** 사용
- **원거리 통신망(WAN; Wide Area Network)**
	- 대륙과 대륙 같이 멀리 떨어진 사이트들을 연결하여 구성
	- 사이트 간의 거리가 멀기 때문에 통신 속도가 느리고, 에러 발생율이 높음
- **VLAN**
	- 물리적 배치와 상관없이 논리적으로 LAN을 구성하여 Broadcast Domain을 구분할 수 있게 해주는 기술
	- 접속된 장비들의 성능향상 및 보안성 증대 효과가 있음

### ARQ (Automatic Repeat Request)
- 자동 반복 요청을 의미. 에러가 발생한 경우 재전송을 요구하는 방식
- Stop-and-wait, Go-back-N, Selective-Repeat, Adaptive

### 스위치(Switch) 분류
- **L2 스위치**
	- OSI 2계층(Da)에 속하는 장비
	- 일반적으로 부르는 스위치는 L2 스위치를 의미
	- MAC 주소를 기반으로 프레임(Frame)을 전송
	- **동일 네트워크 간의 연결만 가능**
- **L3 스위치**
	- OSI 3계층(Ne)에 속하는 장비
	- L2 스위치에 **라우터** 기능이 추가된 것
	- IP 주소를 기반으로 패킷(Packet)을 전송
	- 서로 다른 네트워크 간의 연결이 가능
- **L4 스위치**
	- OSI 4계층(T)에 속하는 장비
	- 로드밸런서(Load Balancer)가 달린 L3 스위치
	- IP 주소 및 TCP/UDP를 기반으로 사용자들의 요구를 서버의 부하가 적은 곳에 배분하는 로드밸런싱 기능을 제공
- **L7 스위치**
	- OSI 7계층(A)에 속하는 장비
	- IP 주소 및 TCP/UDP 포트 정보에 **패킷 내용까지 참조**하여 세밀하게 로드밸런싱함

### 다중화(Multiplexing)
2개 이상의 저수준의 채널들을 하나의 고수준의 채널로 통합하는 과정

- **Frequency Division Multiplexing**: 주파수로 분할
- **Time Division Multiplexing**: 시간으로 분할
- **Code Division Multiplexing**: 코드를 이용한 다중접속 기술
- **Wavelength Division Multiplexing**: 파장으로 분할


### 경로 제어 프로토콜(Routing Protocol)
- **RIP(Routing Information Protocol)**
	- IGP(Interior Gateway Protocol)로 **Bellman-Ford 알고리즘**을 이용하여 최적의 경로를 설정하는 **소규모** 프로토콜
	- 최대 홉(Hop) 수를 15홉 이하로 제한
	- **거리 벡터 라우팅 프로토콜**이라고도 함
- **OSPF(Open Shortest Path First)**
	- IGP(Interior Gateway Protocol)로 RIP의 단점 개선을 위해 **daijkstra 알고리즘** 및 Link Static 기반으로 최단경로를 찾는 **대규모** 프로토콜
- **BGP (Border Gateway Protocol)**
	- 자치 시스템 간의 라우팅 프로토콜로, EGP(Exterior Gateway Protocol)의 단점을 보완하기 위해 만들어짐
	- 초기에 BGP 라우터들이 연결될 때는 전체 경로를 나타내는 **라우팅 테이블을 교환**하고, 이후에는 변화된 정보만 교환
	- 네트워크 변화에 신속하게 대처할 수 있음
	- 멀티캐스팅 지원

### 흐름 제어(Flow Control)
네트워크 내의 원활한 흐름을 위해 송, 수신 측 사이에 전송되는 패킷의 양이나 속도를 규제하는 기능

- **정지-대기(Stop-and-Wait)**
	- 수신 측의 확인 신호(ACK)를 받은 후에 다음 패킷을 전송하는 방식 → 한번에 하나의 패킷 전송
- **슬라이딩 윈도우(Sliding Window)**
	- 수시 측의 확인 신호(ACK)를 받지 않더라도 미리 정해진 패킷의 수만큼 연속적으로 전송하는 방식 → 한번에 여러 개 패킷 전송
	- 수신 측으로부터 송신한 패킷에 대한 긍정 수신 응답(ACK)이 전달된 경우 윈도우 크기는 증가하고, 수신 측으로부터 부정 수신 응답(NAK)이 전달된 경우 윈도우 크기는 감소함

### 폭주(혼잡) 제어(Congestion Control)
흐름 제어(Flow Control)가 송, 수신 측 사이의 패킷 수를 제어하는 기능이라면, 혼잡 제어는 네트워크 내의 패킷 수를 조절하여 네트워크의 오버플로(Overflow)를 방지하는 기능을 함

- **느린 시작(Slow Start)**
	- 윈도우의 크기를 1, 2, 4, 8, … 같이 2배씩 지수적으로 증가시켜 초기에는 느리지만 갈수록 빨라짐
	- 전송 데이터의 크기가 임계 값에 도달하면 혼잡 회피 단계로 넘어감
- **혼잡 회피(Congestion Avoidance)**
	- 느린 시작의 지수적 증가가 임계 값에 도달하면 혼잡으로 간주하고 회피를 위해 윈도우의 크기를 1씩 선형적으로 증가시켜 혼잡을 예방하는 방식

### 접근 제어 (Access Control, AC)
- 누군가가 무언가를 사용하는 것을 허가하거나 거부하는 기능
- 사람이나 프로세스가 시스템이나 파일에 읽기, 쓰기, 실행 등의 접근 여부를 허가하거나 거부할 수 있다.
- 시스템 및 네트워크의 접근 제어: IP, 서비스 포트
- 네트워크 장비의 접근 제어: 관리 인터페이스 접근제어, 접근 제어 목록(ACL, Access Control List)
- **인증(Authentication)**
	- 사용자가 누구인지 판별
- **인가(Authorization)**
	- 어떤 사용자가 어떤 행위(action)을 수행할 권한을 가지고 있는지를 판별
	- ‘인가’를 수행하기 위해서는 ‘인증’이 선행되어야 함
	- **XACML(XML Access Control Markup Language)**: 인가 및 권한 부여 정책을 지정할 수 있도록 XML 구문에 대한 제안을 제공

#### 강제적 접근 제어 (MAC, Mandatory Access Control)
- 미리 정해진 정책과 보안 등급에 의거하여 주체(Subject)에게 허용된 접근 권한과 객체(Object)에 부여된 허용 등급을 비교하여 접근을 제어하는 방법
- 어떤 주체가 특정 개체에 접근하려 할 때 양쪽의 보안 레이블(Security Label)에 기초하여 높은 보안 수준을 요구하는 정보(객체)가 낮은 보안 수준의 주체에게 노출되지 않도록 한다.
- **Bell-Lapadula Model**
	- 주어진 보안 수준에 위치하는 주체는 보다 높은 수준에 있는 데이터를 읽을 수 없음
	- 주어진 보안 수준에 위치하는 주체는 보다 낮은 수준으로 데이터를 쓸 수 없음

#### 임의적 접근 제어 (DAC, Discretionary Access Control)
- 객체에 대한 접근을 사용자나 그룹의 신분을 기준으로 제한하는 방법

#### 역할 기반 접근 제어 (RBAC, Role Based Access Control)
- 권한을 사용자 개인이 아닌 역할 그룹에 부여하고, 사용자에게 역할을 할당하여 접근 제어를 하는 방식
- 임의적 접근 제어(DAC)과 강제적 접근 제어(MAC)의 단점을 보완한 방식

#### 속성 기반 접근 제어 (ABAC, Attribute Based Access Control)
- 객체와 주체의 속성에 대한 조건을 기술하여 접근 제어를 하는 방식

### Secure OS
- 기존의 운영체제(OS)에 내재된 보안 취약점을 해소하기 위해 보안 기능을 갖춘 커널을 이식하여 외부의 침입으로부터 시스템 자원을 보호하는 운영체제
- 식별 및 인증, 임의적 접근통제(DAC), 강제적 접근통제(MAC), 객체 재사용 보호, 완전한 조정, 신뢰 경로, 감사 및 감사기록 축소

#### 구현
위로 갈수록 구현하기 복잡하다
- **암호적 분리(Cryptographic Separation)**: 내부 정보를 암호화하는 방법
- **논리적 분리(Logical Separation)**: 프로세스의 논리적 구역을 지정하여 구역을 벗어나는 행위를 제한하는 방법
- **시간적 분리(Temporal Separation)**: 동일 시간에 하나의 프로세스만 수행되도록 하여 동시 실행으로 발생하는 보안 취약점을 제거하는 방법
- **물리적 분리(Physical Separation)**: 사용자별로 특정 장비만 사용하도록 제한하는 방법

#### 참조 모니터(Reference Monitor)
보호대상의 객체에 대한 접근통제를 수행하는 추상머신이며, 이를 실제로 구현한 것이 보안 커널임
- **격리성(Isolation)**: 부정 조작 불가능
- **검증 가능성(Verifiability)**: 적절히 구현됐다는 것 확인 가능
- **완전성(Completeness)**: 우회가 불가능

### 스토리지
컴퓨터에 데이터를 저장하는 저장소의 역할을 수행하는 부품  
- **DAS(Direct Attachted Storage)**: PC나 서버에 다이렉트로 꽂아서(usb처럼) 사용하는 스토리지
- **NAS(Networt Attached Storage)**
	- TCP/IP와 같은 표준 네트워크로 Network Switch와 연결하여 사용
	- 여러 매체에서 네트워크를 통해 접속하여 파일을 공유 하고 저장된 파일의 정보들을 여러 서버에 공유할 수 있음
	- 파일공유, 동시 접속이 필요한 업무 (웹하드 등), 비정형 데이터 사용에 적합 (동영상 파일, 오디오 파일, 사진, 문서, 메일 본문 등 ), 다수 클라이언트의 데이터 공유를 위하여 사용
- **SAN(Storage Area Network)**
	- 대규모 네트워크 사용자를 위해 저장장치를 데이터 서버와 연결하여 별도의 네트워크로 관리하는 고속 네트워크 시스템
	- 대용량의 데이터를 연결된 서버에 상관없이 원거리에 분산 된 저장장치 사이에서 데이터를 주고받을 수 있습니다.
	- 볼륨을 공유하는 목적으로 블록 형태의 I/O가 필요한 업무, DB같은 구조화된 워크로드, 고용량 및 고성능이 요구되는 업무에 사용

### 개발보안 방법론
- **MS-SDL(Microsoft-Secure Development Lifecycle)**: Microsoft에서 보안수준이 높은 안전한 소프트웨어를 개발하기 위해 자체수립한 SDL이며, 방법론이 적용되기 전 버전보다 50% 이상 취약점이 감소함
- **Seven Touchpoints**: SW 보안의 모범 사례를 SDLC(Software Development Life Cycle)에 통합한 소프트웨어 개발 보안 생명주기 방법론
- **CLASP(Comprehensive Lightweight Application Security Process)**: 개념, 역할기반, 활동평가, 활동구현, 취약성 등의 활동중심, 역할 기반의 프로세스로 구성된 집합체로서 이미 운영중인 시스템에 적용하기 적당한 소프트웨어 개발 보안 방법론
- **CWE(Common Weakness Enumeration)**: 소프트웨어 취약점 및 취약점에 대한 범주 시스템으로, 소프트웨어의 결함을 이해하고 이러한 결함을 식별, 수정 및 방지하는데 사용할 수 있는 자동화된 도구를 작성함

### 서비스 공격
- **Ping of Death(죽음의 핑)**: 정상 크기보다 큰 ICMP 패킷을 작은 조각(Fragment)으로 쪼개어 공격 대상이 조각화된 패킷을 처리하게 만드는 공격 방법. 이 과정을 처리하기 위해 많은 시스템의 자원을 사용하게 되며,시스템의 자원을 부족하게 만들어 정상적인 작동을 하지 못하게 만듬
- **Ping Flood**: 특정 사이트에 매우 많은 ICMP Echo를 보내면, 이에 대한 응답(Respond)을 하기 위해 시스템 자원을 모두 사용해버려 시스템이 정상적으로 동작하지 못하도록 하는 공격
- **서비스 거부 공격 (DOS; Denial of Service)**: 표적이 되는 서버의 자원을 고갈시킬 목적으로 다수의 공격자 또는 시스템에서 대량의 데이터를 한 곳의 서버에 집중적으로 전송함으로써 표적이 되는 서버의 정상적인 기능을 방해하는 것
- **Ping of Death**: Ping 명령을 전송할 때 패킷의 크기를 인터넷 프로토콜 허용 범위 이상으로 전송하여 공격 대상의 네트워크를 마비시키는 공격 방법
- **SMURFING(스머핑)**: IP또는 ICMP의 특성을 악용하여 엄청난 양의 데이터를 한 사이트에 집중적으로 보냄으로써 네트워크를 불능 상태로 만드는 공격 방법. 공격자는 송신 주소를 공격 대상지의 IP주소로 위장하고 해당 네트워크 라우터의 브로드캐스트(Broadcast) 주소를 수신지로 하여 패킷을 전송하면, 라우터의 브로드캐스트 주소로 수신된 패킷은 해당 네트워크 내의 모든 컴퓨터로 전송됨
- **(TCP) SYN Flooding**: 공격자가 가상의 클라이언트로 위장하여 3-way-handshake 과정(TCP에서 신뢰성 있는 연결을 위해 쓰는 기법)을 의도적으로 중단시킴으로써 공격 대상지인 서버가 대기 상태에 놓여 정상적인 서비스를 수행하지 못하게 하는 공격 방법. 존재하지 않는 클라이언트가 서버별로 한정된 접속 가능 공간에 접속한 것처럼 속여 다른 사용자가 서비스를 이용하지 못하게 함
- **TearDrop**: 데이터의 송, 수신 과정에서 패킷의 크기가 여러 개로 분할되어 전송될 때 분할 순서를 알 수 있도록 Fragment Offset값을 함께 전송하는데, 이것을 변경시켜 수신측에서 패킷을 재조립할 때 오류로 인한 과부하를 발생시킴으로써 시스템이 다운되도록 하는 공격 방법
- **LAND Attack**: 패킷을 전송할 때 송신 IP 주소와 수신 IP 주소를 모두 공격 대상의 IP 주소로 하여 공격 대상 자신에게 전송하는 것으로, 자신에 대해 무한히 응답하게 하는 공격 방법
- **분산 서비스 거부 (DDoS; Distributed Denial of Service)**: 여러 곳에 분산된 공격 지점에서 한 곳의 서버에 대해 분산 서비스 공격을 수행하는 공격 방법

### 네트워크 침해 공격
- **Smishing(스미싱)**: 문자 메시지(SMS)에 링크를 거는 등 문자 메시지를 이용해 사용자의 개인 신용 정보를 빼내는 수법
- **Spear Phishing(스피어 피싱)**: 사회 공학의 한 기법으로, 인간 상호 작용의 깊은 신뢰를 바탕으로 특정 대상을 선정한 후 메일의 링크나 파일을 클릭하도록 유도한 뒤 개인 정보를 탈취하는 수법
- **지능형 지속 위협(APT; Advanced Persistent Threats)**": 조직적으로 특정 기업이나 조직 네트워크에 침투해 활동 거점을 마련한 뒤 때를 기다리면서 보안을 무력화시키고 정보를 수집한 다음 외부로 빼돌리는 형태의 공격 (이메일, 이동식 디스크(USB), P2P 사이트)
- **무차별 대입 공격 (Brute Force Attack)**: 암호화된 문서의 암호키를 찾아내기 위해 적용 가능한 모든 값을 대입하여 공격하는 방식
- **Qshing(큐싱)**: QR코드와 개인정보 및 금융정보를 낚는다(Fishing)의 합성 신조어
- **SQL 삽입 공격(SQL Injection)**: 전문 스캐너 프로그램 혹은 봇넷 등을 이용해 웹사이트를 무차별적으로 공격하는 과정에서 취약한 사이트가 발견되면 데이터베이스 등의 데이터를 조작하는 일련의 공격 방식
- **크로스 사이트 스크립팅(XSS; Cross-Site Scripting)**:사용자가 특정 게시물이나 이메일의 링크를 클릭하면 악성 스크립트가 실행되어 페이지가 깨지거나, 사용자의 컴퓨터에 있는 로그인 정보나 개인정보, 내부 자료 등이 해커에게 전달되는 해킹 기법
- **세션 하이재킹(Session Hijacking)**: 공격 대상이 이미 시스템에 접속되어 세션이 연결되어 있는 상태를 가로채기 하는 공격
- **Evil Twin Attack**: 합법적인 네트워크인 것처럼 가장한 무선 네트워크
- **FTP 바운스 공격(FTP Bounce Attack)**: FTP서버가 데이터를 전송할 때 목적지가 어디인지 검사하지 않는 설계상의 문제점을 이용한 공격
- **디렉터리 탐색 공격(Directory Traversal Attack)**: HTTP 기반의 공격으로 액세스가 제한된 디렉터리에 접근하고, 웹 서버의 루트 디렉터리 외부 명령을 실행
- **Switch Jamming**: 위조된 매체 접근 제어(MAC) 주소를 지속적으로 네트워크로 흘려보내, 스위치 MAC 주소 테이블의 저장 기능을 혼란시켜 더미 허브(Dummy Hub)처럼 작동하게 하는 공격

### 정보 보안 침해 공격
- **Zombie(좀비) PC**: 악성코드에 감염되어 다른 프로그램이나 컴퓨터를 조종하도록 만들어진 컴퓨터. C&C(Command & Control) 서버의 제어를 받아 주로 DDoS 공격 등에 이용됨
- **C&C 서버**: 해커가 원격지에서 감염된 좀비 PC에 명령을 내리고 악성코드를 제어하기 위한 용도로 사용하는 서버
- **Botnet(봇넷)**: 악성 프로그램에 감염되어 악의적인 의도로 사용될 수 있는 다수의 컴퓨터들이 네트워크로 연결된 형태
-**Worm(웜)**: 네트워크를 통해 연속적으로 자신을 복제하여 시스템의 부하를 높임으로써 결국 시스템을 다운시키는 바이러스의 일종
-**Zero Day Attack(제로 데이 공격)**: 보안 취약점이 발견되었을 때 발견된 취약점의 존재 자체가 널리 공표되기도 전에 해당 취약점을 통하여 이루어지는 보안 공격
- **Key Logger Attack(키로거 공격)**: 컴퓨터 사용자의 키보드 움직임을 탐지해 ID, 패스워드 등 개인의 중요한 정보를 몰래 빼가는 해킹 공격
- **Ransomware(랜섬웨어)**: 인터넷 사용자의 컴퓨터에 침입해 내부 문서 파일 등을 암호화해 사용자가 열지 못하게 하는 공격으로, 암호 해독용 프로그램의 전달을 조건으로 사용자에게 돈을 요구하기도 함
- **Back Door(백도어, Trap Door)**: 시스템 설계자가 서비스 기술자나 프로그래머의 액세스 편의를 위해 시스템 보안을 제거하여 만들어 놓은 비밀 통로로, 컴퓨터 범죄에 악용되기도 함
- **Trojan Horse(트로이 목마)**: 정상적인 기능을 하는 프로그램으로 위장하여 프로그램 내에 숨어 있다가 해당 프로그램이 동작할 때 활성화되어 부작용을 일으키는 것으로, 자기 복제 능력은 없음
- **Logic Bomb**: 특정 날짜나 시간 등 조건이 충족되었을 때 악의적인 기능이 유발할 수 있게 만든 코드
- **Pharming**: 사용자가 자신의 웹 브라우저에서 정확한 웹 페이지 주소를 입력해도 가짜 웹 페이지에 접속하게 하여 개인정보를 훔치는 것
- **운영체제 명령어 삽입**: 운영체제 명령어 파라미터 입력 값이 적절한 사전검증을 거치지 않고 사용되어 공격자가 운영체제 명령어를 조작
- **자원 삽입**: 외부 입력 값을 이용해서 파일의 경로를 조작한다거나, 내부 자원을 조작할 수 있는 보안약점

#### 블루투스 공격
블루투스를 이용한 해킹 공격
- **블루재킹(Bluejacking)**: 블루스패밍(Bluespamming)이라고도 하며, 스팸처럼 익명으로 블루투스 사용자에게 메시지를 보내는 기법
- **블루스나핑(Bluesnarfing)**: 블루투스의 취약점을 이용하여 장비의 임의 파일에 접근하는 공격으로 모바일 기기에 저장된 일정표, 전화번호, 이메일, 문자메시지 등에 접근하는 방법
- **블루버깅(Bluebugging)**: 블루투스 장비 간의 취약한 연결 관리를 악용한 공격으로 공격 장치와 공격 대상 장치를 연결하여 공격 대상 장치에서 임의의 동작을 실행하는 공격
- **블루프린팅(Blueprinting)**: 공격자가 블루투스의 서비스 발견 프로토콜(SDP)을 이용해 공격이 가능한 블루투스 장치의 종류(예, 전화 통화, 키보드 입력, 마우스 입력 등)를 검색하고 모델을 확인

### 네트워크 관련 신기술
- **IoT(Internet of Things,사물 인터넷)**: 사람과 사물, 사물과 사물 간에 지능 통신을 할 수 있는 M2M(Machine to Machine)의 개념을 인터넷으로 확장하여 사물은 물론, 현실과 가상 세계의 모든 정보와 상호 작용하는 개념
- **M2M(Machine to Machine)**: 무선 통신을 이용한 기계와 기계 사이의 통신
- **Mobile Computing(모바일 컴퓨팅)**: 휴대형 기기로 이동하면서 자유로이 네트워크에 접속하여 업무를 처리할 수 있는 환경
- **Cloud Computing(클라우드 컴퓨팅)**: 각종 컴퓨팅 자원을 중앙 컴퓨터에 두고 인터넷 기능을 갖는 단말기로 언제 어디서나 인터넷을 통해 컴퓨터 작업을 수행할 수 있는 환경
- **Grid Computing(그리드 컴퓨팅)**: 수 많은 컴퓨터를 하나의 컴퓨터처럼 묶어 분산 처리하는 방식
- **Mobile Cloud Computing(MCC;모바일 클라우드 컴퓨팅)**: 클라우드 서비스를 이용하여 소비자와 소비자의 파트너가 모바일 기기로 클라우드 컴퓨팅 인프라를 구성하여 여러 가지 정보와 자원을 공유하는 ICT(Information and Communications Technologies) 기술
- **Inter-Cloud Computing(인터클라우드 컴퓨팅)**: 여러 클라우드 서비스 제공자들이 제공하는 클라우드 서비스나 자원을 연결하는 기술
- **Mesh Network(메시 네트워크)**: 대규모 디바이스의 네트워크 생성에 최적화 되어 차세대 이동통신, 홈 네트워킹, 공공 안전 등의 특수 목적을 위한 새로운 방식의 네트워크 기술
- **Smart Grid(스마트 그리드)**: 전기 및 정보통신 기술을 활용하여 전력망을 지능화, 고도화함으로써 고품질의 전력서비스를 제공하고 에너지 이용효율을 극대화하는 전력망
- **WI-SUN(와이선)**: 스마트 그리드와 같은 장거리 무선 통신을 필요로 하는 사물 인터넷 서비스를 위한 저전력 장거리(LPWA; Low-Power Wide Area) 통신 기술
- **NDN(Named Data Networking)**: 콘텐츠 자체의 정보와 라우터 기능만으로 데이터 전송을 수행하는 기술, 콘텐츠 중심 네트워킹(CNN; Content Centric Networking)과 같은 개념으로 기존의 IP 망을 대체할 새로운 인터넷 아키텍처
- **지능형 초연결망**: 국가망에 소프트웨어 정의 기술을 적용하는 방법
- **NGN(Next Generation Network, 차세대 통신망)**: ITU-T에서 개발하고 있는 유선망 기반의 차세대 통신망으로, 하나의 망이 인터넷처럼 모든 정보와 서비스를 패킷으로 압축하여 전송
- **SDN(Software Defined Networking,소프트웨어 정의 네트워킹)**: 네트워크를 컴퓨터처럼 모델링하여 여러 사용자가 각각의 소프트웨어들로 네트워킹을 가상화하여 제어하고 관리하는 네트워크
- **NFC(Near Field Communication, 근거리 무선 통신)**: 고주파(HF; High Frequency)를 이용한 근거리 무선 통신 기술. 아주 가까운 거리에서 양방향 통신을 지원하는 RFID(Radio Frequency Identification) 기술의 일종
- **UWB(Ultra WideBand,초광대역)**: 짧은 거리에서 많은 양의 디지털 데이터를 낮은 전력으로 전송하기 위한 무선 기술
- **PICONET(피코넷)**: 여러 개의 독립된 통신장치가 UWB 통신 기술 또는 블루투스 기술을 사용하여 통신망을 형성하는 무선 네트워크 기술
- **WBAN(Wireless Body Area Network)**: Wearable 또는 몸에 심는 형태의 센서나 기기를 무선으로 연결하는 개인 영역 네트워킹 기술
- **GIS (Geographic Information System, 지리 정보 시스템)**: 지리적인 자료를 위성을 이용해 모든 사물의 위치 정보를 제공해주는 시스템
- **USN(Ubiquitous Sensor Network, 유비쿼터스 센서 네트워크)**: 필요한 모든 곳에 RFID 태그를 부착하고 사물의 인식 정보는 물론 주변의 환경정보까지 탐지하여 이를 네트워크에 연결해 정보를 관리하는 것
- **SON (Self Organizing Network, 자동 구성 네트워크)**: 주변 상황에 맞추어 스스로 망을 구성하는 네트워크
- **Ad-hoc Network(애드 혹 네트워크)**: 재난 현장과 같이 별도의 고정된 유선망을 구축할 수 없는 장소에서 구성한 네트워크
- **Network Slicing(네트워크 슬라이싱)**: 5G 네트워크를 구현하는 중요한 핵심 기술로, 하나의 물리적인 코어 네트워크 인프라를 독립된 다수의 가상 네트워크로 분리하는 네트워크 기술
- **저전력 블루투스 기술(BLE; Bluetooth Low Energy)**: 일반 블루투스와 동일한 2.4GHz 주파수 대역을 사용하지만 연결되지 않은 대기 상태에서는 절전모드를 유지하는 기술
- **Foursquare**: 위치 기반 소셜 네트워크 서비스이자 이를 개발한 회사의 명칭
- **MQTT**:  TCP/IP 기반 네트워크에서 동작하는 발행-구독 기반의 메시징 프로토콜. 최근 IoT 환경에서 자주 사용되고 있음
- **Li-fi**: 발광 다이오드 적외선에서 근자외선까지 스펙트럼의 빛을 이용한 5세대 이동 통신 기술

### 소프트웨어 관련 신기술
- **인공지능(AI; Artificial Intelligence)**: 인간의 두뇌와 같이 컴퓨터 스스로 추론, 학습, 판단 등 인간지능적인 작업을 수행하는 시스템 (→ 인공지능 개발언어: 리스프(LISP), 프롤로그(PROLOG))
- **Neuralink(뉴럴링크)**: 사람이 인공지능에 대항할 수 있는 더 높은 수준의 기능에 도달하도록 컴퓨터와 뇌를 연결한다는 개념
- **Deep Learning(딥 러닝)**: 인간의 두뇌를 모델로 만들어진 인공 신경망(ANN; Artificial Neural Network)을 기반으로 하는 기계 학습 기술
- **Expert System(전문가 시스템)**: 의료 진단 등과 같은 특정 분야의 전문가가 수행하는 고도의 업무를 지원하기 위한 컴퓨터 응용 프로그램
- **Blockchain(블록체인)**: P2P(Peer-to-Peer) 네트워크를 이용하여 온라인 금융 거래 정보를 온라인 네트워크 참여자(Peer)의 디지털 장비에 분산 저장하는 기술
- **분산 원장 기술(DLT;Distributed Ledger Technology)**: 중앙 관리자나 중앙 데이터 저장소가 존재하지 않고 P2P망 내의 참여자들에게 모든 거래 목록이 분산 저장되어 거래가 발생할 때마다 지속적으로 갱신되는 디지털 원장
- **Hash(해시)**: 임의의 길이의 입력 데이터나 메시지를 고정된 길이의 값이나 키로 변환하는 것
- **양자 암호키 분배(QKD;Quantum Key Distribution)**: 양자 통신을 위해 비밀키를 분배하여 관리하는 기술로, 두 시스템이 암호 알고리즘 동작을 위한 비밀키를 안전하게 공유하기 위해 양자 암호키 분배 시스템을 설치하여 운용하는 방식으로 활용
- **프라이버시 강화 기술(PET; Privacy Enhancing Technology)**: 개인정보 위험 관리 기술로, 다양한 사용자 프라이버시 보호 기술을 통칭함
- **디지털 저작권 관리(DRM;Digital Rights Management)**: 인터넷이나 기타 디지털 매체를 통해 유통되는 데이터의 저작권을 보호하기 위해 데이터의 안전한 배포를 활성화하거나 불법 배포를 방지하기 위한 시스템
- **공통 평가 기준(CC; Common Criteria)**: 정보화 순기능 역할을 보장하기 위해 정보화 제품의 정보보호 기능과 이에 대한 사용 환경 등급을 정한 기준
- **개인정보 영향평가 제도(PIA;Privacy Impact Assessment)**: 개인 정보를 활용하는 새로운 정보시스템의 도입 및 기존 정보시스템의 중요한 변경 시 시스템의 구축, 운영이 기업의 고객은 물론 국민의 사생활에 미칠 영향에 대해 미리 조사, 분석, 평가하는 제도
- **Grayware(그레이웨어) **: 소프트웨어를 제공하는 입장에서는 악의적이지 않은 유용한 소프트웨어라고 주장할 수 있지만 사용자 입장에서는 유용할 수도 있고 악의적일 수도 있는 애드웨어(광고), 트랙웨어(스파이웨어), 악성 공유웨어를 말함 (정상적인 소프트웨어의 이미지인 백색과 악성 소프트웨어의 이미지인 흑색의 중간(회색)에 해당)
- **Mashup(매시업)**: 웹에서 제공하는 정보 및 서비스를 이용하여 새로운 소프트웨어나 서비스, 데이터베이스 등을 만드는 기술 (→ 콘텐츠를 조합하여 하나의 서비스로 제공하는 웹 사이트 또는 애플리케이션)
- **리치 인터넷 애플리케이션(RIA; Rich Internet Application)**: 플래시 애니메이션 기술과 웹 서버 애플리케이션 기술을 통합하여 기존 HTML보다 역동적인 웹페이지를 제공하는 신개념의 플래시 웹페이지 제작 기술
- **Semantic Web(시맨틱 웹)**: 컴퓨터가 사람을 대신하여 정보를 읽고 이해하고 가공하여 새로운 정보를 만들어 낼 수 있도록 이해하기 쉬운 의미를 가진 차세대 지능형 웹
- **Vaporware(증발품)**: 판매 계획 또는 배포 계획은 발표되었으나 실제로 고객에게 판매되거나 배포되지 않고 있는 소프트웨어
- **오픈 그리드 서비스 아키텍처(OGSA;Open Grid Service Architecture)**: 애플리케이션 공유를 위한 웹 서비스를 그리드 상에서 제공하기 위해 만든 개방형 표준
- **서비스 지향 아키텍처(SOA;Service Oriented Architecture)**: 기업의 소프트웨어 인프라인 정보시스템을 공유와 재사용이 가능한 서비스 단위나 컴포넌트 중심으로 구축하는 정보기술 아키텍처. 정보를 누구나 이용 가능한 서비스로 간주하고 연동과 통합을 전제로 아키텍처를 구축
- **서비스형 소프트웨어(SaaS; Software as a Service)**: 소프트웨어의 여러 기능 중에서 사용자가 필요로 하는 서비스만 이용할 수 있도록 한 소프트웨어 (cf) 서비스형 인프라(IaaS), 서비스형 플랫폼(PaaS))
- **Software Escrow(소프트웨어 에스크로, 임치)**: 소프트웨어 개발자의 지식재산권을 보호하고 사용자는 저렴한 비용으로 소프트웨어를 안정적으로 사용 및 유지보수 받을 수 있도록 소스 프로그램과 기술 정보 등을 제 3의 기관에 보관하는 것
- **복잡 이벤트 처리(CEP;Complex Event Processing)**: 실시간으로 발생하는 많은 사건들 중 의미가 있는 것만을 추출할 수 있도록 사건 발생 조건을 정의하는 데이터 처리 방법
- **Digital Twin(디지털 트윈)**: 현실속의 사물을 소프트웨어로 가상화 한 모델로, 현실속의 사물을 대신해 컴퓨터 등 가상세계에서 다양한 상황을 모의 실험하기 위한 용도로 사용하는 기술
- **증강 현실(AR; Augmented Reality)**: 실제 촬영한 화면에 가상의 정보를 부가하여 보여주는 기술, 혼합현실(MR; Mixed Reality)이라고도 부름
- **가상 현실(VR; Virtual Reality)**: 컴퓨터 등을 사용한 인공적인 기술로 만들어낸 실제와 유사하지만 실제가 아닌 어떤 특정한 환경이나 상황 혹은 그 기술 자체를 의미함
- **TensorFlow**: 다양한 작업에 대해 데이터 흐름 프로그래밍을 위한 오픈소스 소프트웨어 라이브러리. 심볼릭 수학 라이브러리이자, 인공 신경망같은 기계 학습 응용프로그램 및 딥러닝에도 사용
- **SSO(Single Sign-On)**:  시스템이 몇 대가 되어도 하나의 시스템에서 인증에 성공하면 다른 시스템에 대한 접근권한도 얻는 시스템
- **OWASP**:  오픈소스 웹 애플리케이션 보안 프로젝트로서 주로 웹을 통한 정보 유출, 악성 파일 및 스크립트, 보안 취약점 등을 연구하는 곳
- **PaaS-TA**:  국내 IT 서비스 경쟁력 강화를 목표로 개발되었으며 인프라 제어 및 관리 환경, 실행 환경, 개발 환경, 서비스 환경, 운영환경으로 구성되어 있는 개방형 클라우드 컴퓨팅 플랫폼
- **BaaS(Blockchain as a Service)**: 블록체인 캐발환경을 클라우드로 서비스하는 개념
- **Docker**: 리눅스의 응용 프로그램들을 프로세스 격리 기술들을 사용해 컨테이너로 실행하고 관리하는 오픈 소스 프로젝트
- **Scrapy**: Python으로 작성된 오픈소스 웹 크롤링 프레임워크. 웹 데이터를 수집하는 것을 목표로 설계

### 하드웨어 관련 신기술
- **고가용성(HA; High Availability)**: 긴 시간동안 안정적인 서비스 운영을 위해 장애 발생 시 즉시 다른 시스템으로 대체 가능한 환경을 구축하는 메커니즘 (Hot Standby(상시 대기 방식), Mutual Take-Over(상호 인수), Concurrent Access(동시적 접근))
	- **고가용성 솔루션(HACMP)**: 각 시스템 간에 공유 디스크를 중심으로 집단화하여 컴퓨터 클러스터로 엮어지게 만들고, 동시에 다수의 시스템을 클러스터로 연결(주로 2개의 서버)하는 방식 사용
	- **LAG(Link Aggregation Group)**: 링크 중 하나가 실패할 것을 대비하여 다중화를 제공하기 위해 여러 네트워크 연결을 병렬로 연결하는 여러가지 방식
	- **Load Balancer**: 하나의 인터넷 서비스가 발생하는 트래픽이 많을 때 여러 대의 서버가 분산처리하여 서버의 로드율 증가, 부하량, 속도저하 등을 고려하여 적절히 분산처리하여 해결해주는 서비스
- **3D Printing**: 대상을 평면에 출력하는 것이 아니라 손으로 만질 수 있는 실제 물체로 만들어 내는 것
- **4D Printing**: 특정 시간이나 환경 조건이 갖추어지면 스스로 형태를 변화시키거나 제조되는 자가 조립(Self-Assembly) 기술이 적용된 제품을 3D Printing하는 기술 의미
- **RAID(Redundant Array of Independant Disk)**: 여러 개의 하드디스크로 디스크 배열을 구성하여 파일을 구성하고 있는 데이터 블록들을 서로 다른 디스크들에 분산 저장해 디스크의 속도를 향상시키는 것
- **4K 해상도**: 차세대 고화질 모니터의 해상도를 지칭하는 용어
- **N-Screen(앤 스크린)**: N개의 서로 다른 단말기에서 동일한 콘텐츠를 자유롭게 이용할 수 있는 서비스 (→ PC, TV, 스마트폰에서 동일한 콘텐츠 이용)
-**Companion Screen(컴패니언 스크린)**: N Screen의 한 종류로, TV 방송 시청 시 방송 내용을 SNS를 통해 공유하며 추가적인 기능을 수행할 수 있는 스마트폰, 태블릿 PC 등을 의미 (→ 세컨드 스크린(Second Screen)  이라고도 불림)
- **Thin Client PC(신 클라이언트 PC)**: 하드디스크나 주변 장치 없이 기본적인 메모리만 갖추고 서버와 네트워크로 운용되는 개인용 컴퓨터. 기억장치를 따로 두지 않기 때문에 PC를 분실하더라도 정보가 유출될 우려가 없음
- **Phablet(패블릿)**: 폰(Phone)과 태블릿(Tablet)의 합성어로, 태블릿 기능을 포함한 5인치 이상의 대화면 스마트폰
- **C형 USB(Universal Serial Bus Type-C)**: 기존 A형 USB에 비하여 크기가 작고, 24핀으로 위아래의 구분이 없어 어느 방향으로든 연결 가능
- **MEMS(멤스; Micro-Electro Mechanical Systems)**: 초정밀 반도체 제조 기술을 바탕으로 센서, 액추에이터(Actuator) 등 기계 구조를 다양한 기술로 미세 가공하여 전기계적 동작을 할 수 있도록 한 초미세 장치
- **Trust-Zone Technology(트러스트존 기술)**: 하나의 프로세서 내에 일반 애플리케이션을 처리하는 일반 구역과 보안이 필요한 애플리케이션을 처리하는 보안 구역으로 분할하여 관리하는 하드웨어 기반의 보안 기술
- **M-DISC(엠디스크;Millennial DISC)**: 한 번의 기록만으로 자료를 영구 보관할 수 있는 광 저장 장치
- **Memristor(멤리스터)**: 메모리(Memory)와 레지스터(Register)의 합성어로, 전류의 방향과 양 등 기존의 경험을 모두 기억하는 특별한 소자. 전원 공급이 끊어졌을 때도 직전에 통과한 전류의 방향과 양을 기억하기 때문에 다시 전원이 공급되면 기존의 상태가 그대로 복원됨
- **One Seg**: 일본과 브라질에서 상용중인 디지털 TV 방송 기술의 일종

### 데이터베이스 관련 신기술
- **Big Data(빅데이터)**: 기존의 관리 방법이나 분석 체계로는 처리하기 어려운 막대한 양의 정형 또는 비정형 데이터 집합
- **Broad Data(브로드 데이터)**: 다양한 채널에서 소비자와 상호 작용을 통해 생성된, 이전에 사용하지 않거나 알지 못했던 새로운 데이터나, 기존 데이터에 새로운 가치가 더해진 데이터
- **Meta Data(메타 데이터)**: 일련의 데이터를 정의하고 설명해 주는 데이터. 데이터를 빠르게 검색하거나 내용을 간략하고 체계적으로 하기 위해 사용
- **Smart Data(스마트 데이터)**: 실제로 가치를 창출할 수 있는 검증된 고품질의 데이터
- **Digital Archiving(디지털 아카이빙)**: 디지털 정보 자원을 장기적으로 보존하기 위한 작업.  아날로그 콘텐츠는 디지털로 변환한 후 압축해서 저장하고, 디지털 콘텐츠도 체계적으로 분류하고 메타 데이터를 만들어 DB화하는 작업
- **Hadoop(하둡)**: 오픈 소스를 기반으로 한 분산 컴퓨팅 플랫폼. 일반 PC급 컴퓨터들로 가상화된 대형 스토리지를 형성. 다양한 소스를 통해 생성된 빅데이터를 효율적으로 저장하고 처리
- **Sqoop**: SQL to Hadoop의 약자로 Hadoop과 관계형 데이터베이스 간에 데이터를 전송할 수 있도록 설계된 오픈소스 소프트웨어
- **Tajo(타조)**: 오픈 소스 기반 분산 컴퓨터 플랫폼인 아파치 하둡(Apache Hadoop) 기반의 분산 데이터 웨어하우스 프로젝트. 대규모 데이터 처리와 실시간 상호 분석에 모두 사용 가능
- **Data Diet(데이터 다이어트)**: 데이터를 삭제하는 것이 아니라 압축하고, 중복된 정보는 중복을 배제하고, 새로운 기준에 따라 나누어 저장하는 작업
- **Data Warehouse(데이터 웨어하우스)**: 정보(Data)와 창고(Warehouse)의 합성어. 여러 시스템에 분산되어 있는 데이터를 주제별로 통합, 축적해 놓은 데이터베이스
- **Map Reduce(맵리듀스)**: 흩어져 있는 데이터를 연관성 있는 데이터 분류로 묶는 Mapping(매핑, 연결)작업을 수행한 후 중복 데이터를 제거하고 원하는 데이터를 추출하는 Reduce 작업을 수행하는 것
- **Data Mining(데이터 마이닝)**: 빅데이터 분석 기술 중 대량의 데이터를 분석하여 데이터 속에 내재되어 있는 변수 사이의 상호관례를 규명하여 일정한 패턴을 찾아내는 기법
- **Software Defined Storage**: 하드웨어에서 스토리지 소프트웨어를 분리하는 스토리지 아키텍처

### 보안 솔루션
- **방화벽(Firewall)**: 내부 네트워크에서 외부로 나가는 패킷은 그대로 통과시키고, 외부에서 내부 네트워크로 들어오는 패킷은 내용을 엄밀히 체크하여 인증된 패킷만 통과시키는 구조
- **침임 탐지 시스템(IDS; Intrusion Detection System)**: 컴퓨터 시스템의 비정상적인 사용, 오용, 남용 등을 실시간으로 탐지하는 시스템
- **침입 방지 시스템(IPS; Intrusion Prevention System)**: 방화벽과 침임 탐지 시스템을 결합한 것으로, 비정상적인 트래픽을 능동적으로 차단하고 격리하는 등의 방어 조치를 취하는 보안 솔루션
- **데이터 유출 방지(DLP; Data Loss Prevention)**: 내부 정보의 외부 유출을 방지하는 보안 솔루션으로, 사내 직원이 사용하는 PC와 네트워크상의 모든 정보를 검색하고 사용자 행위를 탐지, 통제해 사전 유출 방지
- **웹 방화벽(Web Firewall)**: 일반 방화벽이 탐지하지 못하는 SQL 삽입 공격, XSS(Cross-Site Scripting) 등의 웹 기반 공격을 방어할 목적으로 만들어진 웹 서버에 특화된 방화벽
- **VPN(Virtual Private Network, 가상 사설 통신망)**: 가상 사설 네트워크로서 인터넷 등 통신 사업자의 공중 네트워크와 암호화 기술을 이용하여 사용자가 마치 자신의 전용 회선을 사용하는 것처럼 하는 보안 솔루션
- **NAC (Network Access Control)**: 네트워크에 접속하는 내부 PC의 MAC 주소를 IP 관리 시스템에 등록한 후 일관된 보안 관리 기능을 제공하는 보안 솔루션. 내부 PC의 소프트웨어 사용 현황을 관리하여 불법적인 소프트웨어 설치를 방지
- **ESM(Enterprise Security Management)**: 방화벽, IDS, IPS, 웹 방화벽, VPN 등에서 발생한 로그 및 보안 이벤트를 통합하여 관리하는 보안 솔루션. 보안 솔루션 간의 상호 연동을 통해 종합적인 보완 관리 체계를 수립할 수 있음
- **SDP(Software Defined Perimeter)**: ‘블랙 클라우드’라고도 불리며, 2007년경 GIG의 네트워크 우선권에 따라 DISA에서 수행한 작업에서 발전한 컴퓨터 보안 접근 방식
- **이상 탐지 기법(Anomaly Detection)**: 일반적인(발견되고 정립된) 값과 다른 특이한 값이나 드문 사건을 탐지하는 기법
- **HIDS(Host-Based Intrusion Detection)**: 운영체제에 설정된 사용자 계정에 따라 어떤 사용자가 어떤 접근을 시도하고 어떤 작업을 했는지에 대한 기록을 남기고 추적
- **NIDS(Network-Based Intrusion Detection System)**: 네트워크 트래픽을 감시하여 서비스 거부 공격, 포트 스캔, 컴퓨터를 크랙하려는 시도 등과 같은 악의적인 동작들을 탐지하는 시스템. 대표적으로 Snort가 있음
- **Tripwire**: 크래커가 침입하여 백도어를 만들어 놓거나, 설정 파일을 변경했을 때 분석하는 도구
-  **스택가드(Stack Guard)**: 메모리상에서 프로그램의 복귀 주소와 변수사이에 특정 값을 저장해 두었다가 그 값이 변경되었을 경우 오버플로우 상태로 가정하여 프로그램 실행을 중단하는 기술
- **Honeypot**: 비정상적인 접근을 탐지하기 위해 의도적으로 설치해 둔 시스템. 크래커를 유인하여 프로그램 침입이 성공한 것처럼 속임으로써 공격에 대응할 수 있는 시간을 확보하고 정보를 수집
- **nmap**: 서버에 열린 포트 정보를 스캐닝해서 보안취약점을 찾는데 사용하는 도구

### 세션 하이재킹 탐지 방법
- 비동기화 상태 탐지: 서버와 시퀀스번호를 주기적으로 확인해 비동기화를 탐지
- ACK Strom 탐지: ACK 패킷이 급격히 증가하는 것을 탐지
- 패킷의 유실 및 재전송 증가 탐지
- 기대하지 않은 접속의 리셋

### 서비스 지향 아키텍처(SOA) 계층
- 표현 계층(Presentation)
- 프로세스 계층(Process)
- 서비스 계층(Service)
- 비즈니스 계층(Business)
- 영속 계층(Persistency)

### 백도어 탐지 방법
**현재 동작중인 프로세스 및 열린 포트 확인**
- 해커가 접근을 위해 실행시켜둔 프로세스가 있는지, 열어둔 포트가 있는지 확인함

**SetUID 파일 검사**
- SetUID 권한의 파일을 많이 사용하므로, SetUID 권한이 있는 파일들을 검사해봄

**무결성 검사**
- 침입자에 의해 변경된 파일이 있는지 검사해봄

**로그 분석**
- 침입자의 기록을 분석해 보면 누가, 어떠한 공격을 했는지 알 수 있음

**바이러스 및 백도어 탐지 툴 사용**
- 백신 등의 바이러스 탐지 툴을 사용해 찾음

## 미분류
- **책임 프로그래머 팀(Chief Programmer Teams)**
	- 전문화(Specialization)와 계층화(Hierarchy)의 핵심 개념으로 구성하는 중앙 집중형 팀
	- 민주적 팀보다는 커뮤니케이션 채널이 적어 신속하고 정확한 협업과 의사결정 가능
	- chief 프로그래머는 최고의 기술 전문가이어야 하고 프로젝트 관리도 능숙해야 함
	- 일반적인 소규모 프로젝트가 가장 많이 취하는 팀 구조
- DMZ(Demilitarized Zone): 조직의 내부 네트워크와 외부 네트워크 사이에 위치한 서브넷. 내부 네트워크와 외부 네트워크가 DMZ로 연결할 수 있도록 허용하면서도, DMZ 내의 컴퓨터는 오직 외부 네트워크에만 연결할 수 있도록 한다.
- Cent OS: 레드햇 엔터프라이즈 리눅스와 완전하게 호환되는 무료 기업용 리눅스 운영체제
- GPIB: 컴퓨터와 주변기기를 연결하기 위한 외부 버스의 일종으로, 비동기 병렬 전송방식을 갖고있음
- IEEE 488: 단거리 디지털 통신 버스
- IEEE 802.5(토큰링 근거리통신망 기술): OSI 모델의 데이터 링크 계층에서 쓰이는 근거리 통신망 프로토콜
- **PERT(Program Evaluation and Review Technique)**
	- 확률적인 추정치를 이용하여 단계중심의 확률적 모델을 전개
	- 최단기간에 목표를 달성하기 위함
- **CPM (Critical Path Method)**
	- 과거 실적이나 경험 등의 확정적 결과값을 이용하여 활동중심의 확정적 모델을 전개
	- 목표기일 단축과 비용 최소화를 달성하기 위함
	- 임계 경로 = 가장 긴 경로
- **소프트웨어 정의 데이터센터(SDDC : Software Defined Data Center)**
	- 컴퓨팅, 네트워킹, 스토리지, 관리 등을 모두 소프트웨어로 정의
	- 인력 개입 없이 소프트웨어 조작만으로 자동 제어 관리
	- 데이터센터 내 모든 자원을 가상화하여 서비스
- **AJAX(Asynchronous JavaScript and XML)**: JavaScript를 사용한 비동기 통신기술로 클라이언트와 서버 간에 XML 데이터를 주고 받는 기술
- ZIGBEE: 소형, 저전력 디지털 라디오를 이용해 개인 통신망을 구성하여 통신하기 위한 표준 기술이다. IEEE 802.15 표준을 기반으로 만들어졌다.
- Wm-Bus: 스택포스 스마트 계량기
- **Secure shell**: 네트워크 상의 다른 컴퓨터에 로그인하거나 원격 시스템에서 명령을 실행하고 다른 시스템으로 파일을 복사할 수 있도록 해 주는 응용 프로그램 또는 그 프로토콜
- Nimda: 2001년 9월에 발생한 컴퓨터 바이러스
- **Tribe Flood Network**: 다양한 DDoS 공격을 수행하는 일련의 컴퓨터 프로그램
- PIMS: 개인정보보호관리체계
- **외계인코드(Alien Code)**: 아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 프로그램
- **Brooks의 법칙**: 새로운 개발 인력이 진행중인 프로젝트에 투입될 경우 작업 적응 기간과 부작용으로 인해 빠른시간 내에 프로젝트는 완료될 수 없다.  
- EIGRP(강화 내부 경로 제어 통신 규약, Enhanced Interior Gateway Routing Protocol): 시스코사가 만든 원래의 IGRP를 기반으로 한 개방형 라우팅 프로토콜
- **FEP**: 입력되는 데이터를 컴퓨터의 프로세서가 처리하기 전에 미리 처리하여 프로세서가 처리하는 시간을 줄여주는 프로그램이나 하드웨어
- GPL: 자유 소프트웨어 재단에서 만든 자유 소프트웨어 라이선스
- Work Breakdown Structure: 프로젝트 관리와 시스템 공학 분야에서 프로젝트의 더 작은 요소로 분해시킨 딜리버러블 지향 분업 구조
- **Migration**:  기존 소프트웨어 시스템을 새로운 기술 또는 하드웨어 환경에서 사용할 수 있도록 변환하는 작업을 의미하는 것
- **YAML**: XML, C, 파이썬, 펄, RFC2822에서 정의된 e-mail 양식에서 개념을 얻어 만들어진 '사람이 쉽게 읽을 수 있는' 데이터 직렬화 양식. 인터페이스 간의 통신을 위해 이용되는 데이터 포맷
- **위험 분석(Risk Analysis)**: 프로젝트에 내재된 위험 요소를 인식하고 그 영향을 분석하여 이를 관리하는 활동으로서, 프로젝트를 성공시키기 위하여 위험 요소를 사전에 예측, 대비하는 모든 기술과 활동을 포함하는 것
- Stuxnet: 2010년 6월에 발견된 웜 바이러스
- **DPI(Deep Packet Inspection)**: OSI 7 Layer 전 계층의 프로토콜과 패킷 내부의 콘텐츠를 파악하여 침입 시도, 해킹 등을 탐지하고 트래픽을 조정하기 위한 패킷 분석 기술
- Kerberos: 티켓을 기반으로 동작하는 컴퓨터 네트워크 인증 암호화 프로토콜. 비보안 네트워크에서 통신하는 노드가 보안 방식으로 다른 노드에 대해 식별할 수 있게 허용
- **octet**: 8개의 비트가 한데 모인 것
- SNMP: IP 네트워크상의 장치로부터 정보를 수집 및 관리하며, 또한 정보를 수정하여 장치의 동작을 변경하는 데에 사용되는 인터넷 표준 프로토콜
- Clark-Wilson Integrity Model: 컴퓨팅 시스템의 무결성 정책을 지정하고 분석하기 위한 기초를 제공
- Chinese Wall Model: 상업적인 관점에서 충돌되는 정보 흐름 차단
{% endraw %}
