**JMeter**는 Apache에서 개발한 오픈소스 **성능 테스트 도구**로, 주로 부하 테스트, 스트레스 테스트, 성능 측정 등을 위해 사용됩니다. 특히 웹 애플리케이션과 웹 서버에 대한 테스트를 수행하는 데 많이 활용됩니다.

1. **다양한 프로토콜 지원**
    - HTTP, FTP, JDBC, JMS, SOAP, REST API 등 다양한 프로토콜에 대해 테스트를 할 수 있습니다.
    - 웹 애플리케이션뿐만 아니라 데이터베이스, 이메일 서버 등 다양한 시스템의 성능 테스트가 가능합니다.
2. **GUI와 CLI 지원**
    - GUI(그래픽 사용자 인터페이스)를 통해 쉽게 설정하고 테스트 결과를 시각적으로 분석할 수 있습니다.
    - CLI(명령어 기반 인터페이스)로 자동화된 성능 테스트를 실행할 수 있어 CI/CD 환경에서 유용하게 사용됩니다.
3. **다양한 성능 테스트 유형**
    - **부하 테스트(Load Testing)**: 사용자가 많을 때 시스템이 어떻게 반응하는지 평가합니다.
    - **스트레스 테스트(Stress Testing)**: 시스템이 한계에 도달할 때까지 부하를 주어 시스템의 안정성을 점검합니다.
    - **성능 테스트(Performance Testing)**: 시스템의 응답 시간, 처리량 등을 측정합니다.
    - **기능 테스트(Functionality Testing)**: 주로 API 테스트를 통해 시스템의 기능이 잘 작동하는지 확인할 수 있습니다.
4. **확장성**
    - 플러그인을 사용하여 JMeter의 기능을 확장할 수 있습니다.
    - 여러 대의 컴퓨터에서 테스트를 분산 실행하는 분산 테스트가 가능합니다.
5. **리포트 및 분석**
    - 테스트가 끝난 후에는 그래프, 표, 통계 등을 포함한 리포트를 제공하여 테스트 결과를 직관적으로 분석할 수 있습니다.

## 설치
JMeter는 Java로 작성된 도구이므로 **Java**가 설치되어 있어야 합니다.

JMeter 다운로드는 Apache JMeter 공식 웹사이트에서 가능합니다.
> https://jmeter.apache.org/

다운로드 후 압축을 풀고, `bin` 폴더 안에 있는 `jmeter.bat`(Windows) 또는 `jmeter`(Linux/Mac)를 실행합니다.

## Test Plan
- **Test Plan**은 테스트의 루트 구조입니다. JMeter에서 실행할 모든 테스트는 이 안에 포함됩니다.
- `Test Plan`을 마우스 오른쪽 버튼으로 클릭하고 `Add > Threads (Users) > Thread Group`을 선택합니다.

### 테스트 실행
1. 상단 메뉴에서 **Start** 버튼을 클릭하여 테스트를 실행합니다.
2. **View Results Tree** 또는 **View Results in Table**을 통해 요청과 응답을 확인할 수 있습니다.

비활성화된 쓰레드 그룹은 테스트되지 않습니다. (쓰레드 그룹의 컨텍스트 메뉴에서 활성 여부를 토글할 수 있습니다.)

### 결과 초기화
1. **Clear** 버튼을 누르면 초기화됩니다. (리스너에서 우클릭 또는 상단 바 버튼)
2. 상단 바의 **Clear All** 버튼을 누르면 모든 리스너가 초기화됩니다.

## Thread Group
**Thread Group**은 테스트할 사용자 그룹을 정의합니다. (예: 100명의 가상 사용자를 설정)
- **Number of Threads (Users)**: 테스트할 가상 사용자 수
- **Ramp-Up Period**: 모든 사용자 요청을 처리할 시간
- **Loop Count**: 테스트 반복 횟수

이 세 가지 변수는 JMeter에서 **부하 테스트**를 진행할 때 중요한 요소로, 각기 다른 방식으로 테스트의 부하와 성능을 조정합니다.

### Number of Threads (Users)
이 값은 동시에 테스트를 수행할 가상 사용자(쓰레드)의 수를 설정합니다. 각 쓰레드는 독립적인 사용자를 시뮬레이션하여 HTTP 요청을 보냅니다.
- **높을수록 부하 증가**: 사용자 수가 많으면 시스템에 가해지는 부하가 커집니다. 예를 들어, 100명의 사용자가 동시에 요청을 보내면 서버가 이를 처리할 수 있는지 확인할 수 있습니다.
- **성능 한계 확인**: 서버의 성능 한계를 확인하는 데 유용합니다. 시스템이 많은 사용자를 동시에 처리할 수 있는지, 그에 따른 응답 시간이 어떻게 변하는지를 평가할 수 있습니다.
- **비용 증가**: 사용자 수가 많으면 테스트 실행 시간이 길어지고 서버 자원 소모가 많아져 비용이 증가할 수 있습니다.

### Ramp-Up Period
**Ramp-Up Period**는 설정된 가상 사용자들이 테스트를 시작하는 데 걸리는 시간입니다. 즉, 이 시간 동안 모든 사용자가 동시에 테스트를 시작하지 않고 순차적으로 시작됩니다. 예를 들어, `Ramp-Up Period`를 10초로 설정하고 쓰레드 수가 5개일 경우, 각 쓰레드는 10초 동안 점차적으로 시작됩니다. (즉, 첫 번째 쓰레드는 0초에 시작하고, 두 번째 쓰레드는 2초 후, 세 번째는 4초 후 시작되는 방식입니다.)
- **짧을수록 갑작스러운 부하**: Ramp-Up Period가 짧으면 많은 사용자가 짧은 시간 안에 시작되므로 서버에 갑작스러운 부하를 주게 됩니다. 이는 서버의 성능을 급격히 테스트할 수 있지만, 실제 서비스에서는 이와 같은 급격한 부하가 발생하지 않을 수 있으므로 현실적이지 않을 수 있습니다.
- **길수록 부하가 점진적으로 증가**: Ramp-Up Period가 길면 사용자가 점진적으로 추가되므로 서버에 가해지는 부하가 서서히 증가합니다. 이는 서버가 점진적으로 성능을 발휘할 수 있게 하여 안정적인 성능을 평가하는 데 유용합니다.

### Loop Count
**Loop Count**는 각 가상 사용자가 요청을 반복하는 횟수입니다. 예를 들어, Loop Count가 5라면 각 사용자는 5번 HTTP 요청을 반복하게 됩니다.
- **높을수록 테스트 시간 증가**: Loop Count가 많으면 테스트가 길어지며, 각 가상 사용자가 반복적으로 요청을 보내므로 서버에 더 많은 부하를 줄 수 있습니다.
- **긴 테스트 시간**: 반복 횟수가 많으면 시스템의 **장기적인 안정성**을 테스트할 수 있습니다. 예를 들어, 시스템이 지속적인 부하에 얼마나 잘 대응하는지(메모리 누수나 성능 저하 등이 발생하지 않는지) 확인할 수 있습니다.
- **높은 부하**: Loop Count가 높으면 실제 사용자 요청과 비슷한 시나리오를 더 잘 재현할 수 있으며, 서버가 지속적인 요청을 어떻게 처리하는지 살펴볼 수 있습니다.

### 테스트 시나리오
- **부하 테스트**: `Number of Threads`를 증가시키고 `Ramp-Up Period`를 짧게 설정하면 갑작스러운 부하를 서버에 가할 수 있습니다. `Loop Count`를 높이면 서버가 여러 번의 요청을 처리하는 동안 성능이 어떻게 변하는지 확인할 수 있습니다.
- **성능의 피크 테스트**: `Number of Threads`와 `Ramp-Up Period`를 적절히 설정하면 성능의 한계를 테스트할 수 있습니다. 이 경우, 서버가 많은 사용자를 동시에 처리할 수 있는지, 그리고 트래픽 폭주 시 성능 저하가 어떻게 발생하는지 볼 수 있습니다.
- **지속적인 부하 테스트**: `Loop Count`를 높이고 `Ramp-Up Period`를 길게 설정하면 부하가 점진적으로 증가하는 시나리오를 만들 수 있습니다. 이는 장기적인 안정성을 확인하고 서버가 지속적으로 성능을 발휘하는지 테스트하는 데 유용합니다.

## Sampler
**Sampler**는 **JMeter**에서 실제로 테스트할 요청을 보내는 **구성 요소**입니다. Sampler는 테스트 계획에서 특정 작업을 수행하는 단위를 의미하며, JMeter가 서버나 애플리케이션에 요청을 보내고 응답을 받아오는 역할을 합니다.

### HTTP Request Sampler
HTTP(S) 요청을 보내는 데 사용됩니다. 웹 애플리케이션이나 RESTful API 테스트에 주로 사용됩니다. 요청의 URL, 메서드(GET, POST 등), 파라미터, 헤더 등을 설정할 수 있습니다.
- **Server Name or IP**: 테스트할 서버의 주소 (예: `www.example.com`)
- **Port Number**: 서버 포트 (80은 기본 HTTP 포트)
- **Method**: HTTP 메서드 (GET, POST 등)
- **Path**: 요청할 URL 경로 (예: `/api/v1/users`)

Header는 Config의 HTTP Header Manager에서 설정할 수 있습니다.

Body Data에서 body를 직접 작성할 수 있습니다. `"${}"`로 감싸서 변수를 전달할 수 있습니다.
```
{  
    "userId": "${userId}",  
    "date": "2025-03-01"  
}
```

### JDBC Request Sampler
데이터베이스에 쿼리를 실행하는 데 사용됩니다. MySQL, Oracle 등 다양한 데이터베이스를 테스트할 수 있습니다.
- 데이터베이스 연결 정보와 SQL 쿼리를 설정하여 데이터베이스 작업의 성능을 측정합니다.

### FTP Request Sampler
FTP 서버와의 파일 전송 테스트에 사용됩니다.
- FTP 서버 주소, 포트, 사용자 정보 및 파일 업로드/다운로드 등을 설정합니다.

### JMS Request Sampler
JMS(Java Message Service) 메시지 큐와의 상호작용을 테스트하는 데 사용됩니다.
- JMS 서버 주소, 메시지 유형, 큐 등을 설정합니다.

### WebSocket Request Sampler
WebSocket 프로토콜을 통해 실시간 데이터 전송 테스트를 할 수 있습니다.
- WebSocket 서버와의 연결 설정, 메시지 전송 등을 정의합니다.

### Mail Request Sampler
이메일 송수신을 테스트할 수 있는 Sampler입니다.
- SMTP 서버 설정 및 이메일 내용, 수신자 등을 설정합니다.

### TCP Sampler
TCP 소켓 연결을 통해 테스트할 수 있는 Sampler입니다.
- 서버와 포트 정보, 메시지 보내기 및 응답을 처리하는 방법을 설정합니다.

## Assertion
**Assertion**은 요청의 결과가 예상한 대로 반환되었는지 확인하는 검증 도구입니다. 즉, **API 응답**이나 **서버의 처리 결과**가 올바른지 체크하는 데 사용됩니다. Assertion을 사용하면, 특정 조건을 만족하지 않는 응답에 대해 **테스트 실패**를 기록할 수 있어 테스트가 정상적으로 수행되고 있는지 확인할 수 있습니다.
- **성능에 미치는 영향**: Assertion을 많이 추가하면 성능에 영향을 미칠 수 있습니다. 특히 많은 사용자 수를 테스트할 경우 응답을 검증하는 과정에서 성능이 저하될 수 있습니다.
- **필요한 조건만 설정**: 너무 많은 Assertion을 추가하면 테스트가 복잡해지고, 불필요한 검증으로 인해 테스트가 오래 걸릴 수 있습니다.

### Response Assertion
응답 본문(Body), 응답 코드, 응답 메시지 등 특정 응답 데이터가 예상하는 값과 일치하는지 확인합니다.
- HTTP 응답 본문에 특정 텍스트가 포함되어 있는지 확인 (`"OK"`, `"Success"` 등).
- 응답 코드가 `200`인지 확인.
- 응답 시간의 범위가 지정된 값 내에 있는지 확인.

### Size Assertion
응답의 크기(바이트 단위)가 예상한 범위 내에 있는지 확인합니다.
- 응답 본문 크기가 100KB 이상인지를 체크.
- 응답의 크기가 1MB 이하인지를 확인.

### Duration Assertion
요청 응답 시간이 특정 기간 내에 완료되었는지 검증합니다.
- 응답 시간이 2초 이하인지 확인.

### XML Assertion
XML 응답이 올바른 XML 형식인지, 또는 특정 XML 요소가 포함되어 있는지 확인합니다.
- XML 응답에서 `<status>Success</status>`가 포함되어 있는지 체크.

### JSON Assertion
JSON 응답이 유효한 JSON 형식인지, 또는 특정 JSON 필드가 예상된 값인지 검증합니다.
- JSON 응답에서 `"status": "OK"`가 포함되어 있는지 확인.

### HTML Assertion
HTML 응답이 올바른 HTML 형식인지 검증합니다.
- 응답이 정상적인 HTML 페이지인지 체크하거나, 특정 HTML 태그가 포함되어 있는지 확인.

## Listener
**Listener**는 테스트 결과를 수집하고 표시하는 구성 요소입니다. 테스트가 실행된 후, Listener는 요청의 응답 데이터를 수집하여 다양한 형식으로 결과를 시각화하거나 로그로 기록합니다.

### View Results Tree
**각 요청의 세부 결과**를 트리 형태로 보여줍니다. 요청을 보내고 응답을 받은 후, 응답 본문, 헤더, 상태 코드 등을 확인할 수 있습니다.

### Summary Report
**테스트의 요약된 결과**를 표시합니다. 총 요청 수, 성공적인 요청 수, 실패한 요청 수, 평균 응답 시간 등 성능 관련 데이터를 제공합니다. 시간의 단위는 밀리초(ms)입니다.
- **# Samples**: 
	- 해당 요청에 대해 수행된 샘플(즉, 테스트 요청)의 수입니다. 예를 들어, 1000개의 스레드가 있는 경우 `# Samples` 값은 1000이 됩니다.
- **Average**: 
	- 평균 응답 시간으로, 요청에 대한 응답 시간이 평균적으로 얼마나 걸리는지 보여줍니다.
	- 서버가 평균적으로 얼마나 빠르게 응답하는지를 평가합니다.
- **Min**: 
	- 응답 시간의 최소값으로, 테스트 중 가장 빠른 응답 시간을 의미합니다.
	- 서버가 가장 빠르게 응답한 사례를 확인할 수 있습니다.
- **Max**: 
	- 응답 시간의 최대값으로, 테스트 중 가장 느린 응답 시간을 의미합니다.
	- 서버 응답이 비정상적으로 오래 걸린 경우를 찾는 데 유용합니다. 성능 병목 지점을 확인할 수 있습니다.
- **Std. Dev.**: 
	- 응답 시간의 표준 편차로, 응답 시간이 평균에서 얼마나 벗어나는지를 나타냅니다.
	- 응답 시간이 일정한지, 아니면 변동성이 큰지를 평가하는 데 사용됩니다. 표준 편차가 크면 응답 시간이 불안정한 경우일 수 있습니다.
- **Error %**: 
	- 전체 요청 중 실패한 요청의 비율입니다. 실패한 요청의 수를 전체 요청 수로 나눈 값으로, 성능 테스트 중 오류가 얼마나 발생했는지를 나타냅니다.
	- 테스트 중 오류가 발생한 비율을 파악하여, 서버가 얼마나 안정적인지 평가할 수 있습니다. 높은 오류율은 시스템의 불안정성이나 문제를 의미할 수 있습니다.
- **Throughput**:
	- 초당 처리되는 요청의 수를 나타냅니다. `Throughput`은 시간당 또는 초당 처리되는 샘플의 수로 계산됩니다.
	- 서버가 초당 얼마나 많은 요청을 처리할 수 있는지 평가하는 데 사용됩니다. 높은 `Throughput` 값은 높은 성능을 의미합니다. `Throughput`은 "초당 처리량"이라고도 불립니다.
- **KB/sec**:
	- 초당 전송되는 데이터 양을 나타냅니다.
	- 서버의 대역폭 사용량을 모니터링할 때 유용합니다. 네트워크 성능 문제나 데이터 전송 속도가 중요한 경우 이를 평가할 수 있습니다.
- **Connect Time (ms)**:
	- 서버와 연결하는 데 걸린 시간입니다. 이 값은 서버와의 TCP 연결이 얼마나 빨리 설정되었는지 측정합니다.
	- 네트워크 연결 속도나 서버의 연결 처리 속도를 평가할 수 있습니다. 높은 연결 시간은 서버가 다른 클라이언트와의 연결을 처리하는 데 문제가 있을 수 있음을 나타냅니다.

### Aggregate Report
**다양한 성능 지표를 집계**하여 표시합니다. 각 요청에 대한 성공률, 평균 응답 시간, 초당 요청 처리 수 등을 집계할 수 있습니다.

- **Average**:
	- 전체 요청에 대한 평균 응답 시간으로, 모든 요청이 얼마나 평균적으로 처리되었는지를 보여줍니다.
	- 낮을수록 좋은 성능을 의미하지만, 평균이 적다고 해서 모든 요청이 빠르다는 보장은 없습니다. **극단적인 느린 요청들이 평균을 낮출 수 있기 때문**입니다.
- **Median**:
	- 응답 시간의 중간값으로, 평균과 비교할 때, 응답 시간이 어느 정도 고르게 분포했는지를 알 수 있습니다.
	- 평균보다 더 안정적인 지표로, **응답 시간의 대부분이 빠르게 처리되었는지 확인**하는 데 유용합니다. 평균보다 훨씬 더 정확한 성능 상태를 알 수 있습니다.
- **90% Line**:
	- 전체 요청 중 **90%의 요청이 해당 응답 시간 이하로 처리되었음**을 의미합니다. 성능이 90%의 요청에 대해 얼마나 잘 처리되고 있는지를 보여줍니다.
	- 90%의 요청이 적당한 시간 내에 응답을 받았다면, 전체 성능이 우수하다고 평가할 수 있습니다. 하지만 10%의 요청이 매우 느리다면 성능 문제가 있을 수 있음을 시사합니다.
- **95% Line**
	- 전체 요청 중 **95%의 요청이 해당 응답 시간 이하로 처리되었음**을 의미합니다. 95%의 요청이 빠르게 처리되었을 때 서버의 성능이 좋은 것으로 판단할 수 있습니다.
	- 95% Line은 성능의 대부분을 대표하며, 이를 초과하는 요청의 응답 시간이 불안정하거나 비효율적일 수 있음을 나타냅니다.
- **99% Line**
	- 전체 요청 중 **99%의 요청이 해당 응답 시간 이하로 처리되었음**을 의미합니다. 99%의 요청이 해당 응답 시간 내에 완료되었을 때, 성능이 매우 뛰어난 것으로 간주할 수 있습니다.
	- 이 지표는 극단적인 느린 응답 시간을 무시하고 **대부분의 요청이 얼마나 빠르게 처리되었는지**를 보여주기 때문에 **정상적인 요청 처리 속도를 파악**하는 데 유용합니다. 만약 99% Line이 너무 크다면 성능에 문제가 있다는 신호입니다.

### Aggregate Graph
다양한 집계 지표를 **그래프 형식으로 시각화**합니다.

### View Results in Table
요청 결과를 **테이블 형식**으로 보여줍니다. 요청, 응답 시간, 상태 코드 등 기본적인 정보를 표 형식으로 정리하여 보여줍니다. 각 **지표별로 정렬하여 확인**할 수 있습니다.
- **Connect Time**:
	- **클라이언트(즉, JMeter)가 서버와 통신을 시작하고 연결**을 설정하는 데 걸린 시간을 측정합니다.
	- **Connect Time**이 너무 길다면, 네트워크 지연이나 서버가 과부하 상태일 가능성이 높습니다. 이는 **네트워크 성능**이나 **서버 상태**를 점검할 필요가 있음을 시사합니다.

## Pre-Processor
JMeter에서 **Pre-Processor**는 테스트 실행 중 **HTTP 요청**이나 다른 샘플러가 실행되기 전에 수행할 작업을 정의하는 컴포넌트입니다.

1. **요청 전에 데이터 준비**: Pre-Processor는 각 테스트 요청마다 실행됩니다. 즉, JMeter에서 각 요청을 실행할 때마다 그 요청에 대해 미리 정의된 Pre-Processor가 실행되어 해당 요청에 필요한 데이터를 준비하거나 처리합니다.
2. **동적 데이터 처리**: 테스트 실행 시마다 동적으로 데이터를 생성하거나, 다른 요청의 결과를 바탕으로 후속 요청에 필요한 값을 추출하여 사용할 수 있습니다.
3. **스크립트 실행**: JavaScript, BeanShell, JSR223 등의 스크립트 언어를 사용하여 복잡한 작업을 수행할 수 있습니다. 예를 들어, 특정 계산을 통해 요청 파라미터를 동적으로 생성할 수 있습니다.

JMeter의 성능 측정 결과는 실제 요청과 응답의 성능에 대한 정보를 제공하므로, Pre-Processor의 실행 시간은 성능 결과에 포함되지 않습니다.

### JSR223 PreProcessor
`JSR223 PreProcessor`를 사용하여 JavaScript나 Groovy 등의 스크립트를 실행할 수 있습니다. 이 방법을 사용하면 각 스레드가 요청을 보내기 전에 필요한 처리를 동적으로 할 수 있습니다.

예시:
```javascript
// 예: 현재 시간을 'yyyy-MM-dd HH:mm:ss' 형식으로 구하기
var date = new Date();
var formattedDate = date.toISOString().substring(0, 19).replace("T", " ");

// 'formattedDate' 변수를 JMeter 변수로 설정
vars.put("currentDate", formattedDate);
```

위 코드에서는 JavaScript를 사용하여 현재 시간을 구하고, 이를 `"currentDate"`라는 JMeter 변수로 설정합니다. 이후 HTTP 요청 등에서 `${currentDate}`를 사용하여 해당 값을 참조할 수 있습니다.

#### 변수 사용
JSR223 PreProcessor에서 설정한 변수는 이후 테스트 샘플러에서 사용할 수 있습니다. 예를 들어, HTTP 요청에서 다음과 같이 사용할 수 있습니다:

```http
Authorization: Bearer ${currentDate}
```

### User Defined Variables
테스트 중에 자주 사용할 변수들을 설정하여, 요청 전에 이 변수들을 정의하고 사용할 수 있습니다.

#### `__threadNum`
`__threadNum`은 JMeter에서 제공하는 함수로, **현재 실행 중인 스레드의 번호**를 반환하는 기능을 합니다. 이 함수는 각 스레드(즉, 가상 사용자의 실행 인스턴스)에 고유한 값을 할당할 때 유용하게 사용할 수 있습니다.

### HTTP Request Defaults
HTTP 요청을 실행하기 전에 공통된 요청 속성(예: 기본 URL, 포트 등)을 설정할 수 있습니다.

## Config
### CSV Data Set Config
`CSV Data Set Config`는 CSV 파일을 읽어 각 행을 변수로 바꾸고 이를 테스트에서 사용할 수 있게 해줍니다.

- **Filename**: CSV 파일의 경로를 입력합니다. 예를 들어, `C:\Users\yourname\Documents\users_data.csv`와 같은 경로입니다.
- **Variable Names**: CSV 파일의 각 열에 해당하는 변수 이름을 입력합니다. 예를 들어, `user_id,user_pw,user_name,email,phone,created_at`와 같이 입력합니다.
- **Delimiter**: CSV 파일에서 열을 구분하는 구분자를 입력합니다. 일반적으로 쉼표(,)를 사용하므로, 기본값인 `,`을 사용합니다.
- **Recycle on EOF?**: 이 값을 `True`로 설정하면 파일의 끝에 도달했을 때 다시 처음부터 읽습니다. 기본값은 `True`입니다.
- **Stop thread on EOF?**: `True`로 설정하면 파일의 끝에 도달했을 때 쓰레드가 멈춥니다. 기본값은 `False`입니다.
- **Sharing Mode**: 여러 쓰레드에서 CSV 파일을 공유할지 여부를 설정합니다. `All Threads`로 설정하면 모든 쓰레드에서 같은 데이터를 사용하게 됩니다.

예를 들어, **HTTP Request**에서 CSV 데이터를 사용하여 로그인 API를 테스트하려면:
1. **Thread Group** 안에 **HTTP Request**를 추가합니다.
2. HTTP Request의 **Username** 필드에 `${user_name}`을 입력하고, **Password** 필드에 `${user_pw}`를 입력합니다.
3. 요청이 실행되면 각 쓰레드는 CSV에서 읽어온 `user_name`과 `user_pw`를 사용하여 로그인 API를 호출합니다.

**CSV 파일 (users.csv):**
```
username, password
user1, pass1
user2, pass2
user3, pass3
```

각 스레드가 **순차적으로 CSV 파일에서 데이터**를 읽어들입니다. 스레드 수 (Number of Threads)가 3이라면, 각 스레드는 CSV의 데이터를 하나씩 차례대로 사용합니다. 스레드가 5개이고 CSV에 3개의 데이터만 있다면, 첫 번째, 두 번째, 세 번째 스레드는 `user1`, `user2`, `user3`을 각각 사용하고, 네 번째, 다섯 번째 스레드는 다시 `user1`, `user2` 데이터를 사용합니다.

### Random Variable
`Random Variable`은 지정된 범위 내에서 랜덤한 값을 생성하고, 그 값을 JMeter 변수로 설정합니다. 
- **Variable Name**: 생성할 랜덤 값의 변수 이름을 설정합니다. 예를 들어, `userId`를 설정하면 `userId`라는 변수로 랜덤 값을 사용할 수 있습니다.
- **Minimum Value**: 생성할 랜덤 값의 최소값을 설정합니다.
- **Maximum Value**: 생성할 랜덤 값의 최대값을 설정합니다.
- **Random Seed** (선택 사항): 랜덤 값 생성의 시드를 지정하여 결과를 반복 가능하게 만듭니다. 생략하면 매번 다른 랜덤 값이 생성됩니다.
- **Per User**: 각 스레드(사용자)마다 다른 랜덤 값을 생성할지 여부를 설정합니다. 이 옵션을 활성화하면 각 스레드에서 독립적인 랜덤 값을 생성합니다.
- **Use Timestamps**: 랜덤 값 생성에 현재 시간을 포함할지 여부를 설정합니다.
- **Formula**: 랜덤 값에 대한 특정 수식 또는 범위 등을 설정할 수 있습니다. 예를 들어, `__Random(1,100)`과 같이 사용하여 범위 내의 값을 생성할 수 있습니다.

### HTTP Header Manager
HTTP 요청의 Header를 설정합니다.

## 참고
### 기본 변수 목록
> https://jmeter.apache.org/usermanual/functions.html

