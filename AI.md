# AI
인공지능(Artificial Intelligence, AI)은 컴퓨터 프로그램이 인간과 유사한 지능을 구현하고 인간의 학습, 추론, 문제 해결 등의 능력을 모방하도록 하는 기술 또는 시스템을 말합니다. 인공지능은 다양한 분야에서 사용되며, 기계 학습, 자연어 처리, 컴퓨터 비전 등과 같은 하위 분야를 포함합니다.

## 머신러닝 (Machine Learning)
머신러닝(Machine Learning)은 컴퓨터 시스템이 데이터에서 학습하고 패턴을 발견하여 문제를 해결하거나 작업을 수행할 수 있는 능력을 갖추는 인공지능 분야입니다. 머신러닝은 명시적인 프로그래밍 없이도 컴퓨터가 데이터에서 학습하고 개선할 수 있도록 하는 기술입니다. 머신러닝은 이미지 및 음성 인식, 자연어 처리, 의료 진단, 금융 예측, 제조 및 로봇 공학 등과 같은 다양한 분야에서 활용되고 있습니다.

### 지도 학습 (Supervised Learning)
지도 학습은 기계 학습의 한 유형으로, 입력과 출력 쌍으로 구성된 훈련 데이터를 사용하여 모델을 학습하는 방법입니다. 이 학습 방법을 통해 입력과 해당 출력 간의 관계를 학습하고, 새로운 입력에 대해 정확한 출력을 예측할 수 있습니다. 지도 학습은 명확한 목표 출력값이 있는 문제에서 유용하며, 다양한 분야에서 널리 사용되고 있습니다. 예를 들어, 이미지와 해당하는 레이블(예: 고양이 또는 개)이 있는 경우, 지도학습 모델은 이미지를 입력으로 사용하여 해당하는 레이블을 예측할 수 있습니다.

지도 학습에는 크게 분류(Classification)와 회귀(Regression) 2가지 유형이 있습니다.

#### 회귀 문제 (Regression Problem)
회귀 문제는 종속 변수와 한 개 이상의 독립 변수 간의 관계를 모델링하고, 주어진 입력에 대한 출력 값을 예측하는 문제를 말합니다. 즉, 회귀 문제에서는 입력 변수의 값에 따라 연속형 출력 변수(종속 변수)의 값을 예측하려는 것입니다.

회귀 문제의 예시는 다음과 같습니다:

1.  부동산 가격 예측: 주택의 크기, 위치, 시설 등 여러 요소를 기반으로 주택의 가격을 예측하는 문제.
2.  주가 예측: 주식 시장에서 과거 주가 데이터와 다양한 요인을 기반으로 미래 주가를 예측하는 문제.
3.  수요 예측: 제품의 판매량을 예측하기 위해 마케팅 지출, 경쟁사의 활동 등의 변수를 사용하는 문제.
4.  날씨 예측: 기상 조건과 지리적 요인을 기반으로 향후 기온, 강우량 등을 예측하는 문제.

##### 선형 회귀 (Linear Regression)
선형 회귀는 종속 변수와 한 개 이상의 독립 변수 간의 선형 관계를 모델링하는 지도 학습 알고리즘입니다. 주어진 데이터셋을 사용하여 독립 변수와 종속 변수 간의 관계를 최적으로 설명하는 선형 함수를 찾는 것이 목표이며, 주로 연속형 종속 변수를 예측하는 데 사용됩니다.

선형 회귀 모델은 일반적으로 다음과 같은 형태를 가집니다:

$$
y = w_0 + w_1x_1 + w_2x_2 + ... + w_nx_n
$$

- $y$는 종속 변수(예측하려는 값)입니다.
- $x$는 독립 변수(입력 특성)입니다.
- $w$는 회귀 계수(가중치)이며, 이 값들은 학습 과정에서 데이터로부터 추정됩니다.

선형 회귀는 주어진 입력 데이터를 사용하여 회귀 계수를 학습하는 과정을 거칩니다. 이를 위해 일반적으로 최소 제곱법(Least Squares Method)이나 경사 하강법(Gradient Descent)과 같은 최적화 알고리즘이 사용됩니다.

#### 분류 문제 (Classification)
분류 문제는 여러 개의 클래스 중 하나를 예측하는 문제를 말합니다. 이진 분류는 분류 문제의 한 유형으로, 두 개의 클래스 중 하나를 예측하는 문제입니다. 이진 분류는 입력 데이터가 두 개의 서로 다른 범주 중 하나에 속하는지를 판별하는 문제를 다룹니다.

예를 들어, 스팸 메일 필터링은 이진 분류 문제의 한 예입니다. 여기서는 이메일이 "스팸"인지 "정상"인지를 판별하는 문제입니다.

이진 분류에서는 주로 다음과 같은 표현을 사용합니다:
- Positive(양성): 관심 있는 클래스 또는 이벤트를 나타냅니다. 예를 들어, 스팸 메일이 양성 클래스가 될 수 있습니다.
- Negative(음성): 관심 없는 클래스 또는 이벤트를 나타냅니다. 예를 들어, 정상 메일이 음성 클래스가 될 수 있습니다.

이진 분류 모델은 주어진 입력 데이터의 특성을 기반으로 이러한 클래스 중 하나를 예측하는 것을 목표로 합니다. 예측은 보통 확률 값으로 나타나며, 일반적으로 임계값(threshold)을 설정하여 확률이 이 임계값을 넘으면 양성 클래스로 분류되도록 합니다.

##### 로지스틱 회귀 (Logistic Regression)
로지스틱 회귀는 이진 분류 문제를 해결하는 지도 학습 알고리즘 중 하나입니다. 로지스틱 회귀는 간단하면서도 효과적인 분류 모델로, 이진 분류 문제를 해결하는 데 널리 사용됩니다. (이름은 회귀로 되어 있지만, 실제로는 선형 회귀와는 다르며, 분류 문제를 해결하기 위한 모델입니다.)

로지스틱 회귀는 입력 변수와 가중치의 선형 결합을 로지스틱 함수(Sigmoid Function)에 적용하여 0과 1 사이의 확률을 예측합니다. 이 확률은 주어진 입력 변수가 어떤 클래스에 속할 확률을 나타냅니다.

로지스틱 함수는 다음과 같이 정의됩니다:

$$
σ(z) = \frac{1}{1 + e^{-z}}
$$

여기서, $z$는 입력 변수와 가중치의 선형 결합입니다. ($z = w_0 + w_1x_1 + w_2x_2 + ... + w_nx_n$)

로지스틱 회귀 모델은 주어진 학습 데이터를 사용하여 가중치를 학습시킵니다. 학습된 모델을 사용하여 새로운 입력 데이터에 대한 클래스를 예측할 수 있습니다. 예측된 확률이 0.5보다 크면 양성 클래스로 분류되고, 그렇지 않으면 음성 클래스로 분류됩니다.

### 비지도 학습 (Unsupervised Learning)
비지도 학습은 기계 학습의 한 종류로, 레이블이 지정되지 않은 데이터를 사용하여 패턴을 발견하고 데이터를 클러스터링하거나 차원을 축소하는 등의 작업을 수행하는 알고리즘입니다. 이러한 알고리즘은 주어진 데이터의 구조를 이해하고 특징을 추출하기 위해 사용됩니다.

### 강화 학습 (Reinforcement Learning)
강화 학습은 기계 학습의 한 분야로, 특정 상황에서 어떤 행동을 취할지 결정하는 것을 목표로 합니다. 강화 학습은 게임 플레이, 자율 주행 자동차, 로봇 제어, 자원 관리, 금융 투자 등 다양한 분야에서 활용되고 있습니다.

1. **에이전트(Agent)**:
	- 의사 결정을 내리고 행동을 수행하는 주체입니다.
	- 강화 학습의 목표는 에이전트가 최적의 행동을 학습하도록 하는 것입니다.
2. **환경(Environment)**:
	- 에이전트가 상호 작용하는 대상입니다.
	- 에이전트가 취한 행동에 따라 상태가 변하고, 환경은 보상 신호를 제공하여 에이전트에게 피드백을 제공합니다.
3. **상태(State)**:
	- 에이전트와 환경의 상호 작용에서의 현재 상황을 나타냅니다.
	- 강화 학습에서는 상태를 기반으로 행동을 선택하고 보상을 받습니다.
4. **행동(Action)**:
	- 에이전트가 특정 상태에서 취할 수 있는 행동의 집합입니다.
	- 에이전트는 현재 상태에 따라 가능한 행동 중에서 선택합니다.
5. **보상(Reward)**:
	- 행동에 대한 피드백으로, 에이전트가 특정 행동을 수행했을 때 받는 값입니다.
	- 목표는 누적 보상을 최대화하는 최적의 정책을 학습하는 것입니다.

## 딥러닝 (Deep Learning)
딥러닝(Deep Learning)은 인공 신경망을 사용하여 복잡한 패턴을 학습하고 데이터를 모델링하는 머신러닝의 구현 방법 중 하나입니다. 딥러닝은 대규모 데이터셋에서 직접 특징을 추출하고 다층적인 구조를 사용하여 데이터의 추상적인 표현을 학습합니다. 이를 통해 딥러닝 모델은 사람보다 정확하게 이미지, 음성, 텍스트 등의 데이터를 처리하고 분류할 수 있습니다.

딥러닝의 핵심 구성 요소는 인공 신경망입니다. 인공 신경망은 생물학적 뉴런의 작동 방식에서 영감을 받아 구성된 모델로, 입력 데이터를 받아들이고 이를 처리하여 출력을 생성합니다. 딥러닝에서는 특히 심층 신경망(Deep Neural Networks)이라고도 불리는 깊은 신경망을 사용합니다. 이러한 심층 신경망은 여러 층(layer)으로 구성되어 있으며, 각 층은 이전 층의 출력을 입력으로 받아들입니다.

### vs 머신러닝
딥러닝과 머신러닝의 차이점은 다음과 같습니다.

1. **표현 학습 방법의 차이**:
    - **머신러닝**: 머신러닝은 데이터로부터 특징(feature)을 추출하고, 이러한 특징을 사용하여 모델을 학습합니다. 특징 엔지니어링(feature engineering)이 중요한 과정입니다.
    - **딥러닝**: 딥러닝은 데이터로부터 직접 특징을 학습합니다. 이를 통해 입력 데이터에서 유용한 표현을 자동으로 학습할 수 있습니다. 따라서 딥러닝은 특징 엔지니어링 과정을 크게 줄일 수 있습니다.
2. **모델의 구조적 차이**:
    - **머신러닝**: 머신러닝 모델은 주로 선형 모델, 결정 트리, SVM(Support Vector Machine) 등과 같은 상대적으로 간단한 알고리즘을 기반으로 합니다.
    - **딥러닝**: 딥러닝 모델은 다양한 신경망 아키텍처를 사용합니다. 이러한 신경망은 여러 층의 뉴런으로 구성되어 있으며, 복잡한 비선형 관계를 모델링할 수 있습니다.
3.  **학습 방법의 차이**:
    - **머신러닝**: 대부분의 머신러닝 알고리즘은 상대적으로 적은 수의 데이터로도 학습이 가능하며, 일반적으로 작은 데이터셋에 적합합니다.
    - **딥러닝**: 딥러닝은 대규모의 데이터셋과 많은 컴퓨팅 자원이 필요합니다. 일반적으로 많은 데이터를 사용하여 복잡한 모델을 학습하므로, 많은 시간과 계산 리소스가 필요합니다.

### 뉴런 (Neuron)
뉴런(Neuron)은 신경망의 기본적인 단위로, 정보를 처리하고 전달하는 역할을 합니다. 이러한 뉴런들이 모여서 신경망을 형성하며, 각 뉴런은 신경망의 계산과정에서 중요한 역할을 합니다.

가중치(weight)와 편향(bias)은 뉴런에서 사용되는 매개변수로, 입력 데이터와 뉴런 간의 연결을 특정 진행 방향으로 조절하고 신경망의 출력을 생성하는 데 사용됩니다.

1. **가중치(Weight)**:
	- 가중치는 입력 데이터와 함께 곱해지는 값으로, 해당 입력의 중요성을 나타냅니다.
	- 이미지 분류에서는 가중치가 각 픽셀의 중요도를 나타내고, 자연어 처리에서는 단어의 중요성을 나타냅니다.
2. **편향(Bias)**:
	- 편향은 각 뉴런에 더해지는 고정된 값으로, 해당 뉴런이 얼마나 쉽게 활성화되는지를 조절합니다.
	- 편향을 사용함으로써 신경망은 입력 데이터가 0인 경우에도 올바른 출력을 생성할 수 있습니다.

일반적으로 신경망에서 각 뉴런은 각각 고유한 가중치와 편향을 가집니다. 또한 각 뉴런과 이전 계층의 뉴런 간의 연결도 고유한 가중치와 편향을 가집니다.

따라서 신경망에서 각 뉴런마다 가중치와 편향은 해당 뉴런과 연결된 다른 뉴런과는 다른 값을 가지며, 이 값들은 학습 과정에서 업데이트됩니다. 이를 통해 네트워크는 입력 데이터와 가중치, 편향을 사용하여 패턴을 학습하고, 주어진 작업을 수행할 수 있습니다.

### 활성화 (Activation)
활성화 과정은 각 뉴런마다 입력된 데이터에 가중치를 곱하고 편향을 더한 후, 활성화 함수를 적용하는 과정입니다.

활성화 과정은 다음과 같습니다.
1. **가중치 합 계산**:
	- 입력된 값과 현재 뉴런의 가중치(weight)를 곱한 후, 편향(bias)을 더하여 가중치 합을 계산합니다.
2.  **활성화 함수 적용**:
	- 가중치 합을 계산한 후, 활성화 함수를 적용하여 뉴런의 출력을 생성합니다.
	- 활성화 함수를 통과한 값은 뉴런의 활성화 정도를 나타냅니다.

#### 활성화 함수(Activation Function)
활성화 함수는 데이터에 비선형성을 도입하고, 네트워크가 더 복잡한 함수를 모델링할 수 있도록 합니다.

주로 사용되는 활성화 함수는 다음과 같습니다:
- **ReLU(Rectified Linear Unit)**: 입력이 양수인 경우에는 그 값을 그대로 반환하고, 음수인 경우에는 0으로 변환합니다.
- **Leaky ReLU**: 입력이 음수인 경우에도 작은 기울기를 갖도록 ReLU를 변형한 함수입니다.
- **시그모이드(Sigmoid)**: 값의 범위를 0과 1 사이로 제한합니다.
- **하이퍼볼릭 탄젠트(Tanh)**: 값의 범위를 -1과 1 사이로 제한합니다.
- **소프트맥스(Softmax)**: 값을 각 클래스에 대한 확률로 변환합니다.

### 선형 (Linear)
선형 모델은 입력과 출력 사이의 관계를 직선으로 표현할 수 있는 모델입니다. 단순하고 계산이 빠르지만, 복잡한 패턴을 학습할 수 없습니다. 수학적으로, 선형 함수는 다음과 같이 정의됩니다:

$$
y = \mathbf{w} \cdot \mathbf{x} + b
$$

- $y$: 출력 값
- $\mathbf{w}$: 가중치 벡터
- $\mathbf{x}$: 입력 벡터
- $b$: 편향(bias)

선형 모델은 입력 값에 대한 가중치의 선형 결합으로 출력을 계산합니다. 이러한 모델은 직선적인 관계를 학습할 수 있으며, 입력 데이터와 출력 데이터가 선형적으로 분리될 수 있는 경우에만 유용합니다. 예를 들어, 선형 회귀나 로지스틱 회귀는 선형 모델에 해당됩니다.

### 비선형 (Non-linear)
비선형 모델은 입력과 출력 사이의 관계를 직선이 아닌 복잡한 곡선으로 표현할 수 있는 모델입니다. 비선형 모델은 선형 함수로는 표현할 수 없는 복잡한 패턴과 관계를 학습할 수 있습니다. 비선형성을 도입하기 위해 딥러닝에서는 주로 비선형 활성화 함수를 사용합니다.

활성화 함수는 뉴런의 출력 값을 비선형적으로 변환합니다. 일반적인 비선형 활성화 함수로는 ReLU(Rectified Linear Unit), Sigmoid, Tanh 등이 있습니다. 비선형 활성화 함수를 사용함으로써 딥러닝 모델은 복잡한 데이터 구조를 학습하고 표현할 수 있는 능력을 갖추게 됩니다. 이는 딥러닝의 강력한 성능의 핵심 요소 중 하나입니다.

예를 들어, XOR(Exclusive OR) 문제는 입력 값이 두 개의 이진 변수인 경우, 두 값이 다를 때만 출력이 1이고, 같을 때는 0이 되는 문제입니다. XOR 문제는 선형 분리가 불가능한 비선형 문제로, 단일 레이어 퍼셉트론으로 해결할 수 없습니다. 이를 해결하기 위해 다층 레이어 퍼셉트론이 필요합니다.

## 단일 레이어 퍼셉트론 (Single-Layer Perceptron)
단일 레이어 퍼셉트론은 인공 신경망의 가장 기본적인 형태 중 하나로, 인공 뉴런의 개념을 기반으로 한 간단한 모델입니다. 단일 레이어 퍼셉트론은 입력값을 받아들이고, 가중치를 적용한 후, 활성화 함수를 통해 출력을 생성하는 단일 층으로 구성된 신경망입니다.

1. **입력층(Input Layer)**: 입력 값을 받는 뉴런들이 위치한 층입니다. 각 입력 뉴런은 하나의 특성을 나타냅니다.
2. **출력층(Output Layer)**: 입력 값을 처리하여 최종 출력을 생성하는 뉴런이 위치한 층입니다.

### 퍼셉트론 학습 규칙 (Perceptron Learning Rule)
퍼셉트론 학습 규칙(Perceptron Learning Rule)은 단일 레이어 퍼셉트론을 학습시키기 위해 사용하는 간단하고 직관적인 방법입니다.

퍼셉트론 학습 규칙은 다음과 같습니다:
1. **가중치 초기화**:
	- 가중치와 편향은 보통 작은 무작위 값으로 초기화됩니다.
2. **순전파(Forward Propagation)**:
   - 입력 벡터를 받아 가중합을 계산합니다.
   - 활성화 함수를 적용하여 출력을 계산합니다.
3. **손실 계산(Loss Calculation)**:
   - 손실 함수를 사용하여 예측값과 실제값 사이의 손실을 계산합니다.
4. **가중치 업데이트(Weight Update)**:
   - 계산된 손실을 기반으로 가중치와 편향을 조정합니다.
   - 하이퍼파라미터인 학습률을 사용하여 업데이트 속도를 조절할 수 있습니다.
5. **반복**:
   - 모든 훈련 데이터에 대해 위 과정을 반복합니다.
   - 전체 데이터셋에 대해 손실이 0이 되거나 설정된 반복 횟수에 도달할 때까지 학습을 계속합니다.

퍼셉트론 학습 규칙은 단순한 문제를 해결하는 데 유용하지만, XOR 문제와 같이 선형 분리 불가능한 문제는 해결할 수 없습니다.

## 다중 레이어 퍼셉트론 (Multilayer Perceptron, MLP)
다중 레이어 퍼셉트론은 인공 신경망의 한 형태로, 입력층과 출력층 사이에 하나 이상의 은닉층(hidden layer)을 포함하는 신경망입니다. MLP는 비선형 문제를 해결할 수 있으며, 더 복잡한 패턴과 관계를 학습하는 데 사용됩니다. MLP는 이미지 인식, 자연어 처리, 회귀 문제 등 다양한 분야에서 활용됩니다.

1. **입력층(Input Layer)**: 입력 값을 받는 뉴런들이 위치한 층입니다. 각 입력 뉴런은 하나의 특성을 나타냅니다.
2. **은닉층(Hidden Layer)**: 입력층과 출력층 사이에 위치한 하나 이상의 층입니다. 은닉층의 뉴런들은 가중치와 편향을 통해 연결되어 있으며, 활성화 함수를 사용하여 비선형성을 추가합니다.
3. **출력층(Output Layer)**: 입력 값을 처리하여 최종 출력을 생성하는 뉴런이 위치한 층입니다.

MLP의 동작 과정은 다음과 같습니다:

1. **가중치 초기화**:
	- 가중치와 편향은 보통 작은 무작위 값으로 초기화됩니다.
2. **순전파(Forward Propagation)**:
	- 입력 데이터가 입력층에서 시작하여 은닉층을 거쳐 출력층까지 전달됩니다.
	- 각 뉴런은 가중합과 활성화 함수를 통해 출력값을 계산합니다.
3. **손실 계산(Loss Calculation)**:
	- 손실 함수를 사용하여 예측값과 실제값 사이의 손실을 계산합니다.
4. **역전파(Backpropagation)**:
	- 출력층에서부터 시작하여 오차를 거꾸로 전파하여 각 층의 가중치와 편향에 대한 손실 함수의 기울기를 계산합니다.
	- 각 층의 기울기는 오차와 활성화 함수의 미분값을 곱하여 계산됩니다.
5. **가중치 업데이트(Weight Update)**:
	- 현재 값의 기울기를 통해 손실 함수를 최소화하는 방향으로 각 가중치와 편향을 업데이트합니다.
	- 하이퍼파라미터인 학습률을 사용하여 업데이트 속도를 조절할 수 있습니다.
6. **반복**:
	- 모든 훈련 데이터에 대해 위 과정을 반복합니다.
	- 전체 데이터셋에 대해 손실이 0이 되거나 설정된 반복 횟수에 도달할 때까지 학습을 계속합니다.

### 경사 하강법 (Gradient Descent)
경사 하강법(Gradient Descent)은 함수의 최솟값을 찾는 최적화 알고리즘 중 하나로, 기울기(경사)를 따라 함수의 값을 조금씩 조정하여 최솟값에 수렴하는 방법입니다. 주로 역전파의 가중치 업데이트 과정에서 사용됩니다.

경사 하강법의 기본 아이디어는 다음과 같습니다:
1. **시작점 선택**:
   - 최적화하려는 함수의 시작점을 임의로 선택합니다.
2. **경사 계산**:
   - 선택한 지점에서 함수의 기울기를 계산합니다.
3. **이동**:
   - 현재 위치에서 기울기가 감소하는(함수의 값이 감소하는) 방향으로 이동합니다.
4. **반복**:
   - 새로운 위치에서 위 과정을 반복합니다. 일정한 조건(예: 일정한 반복 횟수 또는 함수 값의 변화량)이 충족될 때까지 이 과정을 반복합니다.

## Convolutional Neural Network
컨볼루셔널 신경망(Convolutional Neural Network, CNN)은 주로 이미지 인식 및 분류와 관련된 문제에 사용되는 딥러닝 신경망 아키텍처입니다. CNN은 이미지 등 공간정보 처리에 특화되어 있으며, 공간의 특징을 자동으로 학습하여 패턴을 인식하고 분류하는 데 사용됩니다.

CNN의 순전파 과정은 다음과 같습니다:
1. **합성곱(Convolution)**:
    - 여러 개의 작은 필터(kernel)를 사용하며, 각 필터는 입력 데이터를 슬라이딩하면서 합성곱 연산을 수행하고, 각 위치에서 특징 맵(feature map)을 생성합니다.
2. **활성화(Activation)**:
    - 합성곱 계층의 생성한 특징 맵에 활성화 함수(비선형 함수)를 적용하여 활성화된 특징 맵을 생성합니다.
3. **풀링(Pooling)**:
    - 활성화된 특징 맵을 다운샘플링하여 특징 맵의 크기를 줄이고 계산량을 줄입니다.
4. **합성곱-활성화-풀링 계층의 반복**:
    - 합성곱-활성화-풀링 계층의 조합이 여러 번 반복됩니다.
    - 풀링 계층의 출력이 다음 컨볼루션 계층의 입력으로 사용됩니다.
5. **완전 연결 계층(Fully Connected Layer)**:
    - 추출된 특징을 기반으로 최종적으로 입력 데이터를 분류합니다.

아래 예제는 MNIST 숫자 이미지 분류 문제를 해결하는 간단한 CNN입니다.
```
import tensorflow as tf
from tensorflow.keras import layers, models

# MNIST 데이터셋 로드
mnist = tf.keras.datasets.mnist
(train_images, train_labels), (test_images, test_labels) = mnist.load_data()

# 이미지 데이터 전처리
train_images = train_images.reshape((60000, 28, 28, 1)) / 255.0
test_images = test_images.reshape((10000, 28, 28, 1)) / 255.0

# CNN 모델 구성
model = models.Sequential([
    layers.Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.Flatten(),
    layers.Dense(64, activation='relu'),
    layers.Dense(10, activation='softmax')
])

# 모델 컴파일
model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

# 모델 훈련
model.fit(train_images, train_labels, epochs=5, batch_size=64)

# 모델 평가
test_loss, test_acc = model.evaluate(test_images, test_labels)
print('Test accuracy:', test_acc)
```

### Convolution
합성곱(Convolution) 과정은 입력 데이터와 필터(kernel) 사이의 합성곱을 계산하는 과정입니다. 합성곱은 입력 데이터를 필터와 겹쳐지는 부분마다 연산하여 출력값을 생성하며, 이를 통해 입력 데이터의 특징을 추출합니다.

합성곱 과정은 다음과 같습니다.
1. **입력 데이터와 필터(커널)**:
	- 입력 데이터는 주로 이미지나 다차원 배열 형태로 제공됩니다. 필터는 입력 데이터와 동일한 차원을 갖는 작은 행렬로서, 주로 2차원 혹은 3차원으로 사용됩니다. 필터의 크기는 일반적으로 3x3 또는 5x5와 같은 작은 값으로 설정됩니다.
2. **합성곱 연산**:
	- 입력 데이터와 필터의 요소별 곱을 계산합니다.
	- 이 곱의 합을 구하여 출력 맵의 현재 위치에 할당합니다.
	- 필터를 이동하면서 전체 입력 데이터를 스캔하고, 각 위치에서 합성곱 연산을 수행하여 출력 맵을 생성합니다.
3. **스트라이드(Strides)**:
	- 스트라이드는 필터가 이동하는 간격입니다.
	- 보통 스트라이드는 1이며, 필터가 한 칸씩 이동하면서 합성곱이 계산됩니다.
4. **패딩(Padding)**:
	- 패딩은 입력 데이터의 가장자리에 추가되는 가상의 값으로, 출력 맵의 크기를 조절하는 데 사용됩니다.
	- 패딩을 사용하여 출력 맵의 크기를 입력 데이터와 동일하게 만들 수 있습니다.

### Pooling
풀링(Pooling) 과정은 특징 맵의 공간적인 해상도를 줄이고 계산량을 감소시킵니다. 특징의 중요성을 유지하면서 공간적인 차원을 축소하여, 네트워크의 일반화 성능을 향상시키고 과적합을 방지합니다.

풀링 과정은 다음과 같습니다:
1. **풀링 윈도우(Window)**:
	- 풀링 연산은 풀링 윈도우(window)라는 고정 크기의 영역을 사용하여 수행됩니다.
	- 윈도우 영역은 일반적으로 2x2 또는 3x3 크기입니다.
2. **스트라이드(Strides)**:
	- 스트라이드는 윈도우가 이동하는 간격입니다.
	- 보통 스트라이드는 풀링 윈도우의 크기와 동일하게 설정되어, 겹치지 않는 영역에서 연산을 수행합니다.
3. **풀링 연산**:
	- 최대 풀링(Max Pooling): 각 풀링 윈도우 내에서 최대값을 계산합니다.
	- 평균 풀링(Average Pooling): 각 풀링 윈도우 내에서 평균값을 계산합니다.
4. **출력 특징 맵 생성**:
	- 풀링 연산을 통해 얻은 최대값 또는 평균값은 새로운 특징 맵의 해당 위치에 할당됩니다.

### Fully Connected Layer
CNN에서 완전 연결 계층(Fully Connected Layer)은 주로 네트워크의 최종 단계로, 층은 이전 계층에서 추출된 특징들을 사용하여 입력 데이터에 대한 최종적인 출력을 생성합니다. 

완전 연결 계층의 동작 과정은 다음과 같습니다:
1. **입력 데이터 전달**:
	- 이전 계층에서 추출된 특징 맵을 1차원으로 평탄화(flatten)합니다.
	- 평탄화한 벡터 형태의 데이터를 입력으로 사용합니다.
2. **활성화 함수 적용**:
	- 각 뉴런의 가중치와 편향을 적용한 후, 활성화 함수를 적용하여 출력을 생성합니다.
	- 활성화 함수를 거친 출력은 완전 연결 계층의 최종 출력이 됩니다.

완전 연결 계층의 출력은 주어진 작업에 따라 다르게 구성될 수 있습니다. 예를 들어, 분류(classification) 작업에서는 출력 뉴런의 수는 클래스의 수와 동일하게 설정되며, 각 출력 뉴런은 해당 클래스에 속할 확률을 나타냅니다.

## Recurrent Neural Network
순환 신경망(Recurrent Neural Network, RNN)은 이전 단계의 출력을 현재 단계의 입력으로 사용하는 구조를 가진 딥러닝의 한 유형입니다. 이전 정보를 현재의 결정에 반영할 수 있다는 점에서 RNN은 순차 데이터를 처리할 때 효과적입니다. RNN은 자연어 처리 (번역, 텍스트 생성 등), 시계열 예측 (주식 시장 예측, 날씨 예측 등), 음성 인식 등 다양한 응용 분야에서 활용됩니다.

RNN은 다음과 같이 구성됩니다:
1. **입력층(Input Layer)**:
	- 입력 데이터를 받습니다.
2. **은닉층(Hidden Layer)**:
	- 이전 단계의 출력을 현재 단계의 입력과 결합하여 새로운 출력을 생성합니다.
	- 이전 단계의 은닉 상태를 다음 단계로 전달하는 순환적인 구조를 가지며 여러 번 반복됩니다.
3. **출력층(Output Layer)**: 모델의 최종 출력을 생성합니다.

다음은 0부터 9까지의 숫자 시퀀스를 예측하는 간단한 RNN 모델입니다.
```
import numpy as np
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import SimpleRNN, Dense

# 입력: [[0], [1], [2], [3], [4], [5], [6], [7], [8]]
# 출력: [[1], [2], [3], [4], [5], [6], [7], [8], [9]]

# 입력 데이터 (samples, time steps, features)
X = np.array([[[i]] for i in range(9)])
# 출력 데이터 (samples, features)
y = np.array([[i + 1] for i in range(9)])

# RNN 모델 구성
model = Sequential()
model.add(SimpleRNN(10, input_shape=(1, 1)))
model.add(Dense(1))

# 모델 컴파일
model.compile(optimizer='adam', loss='mse')

# 모델 훈련
model.fit(X, y, epochs=200, verbose=0)

# 예측
predictions = model.predict(X)

# 결과 출력
for i in range(len(predictions)):
    print(f'입력: {i} => 예측 출력: {predictions[i][0]:.2f}')
```

## Word Embedding
단어 임베딩(Word Embedding)은 자연어 처리(NLP)에서 단어를 수치 벡터로 표현하는 기술입니다. 단어 임베딩을 통해 단어를 고정 길이의 실수 벡터로 변환할 수 있으며, 이러한 벡터는 단어의 의미적 유사성을 반영합니다. 즉, 의미가 비슷한 단어들은 임베딩 벡터 공간에서 서로 가깝게 위치하게 됩니다.

1. **벡터 표현**:
   - 단어를 고정 길이의 실수 벡터로 변환합니다.
   - 벡터의 각 차원은 단어의 특정 의미적 특성을 나타냅니다.
2. **의미적 유사성**:
   - 임베딩 벡터 공간에서 의미가 유사한 단어들은 가까운 거리에 위치하게 됩니다.
   - 예를 들어, "king"과 "queen", "apple"과 "fruit"은 각각 임베딩 벡터 공간에서 서로 가까운 위치에 있을 것입니다.
3. **학습 방법**:
   - 단어 임베딩은 주로 대규모 텍스트 데이터에서 학습됩니다.
   - 대표적인 방법으로 Word2Vec, GloVe, FastText 등이 있습니다.

### Word2Vec
Word2Vec은 구글에서 개발한 단어 임베딩 기법으로, 단어를 벡터 공간에 임베딩하여 의미적으로 유사한 단어들이 가까운 거리에 위치하도록 합니다.

Word2Vec에서 주로 사용되는 모델 종류는 다음과 같습니다:
1. **CBOW (Continuous Bag of Words)**:
   - CBOW 모델은 주변 단어들(Context words)을 통해 중심 단어(Target word)를 예측하는 방식입니다.
   - 예를 들어, 문장에서 "The cat sits on the mat"가 있을 때, "The", "cat", "on", "the", "mat" 같은 주변 단어들을 사용하여 "sits"라는 중심 단어를 예측합니다.
   - CBOW 모델은 문맥의 평균적인 표현을 통해 중심 단어를 예측하므로, 데이터셋이 클 때 효율적으로 학습할 수 있습니다.
2. **Skip-gram**:
   - Skip-gram 모델은 중심 단어(Target word)를 통해 주변 단어들(Context words)을 예측하는 방식입니다.
   - 같은 예시에서, 중심 단어 "sits"를 사용하여 주변 단어들 "The", "cat", "on", "the", "mat"를 예측합니다.
   - Skip-gram 모델은 희귀한 단어에 대한 표현을 학습하는 데 더 효과적입니다.

Word2Vec의 학습 과정은 다음과 같습니다:

1. **단어 벡터 초기화**:
   - 각 단어는 임의의 작은 값으로 초기화된 고정 길이의 벡터로 표현됩니다.
2. **단어 예측**:
   - CBOW 모델에서는 주변 단어들을 평균하여 중심 단어를 예측합니다.
   - Skip-gram 모델에서는 중심 단어를 사용하여 주변 단어들을 예측합니다.
3. **손실 함수 계산**:
   - 모델이 예측한 단어와 실제 단어 사이의 차이를 계산하여 손실을 구합니다.
   - 일반적으로 음성 샘플링(Negative Sampling) 또는 계층적 소프트맥스(Hierarchical Softmax) 같은 방법을 사용하여 계산 효율성을 높입니다.
4. **역전파를 통해 가중치 업데이트**:
   - 손실을 최소화하기 위해 역전파 알고리즘을 사용하여 단어 벡터를 업데이트합니다.
   - 이 과정은 반복적으로 수행되어 단어 벡터가 최적화됩니다.

## Generative Adversarial Network
Generative Adversarial Network(GAN, 생성적 적대 신경망)은 두 개의 신경망, 즉 생성자(Generator)와 판별자(Discriminator)가 경쟁하는 방식으로 작동합니다. 이 두 네트워크는 서로 대립하며 학습하는 과정에서 점점 더 정교한 결과를 만들어냅니다. GAN은 이미지 생성, 이미지 변환, 데이터 증강 등 다양한 분야에서 사용됩니다.

1. **생성자(Generator)**:
	- 생성자는 무작위 노이즈 벡터를 입력으로 받아서 가짜 데이터를 생성합니다. 이 데이터는 판별자를 속이기 위해 최대한 진짜 데이터와 유사하게 만들어야 합니다.
	- 생성자는 판별자가 가짜 데이터를 '진짜'라고 잘못 분류하도록 속이는 방향으로 학습합니다.
2.  **판별자(Discriminator)**:
	- 판별자는 입력으로 받은 데이터가 진짜인지 가짜인지 판별하는 이진 분류기입니다. 진짜 데이터는 실제 데이터셋에서 가져온 것이고, 가짜 데이터는 생성자가 만든 것입니다.
	- 판별자는 진짜와 가짜를 구별하는 방향으로 학습합니다.

GAN의 전체적인 동작 과정은 다음과 같습니다:

1. **생성자(Generator)**:
	- 생성자는 무작위 잠재 공간에서 무작위 벡터를 샘플링한 후, 이를 이미지로 변환하여 가짜 이미지를 생성합니다.
2. **판별자(Discriminator)**:
	- 판별자는 실제 이미지와 생성자가 생성한 가짜 이미지를 입력으로 받아, 각 이미지가 실제인지 혹은 가짜인지를 판별합니다.
3. **경쟁(Adversarial) 과정**:
	- 생성자와 판별자는 서로 대립하면서 학습합니다. 생성자는 가능한 한 실제 이미지와 비슷한 가짜 이미지를 생성하려고 노력하고, 판별자는 실제 이미지와 생성자가 생성한 가짜 이미지를 정확히 구별하려고 합니다.
	- 이 경쟁적인 과정은 두 신경망이 서로를 개선하면서 최적의 성능을 달성하도록 합니다.
4. **손실 함수(Loss Function)**:
	- 생성자와 판별자는 각각 다른 손실 함수를 사용하여 학습됩니다.
	- 생성자의 손실: 생성자는 판별자를 속이도록 학습하기 때문에, 생성된 가짜 이미지가 실제 이미지로 잘못 분류될 확률을 최소화하는 방향으로 학습됩니다. 일반적으로 생성자의 손실은 생성된 이미지가 진짜로 분류되었을 때의 로그 확률을 최대화하는 방식으로 정의됩니다.
	- 판별자의 손실: 판별자는 실제 이미지와 가짜 이미지를 잘못 구별할 확률을 최소화하는 방향으로 학습됩니다. 일반적으로 이 손실은 실제 이미지에 대한 분류 오차와 가짜 이미지에 대한 분류 오차를 모두 고려합니다.
5. **수렴**:
	- 생성자와 판별자가 동시에 학습하면서 손실이 감소하고, 결국 생성자가 실제와 거의 구별할 수 없는 가짜 이미지를 생성할 수 있는 수준으로 발전합니다.
	- 이때 생성된 이미지는 실제 이미지와 매우 유사해지며, 생성자와 판별자의 성능이 수렴하는 지점에 이르게 됩니다.

최종적으로 생성자는 실제 데이터와 매우 유사한 가짜 데이터를 생성하고, 판별자는 생성된 가짜 데이터를 실제 데이터와 구별하기 어려운 수준까지 발전하게 됩니다.

## Autoencoder
Autoencoder는 입력 데이터의 효율적인 표현을 학습하는 신경망입니다. 입력 데이터를 저차원으로 인코딩한 후 다시 디코딩하여 원래의 입력을 복원하려고 시도합니다. 이를 통해 입력 데이터를 효과적으로 압축하고 잠재적인 특징을 추출할 수 있습니다. Autoencoder는 주로 데이터의 차원 축소, 잡음 제거, 특징 추출 용도로 활용됩니다.

1. **인코더(Encoder)**:
	- 인코더는 입력 데이터를 저차원의 잠재 공간으로 매핑하는 신경망입니다.
	- MLP 또는 CNN을 사용하여 인코더를 구성합니다.
2. **디코더(Decoder)**:
	- 디코더는 인코더가 생성한 저차원 표현을 다시 원래의 고차원 데이터로 디코딩하는 신경망입니다.
	- MLP 또는 CNN을 사용하여 디코더를 구성합니다.
3. **재구성 손실(Reconstruction Loss)**:
	- 재구성 손실은 입력 데이터가 얼만큼 정확하게 재구성 됐는지를 측정하는 손실 함수입니다.
	- 일반적으로 재구성 손실은 입력 데이터와 디코더가 생성한 재구성 데이터 간의 차이를 최소화하는 방향으로 학습됩니다.

Autoencoder의 전체적인 동작 과정은 다음과 같습니다:

1. **압축과 특징 추출**:
	- 인코더는 입력 데이터를 저차원으로 압축하면서 입력 데이터의 중요한 특징을 추출합니다.
	- 이 저차원 표현은 입력 데이터의 효율적인 표현으로 사용될 수 있습니다.
2. **재구성**:
	- 디코더는 저차원의 표현을 입력으로 받아 원래의 입력 데이터를 재구성합니다.
3. **평가와 응용**:
	- 훈련된 Autoencoder는 주어진 입력 데이터에 대해 잠재 공간으로 매핑하고 재구성할 수 있습니다.
	- 이러한 특성을 활용하여 데이터의 압축, 잡음 제거, 특징 추출 등 다양한 응용이 가능합니다.

## Variational Autoencoder
VAE(Variational Autoencoder)는 Autoencoder의 한 종류로, 잠재 변수를 사용하여 보다 유연하고 다양한 데이터 분포를 모델링할 수 있으며, 훈련된 모델로부터 새로운 데이터를 생성할 수 있습니다. VAE는 주로 이미지 생성, 잡음 제거, 복원 용도로 활용됩니다.

1. **확률적 잠재 변수**:
	- VAE는 확률적 잠재 변수를 사용하여 각 데이터에 대해 잠재 변수의 확률 분포를 모델링하고, 해당 데이터의 특성을 포착합니다.
2. **변분 추론(Variational Inference)**:
	- VAE는 변분 추론을 사용하여 데이터를 잠재 공간으로 매핑하는 동시에, 잠재 변수의 확률 분포를 학습합니다.
3. **재구성 손실과 KL 발산 손실**:
	- 재구성 손실(reconstruction loss): 입력 데이터가 얼만큼 정확하게 재구성 됐는지를 측정하는 손실 함수입니다.
	- KL 발산 손실(Kullback-Leibler divergence loss): 잠재 변수의 확률 분포와 사전 분포 사이의 차이를 측정하는 손실 함수입니다.
	- VAE는 이 두 손실을 최소화하는 방향으로 학습합니다.

VAE의 전체적인 동작 과정은 다음과 같습니다:

1. **인코더(Encoder)**:
	- 인코더는 입력 데이터를 받아 잠재 공간의 확률 분포를 파라미터화합니다.
2. **샘플링 과정(Sampling)**:
	- 인코더가 파라미터화한 확률 분포에서 잠재 변수의 샘플을 추출합니다.
	- 이 샘플은 잠재 공간에서 데이터를 대표하는 확률적인 표현입니다.
3. **디코더(Decoder)**:
	- 디코더는 잠재 변수 샘플을 입력으로 받아 원래의 입력 데이터를 재구성합니다. 
4. **손실 함수 최적화**:
	- VAE는 재구성 손실과 KL 발산 손실을 최소화하는 방향으로 학습됩니다.
	- 재구성 손실은 입력 데이터를 잘 복원하는 것을 보장하고, KL 발산 손실은 잠재 공간의 확률 분포를 사전 분포와 근접하게 만듭니다.
5. **샘플링과 생성**:
	- 훈련된 VAE는 잠재 공간에서 샘플링하여 새로운 데이터를 생성할 수 있습니다.
	- 잠재 공간에서 무작위한 점을 선택하고 디코더를 통해 해당 점에 해당하는 데이터를 생성합니다.

## Transformer
Transformer는 딥러닝 모델 중 하나로, 주로 Attention 메커니즘을 기반으로 합니다. Transformer 모델은 기존의 RNN이나 CNN에 비해 학습이 빠르며, 병렬 처리가 가능하고 긴 시퀀스에 대해 잘 작동합니다. 이러한 특징으로 인해 자연어 처리에서 널리 사용되고 있습니다. (예: BERT, GPT, T5)

1. **Self-Attention 메커니즘**:
	- Transformer 모델은 Self-Attention 메커니즘을 사용하여 입력 시퀀스 내의 각 워드 간의 관계를 파악합니다.
	- Self-Attention 메커니즘은 각 워드의 중요도를 동적으로 계산하여 해당 워드의 문맥을 잘 이해할 수 있습니다.
2. **인코더-디코더 구조**:
	- Transformer 모델은 주로 인코더-디코더 구조를 사용하여 Sequence-to-Sequence 작업을 수행합니다.
	- 인코더는 입력 시퀀스를 임베딩하고, 디코더는 출력 시퀀스를 생성합니다.
3. **Scaled Dot-Product Attention**:
	- Transformer 모델은 Scaled Dot-Product Attention을 사용하여 각 워드 간의 관계를 계산합니다.
	- Scaled Dot-Product Attention은 메모리를 효율적으로 활용하며 병렬로도 연산할 수 있어 효율적인 학습을 가능하게 합니다.
4. **포지션 임베딩(Positional Embedding)**:
	- 포지션 임베딩은 입력 시퀀스 내의 단어의 위치 정보를 임베딩하는 방법입니다.
	- 포지션 임베딩을 사용해 입력 시퀀스의 위치 정보를 고려할 수 있습니다.
