# Database
## DBMS
DBMS는 데이터베이스 관리 시스템(Database Management System)의 약자로, 데이터를 저장, 검색, 수정 및 삭제할 수 있는 소프트웨어입니다. 데이터베이스는 조직화된 데이터의 집합이며, DBMS는 이러한 데이터베이스를 효율적으로 관리하고 사용자가 쉽게 접근할 수 있도록 돕습니다.

DBMS의 주요 기능에는 다음과 같은 것들이 있습니다:
1. **데이터 정의 (Data Definition):** 데이터베이스의 구조와 스키마를 정의합니다. 이는 데이터의 유형, 관계, 제약 조건 등을 정의하는 과정입니다.
2. **데이터 조작 (Data Manipulation):** 데이터를 검색, 추가, 수정, 삭제하는 기능을 제공합니다. 이는 주로 쿼리 언어(SQL 등)를 사용하여 수행됩니다.
3. **데이터 관리 (Data Management):** 데이터의 보안, 무결성, 백업, 복구 등을 관리합니다. 이는 데이터베이스의 안전하고 일관된 상태를 유지하기 위한 작업입니다.
4. **데이터 제어 (Data Control):** 데이터베이스에 접근할 수 있는 권한을 관리하고 사용자의 보안 및 권한을 관리합니다.

### MySQL
MySQL은 오픈 소스 관계형 데이터베이스 관리 시스템(RDBMS)으로, 많은 웹 애플리케이션 및 소프트웨어에서 사용되는 인기 있는 데이터베이스입니다. MySQL은 다양한 운영 체제에서 실행할 수 있으며, 사용하기 쉽고 안정성이 뛰어나며 무료로 제공되는 오픈 소스 소프트웨어입니다.

MySQL은 웹 개발, 소프트웨어 애플리케이션, 데이터 분석 등 다양한 분야에서 널리 사용되며, 안정성과 성능을 고려할 때 많은 사용자들에게 선호되는 선택지입니다.

- **오픈 소스:** MySQL은 오픈 소스 라이센스인 GNU General Public License(GPL) 하에 배포되며, 무료로 사용할 수 있습니다. 이는 비용을 절감하고 커뮤니티 지원을 받을 수 있음을 의미합니다.
- **선순환적 구조:** MySQL은 다른 RDBMS와 호환되는 표준 SQL을 사용합니다. 이는 MySQL을 쉽게 다른 시스템과 통합하고, 기존의 SQL 기술을 활용하여 데이터를 조작할 수 있음을 의미합니다.
- **높은 성능:** MySQL은 뛰어난 성능을 제공하며, 대부분의 웹 애플리케이션과 소규모부터 중규모의 데이터베이스 요구 사항을 충족합니다. 특히 인덱싱, 쿼리 최적화 및 캐싱 기능 등을 통해 빠른 응답 시간을 제공합니다.
- **확장성:** MySQL은 수평 및 수직 확장 모두를 지원합니다. 이는 필요에 따라 서버의 하드웨어 성능을 업그레이드하거나 여러 대의 서버를 클러스터링하여 성능을 확장할 수 있음을 의미합니다.

### MongoDB
MongoDB는 NoSQL 데이터베이스로서, 문서 지향(Document-Oriented) 데이터베이스 시스템입니다. 이는 데이터를 BSON(Binary JSON) 형식의 문서로 저장하는 특징을 가지고 있습니다. MongoDB는 대량의 비정형 데이터를 효율적으로 저장하고 처리하는 데 주로 사용됩니다.

MongoDB는 주로 대규모 데이터 분석, 로그 저장, 실시간 분석 등의 분야에서 사용되며, 특히 비정형 데이터를 다루는 데 효과적입니다. 그러나 데이터의 일관성과 ACID(Atomicity, Consistency, Isolation, Durability) 특성에 대한 보장이 상대적으로 약할 수 있습니다.

- **유연한 스키마:** MongoDB는 스키마가 없거나 동적으로 변하는 스키마를 가질 수 있습니다. 이는 데이터 구조를 유연하게 변경하고 확장할 수 있음을 의미합니다.
- **문서 지향 데이터 모델:** MongoDB는 JSON과 유사한 BSON 형식의 문서를 사용하여 데이터를 저장합니다. 이는 복잡한 데이터 구조를 쉽게 표현하고 다룰 수 있습니다.
- **고성능 및 확장성:** MongoDB는 쓰기 및 읽기 작업을 빠르게 처리하며, 수평 및 수직 확장이 가능합니다. 이는 대규모의 데이터를 효율적으로 처리할 수 있음을 의미합니다.
- **높은 가용성:** MongoDB는 자동으로 데이터를 복제하여 고 가용성을 제공합니다. 이는 단일 장애 지점(SPOF)을 방지하고 시스템의 신뢰성을 높입니다.
- **분산 데이터베이스:** MongoDB는 여러 서버에 데이터를 분산하여 저장하고 관리할 수 있습니다. 이는 데이터의 안정성과 확장성을 높여줍니다.
- **풍부한 쿼리 언어:** MongoDB는 강력한 쿼리 언어를 제공하여 데이터를 검색하고 조작하는 데 유용합니다. 이는 다양한 검색 및 분석 작업을 수행할 수 있음을 의미합니다.

### Oracle Database
Oracle Database는 오라클이 개발한 상용 관계형 데이터베이스 관리 시스템(RDBMS)입니다. 대규모 기업 및 조직에서 사용되며, 안정성, 성능, 보안 등의 면에서 높은 평가를 받고 있습니다.

Oracle Database는 대규모 기업 환경에서 널리 사용되며, 안정성, 성능 및 보안 기능을 강조하는 경우에 적합한 선택지입니다. 그러나 라이센스 비용이 높을 수 있고, 초기 설정 및 관리에는 일정한 노력이 필요할 수 있습니다.

- **고성능:** Oracle Database는 뛰어난 성능을 제공합니다. 다중 프로세서 아키텍처와 메모리 캐시 기능을 통해 데이터베이스 작업을 빠르게 처리할 수 있습니다.
- **높은 가용성:** Oracle Database는 자동화된 데이터베이스 복제 및 장애 복구 기능을 제공하여 고 가용성을 보장합니다. 이는 시스템의 신뢰성을 높이고 비즈니스 연속성을 유지합니다.
- **확장성:** Oracle Database는 대규모 데이터베이스 환경에 적합하며, 수평 및 수직 확장이 가능합니다. 이는 데이터베이스의 용량을 쉽게 조절하고 확장할 수 있음을 의미합니다.
- **고급 보안 기능:** Oracle Database는 강력한 보안 기능을 제공하여 데이터의 안전성을 보장합니다. 접근 제어, 암호화, 감사 및 감사 추적 기능 등을 제공하여 데이터를 보호합니다.
- **다양한 기능과 옵션:** Oracle Database는 다양한 기능과 옵션을 제공하여 사용자의 요구 사항을 충족합니다. 데이터베이스 관리, 성능 최적화, 비즈니스 인텔리전스(BI) 등 다양한 기능을 지원합니다.

### Microsoft SQL Server
Microsoft SQL Server는 Microsoft가 개발한 관계형 데이터베이스 관리 시스템(RDBMS)으로, 주로 Windows 환경에서 실행됩니다. SQL Server는 대규모 기업 및 중소 규모의 비즈니스에 널리 사용되며, 안정성, 성능, 보안 등의 면에서 높은 평가를 받고 있습니다.

Microsoft SQL Server는 안정성, 성능 및 보안 기능을 강조하는 경우에 적합한 선택지입니다. Microsoft의 다른 제품 및 서비스와의 통합성도 높으며, 사용자가 익숙한 환경에서 데이터베이스를 운영할 수 있습니다.

- **다양한 버전 및 에디션:** SQL Server는 다양한 버전과 에디션을 제공하여 사용자의 요구 사항을 충족합니다. 개발자, Express, Standard, Enterprise 등 다양한 에디션을 선택할 수 있습니다.
- **유연한 배포 옵션:** SQL Server는 온-프레미스, 클라우드 및 하이브리드 환경에서 실행할 수 있습니다. 이는 사용자가 원하는 환경에서 데이터베이스를 운영할 수 있음을 의미합니다.
- **높은 가용성:** SQL Server는 자동화된 데이터베이스 복제, 장애 복구 및 클러스터링 기능을 제공하여 고 가용성을 보장합니다. 이는 시스템의 신뢰성을 높이고 비즈니스 연속성을 유지합니다.
- **고급 보안 기능:** SQL Server는 강력한 보안 기능을 제공하여 데이터의 안전성을 보장합니다. 접근 제어, 암호화, 투명한 데이터 암호화(TDE) 등의 기능을 제공하여 데이터를 보호합니다.
- **통합된 비즈니스 인텔리전스(BI):** SQL Server는 통합된 비즈니스 인텔리전스(BI) 기능을 제공하여 사용자가 데이터를 분석하고 시각화할 수 있습니다. 이는 의사 결정을 지원하고 비즈니스 인텔리전스를 개발하는 데 유용합니다.

## Index
인덱스(Index)는 데이터베이스에서 데이터를 빠르게 검색할 수 있도록 도와주는 데이터 구조입니다. 주로 B+ 트리로 데이터가 인덱스로 사용됩니다. 인덱스는 검색 성능을 향상시키고, 대용량 데이터를 다룰 때 효율성을 높이는 데 사용됩니다.

- **검색 속도 향상**: 특정 컬럼에 대해 빠르게 데이터를 찾을 수 있습니다. 예를 들어, `user_id`로 검색할 때 인덱스를 사용하면 테이블의 모든 행을 조회할 필요 없이 빠르게 검색할 수 있습니다.
- **정렬 성능 향상**: 인덱스는 데이터가 정렬된 상태로 관리되기 때문에, 정렬 쿼리에서 성능을 크게 향상시킬 수 있습니다.
- **중복값 검사**: 유니크 인덱스를 사용하면 중복된 데이터 삽입을 방지할 수 있습니다.
- **디스크 공간 사용 증가**: 인덱스를 추가하면 해당 인덱스를 저장하기 위한 디스크 공간이 필요합니다. 특히 대용량 데이터베이스에서는 인덱스가 큰 디스크 공간을 차지할 수 있습니다.
- **데이터 변경 시 성능 저하**: 데이터를 삽입, 수정, 삭제할 때 인덱스도 업데이트되어야 합니다. 이 때문에 데이터 변경 작업이 많을 경우 인덱스 업데이트가 성능 저하를 일으킬 수 있습니다.

 **PK는 기본적으로 인덱스를 생성**합니다. 즉, MySQL이나 다른 RDBMS에서 **PK를 정의하면 자동으로 해당 컬럼에 인덱스가 생성**되기 때문에, 해당 PK를 이용한 검색은 **인덱스를 활용한 빠른 검색**이 가능합니다.

### 인덱스를 사용해야 할 때
인덱스는 데이터베이스 성능을 최적화하고, 데이터를 빠르게 검색할 수 있게 도와주는 중요한 기법입니다. 그러나 잘못 사용하면 성능이 오히려 저하될 수 있기 때문에, 인덱스를 추가할 때는 쿼리 패턴을 잘 분석하고, 필요한 컬럼에만 인덱스를 생성하는 것이 중요합니다.

- **검색이 자주 발생하는 컬럼**에 인덱스를 추가하면 성능 향상에 도움이 됩니다. 예를 들어, 자주 검색되는 `user_id`, `email` 등의 컬럼에 인덱스를 추가하는 것이 좋습니다.
- **JOIN 조건에 자주 사용되는 컬럼**에 인덱스를 추가하면 JOIN 연산이 빨라집니다. 예를 들어, 두 테이블을 `user_id`로 JOIN할 때 `user_id` 컬럼에 인덱스가 있으면 성능이 향상됩니다.

## Partitioning
파티셔닝(Partitioning)은 대규모 데이터베이스에서 **데이터를 여러 개의 부분(파티션)으로 나누어 관리**하는 기법입니다. 각 파티션은 **물리적으로 별도의 저장 공간에 존재하지만, 논리적으로는 하나의 테이블**처럼 동작합니다. 파티셔닝은 데이터의 크기가 커질 때 성능을 최적화하고, 관리의 용이성을 높이기 위해 사용됩니다.

1. **성능 향상**: 파티셔닝된 테이블에서 쿼리가 특정 파티션만 대상으로 실행되므로, 불필요한 데이터를 조회하지 않아 성능이 개선됩니다. 예를 들어, 날짜별로 파티셔닝을 하면 특정 날짜의 데이터만 조회할 수 있습니다.
2. **관리 용이성**: 파티셔닝된 테이블은 관리가 용이합니다. 예를 들어, 오래된 데이터를 아카이빙하거나 삭제할 때, 특정 파티션만 처리하면 됩니다.
3. **병렬 처리**: 각 파티션은 독립적으로 처리되므로, 데이터베이스 시스템이 병렬로 작업을 처리할 수 있어 처리 속도가 빨라집니다.

### 수직 파티셔닝 (Vertical Partitioning)
수직 파티셔닝은 **테이블의 열(컬럼)을 기준**으로 데이터를 분할하는 방법입니다. 즉, **같은 행(row)의 데이터** 중에서 **다른 열을 별도의 테이블로 나누는 방식**입니다.

- 자주 조회되는 열을 하나의 테이블에 두고, 사용 빈도가 적은 열은 다른 테이블에 분리하여 성능을 최적화할 수 있습니다.
- 예를 들어, 고객 테이블에서 `이름`, `이메일`과 같은 기본 정보는 하나의 테이블에, `주소`, `전화번호`와 같은 부가 정보는 다른 테이블에 분리할 수 있습니다.

```sql
-- 원본 테이블
CREATE TABLE users (
    user_id INT,
    name VARCHAR(100),
    email VARCHAR(100),
    address VARCHAR(255),
    phone_number VARCHAR(20)
);

-- 수직 파티셔닝된 테이블
CREATE TABLE users_basic_info (
    user_id INT,
    name VARCHAR(100),
    email VARCHAR(100)
);

CREATE TABLE users_contact_info (
    user_id INT,
    address VARCHAR(255),
    phone_number VARCHAR(20)
);
```

### 수평 파티셔닝 (Horizontal Partitioning)
수평 파티셔닝은 **테이블의 행(row)을 기준**으로 데이터를 분할하는 방법입니다. 즉, **같은 컬럼**의 데이터들 중에서 **행을 나누는 방식**입니다. 데이터를 여러 개의 파티션으로 나누어 각각 독립적으로 저장합니다.

- 수평 파티셔닝은 **데이터가 많이 늘어나거나** **성능을 최적화해야 하는 경우**에 유용합니다.
- 분할 기준에 따라 여러 파티션에 데이터를 분배하여 저장할 수 있습니다. 예를 들어, 날짜, 지역, 사용자 그룹 등을 기준으로 데이터를 나눌 수 있습니다.

#### 범위 기반 파티셔닝 (Range Partitioning)
데이터의 특정 열에 대해 범위(구간)를 정의하고, 그 범위에 맞는 데이터를 파티션에 나눕니다. 예를 들어, 특정 날짜나 ID 범위에 따라 데이터를 분할할 수 있습니다.

- `order_date`가 `2023-01-01`부터 `2023-06-30`까지는 파티션 A, `2023-07-01`부터 `2023-12-31`까지는 파티션 B.
- 범위 기반 검색이 효율적입니다. 예를 들어, 날짜 범위나 ID 범위로 데이터를 조회할 때 유용합니다.
- 특정 범위에 데이터가 몰리게 되면 부하가 집중될 수 있습니다. 예를 들어, 한 날짜에 트랜잭션이 집중되거나 특정 ID 범위에 많은 데이터가 몰리는 경우 성능이 저하될 수 있습니다.

#### 해시 기반 파티셔닝 (Hash Partitioning)
데이터의 특정 열을 해시 함수에 입력하여 결과 값을 바탕으로 데이터를 파티션에 분배합니다. 데이터가 균등하게 분배되도록 해시 값을 사용하기 때문에 파티션이 고르게 나누어집니다.

- `user_id`에 대해 해시 값을 계산하고, 그 결과를 바탕으로 데이터를 4개의 파티션에 분배합니다. 예를 들어, `user_id % 4` 값을 사용하여 4개의 파티션으로 분배합니다.
- 데이터를 고르게 분배할 수 있습니다. 즉, 특정 범위에 데이터가 몰리지 않고 전체적으로 분배되므로 성능이 고르게 유지됩니다.
- 해시 기반 파티셔닝은 범위 검색에 비효율적입니다. 예를 들어, 특정 `user_id` 범위를 검색하려면 모든 파티션을 검색해야 하므로 성능이 저하될 수 있습니다.

#### 리스트 기반 파티셔닝 (List Partitioning)
특정 열에 대해 미리 정의된 값 목록을 기준으로 데이터를 나누는 방식입니다. 이 방식은 데이터가 특정한 그룹에 속할 때 유용합니다.

- `country`가 'USA'인 데이터는 파티션 A, 'Korea'인 데이터는 파티션 B. `status`가 'active'인 데이터는 파티션 A, 'inactive'인 데이터는 파티션 B.
- 데이터가 미리 정의된 그룹에 속할 때 효율적입니다. 예를 들어, 국가별, 상태별로 데이터를 나누는 경우 범위가 분명하므로 검색이 효율적입니다.
- 새로운 값이 추가될 때 관리가 필요하며, 이를 처리하는 로직이 복잡해질 수 있습니다. 또한, 값이 고정된 목록에 포함되지 않는 데이터는 처리하기 어려울 수 있습니다.

### 파티셔닝 자동화
**파티셔닝 자동화**란 데이터베이스에서 데이터를 여러 파티션(구역)으로 자동으로 나누는 과정을 말합니다. 이 과정은 수동으로 데이터를 분리할 필요 없이 데이터베이스 시스템이 자동으로 데이터를 여러 파티션으로 분배하도록 설정하는 방식입니다.

1. **파티셔닝 기준 자동 설정**:
    - 데이터를 특정 기준(예: 날짜, 범위, 해시 값 등)에 따라 자동으로 나누는 방법입니다.
    - 예를 들어, 특정 날짜를 기준으로 데이터가 자동으로 일별 파티션으로 나누어지도록 설정할 수 있습니다.
2. **파티션 크기 조정**:
    - 파티셔닝 시스템이 데이터의 양에 따라 파티션을 자동으로 크기를 조정하거나 새 파티션을 추가하는 기능입니다.
    - 데이터가 증가하면 자동으로 새로운 파티션을 생성하거나 기존 파티션을 분할하여 성능을 유지할 수 있습니다.
3. **데이터 이동 자동화**:
    - 데이터가 특정 기준에 도달하면 자동으로 해당 데이터를 다른 파티션으로 이동시킵니다.
    - 예를 들어, 오래된 데이터를 아카이브 파티션으로 이동시켜 현재 파티션에서 불필요한 데이터를 제거할 수 있습니다.
4. **스케일링**:
    - 시스템이 자동으로 파티션을 나누고 조정하여 성능을 최적화할 수 있게 하며, 더 많은 데이터를 처리할 수 있도록 합니다.
    - 파티셔닝 시스템은 데이터가 많아질수록 수동 개입 없이도 확장이 가능해야 하므로, 데이터베이스의 부하 분산을 자동으로 처리합니다.

MySQL에서 `RANGE` 파티셔닝을 사용하여 `created_at` 필드 기준으로 데이터를 분할:
```sql
CREATE TABLE logs (
    id INT,
    message VARCHAR(255),
    created_at DATETIME
) PARTITION BY RANGE (YEAR(created_at)) (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026)
);
```

위의 테이블은 **시간에 따라** 새로운 파티션이 자동으로 추가됩니다. 예를 들어, 2024년이 시작되면 `p2024` 파티션이 자동으로 활성화되고, 2025년에는 `p2025` 파티션이 생성됩니다.

Bash 스크립트를 사용하여 데이터베이스에 접속하고 SQL 명령을 실행하는 방법도 가능합니다. 이때, Bash에서 SQL 스크립트를 실행할 수 있도록 `psql` (PostgreSQL)이나 `mysql` (MySQL) 커맨드 라인 도구를 사용합니다.

예시 (Bash + PostgreSQL):
```
#!/bin/bash
CURRENT_DATE=$(date +"%Y_%m")
PSQL_CMD="psql -U username -d database_name"

# 새로운 파티션 생성
$PSQL_CMD -c "CREATE TABLE transactions_${CURRENT_DATE} PARTITION OF transactions FOR VALUES FROM ('${CURRENT_DATE}-01') TO ('$(date -d '+1 month' +"%Y-%m-01")');"
```

위 예시에서는 Bash를 통해 현재 날짜에 맞는 파티션을 생성하는 SQL 명령을 데이터베이스에 전달합니다.
