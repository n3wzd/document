# miscellaneous
## Container vs Wrapper
`Container(컨테이너)`와 `Wrapper(래퍼)`는 프로그래밍 및 소프트웨어 개발에서 사용되는 용어입니다.

이 두 용어는 모두 다른 요소들을 묶거나 감싸는 데 사용되지만, 컨테이너는 일반적으로 **여러 요소를 포함하고 있는 구조**를 가리키는 데 비해, 래퍼는 보통 **특정 요소를 감싸거나 추가적인 기능을 제공**하는 데 초점을 맞추고 있습니다.

### Container
컨테이너는 일반적으로 데이터나 객체 등을 포함하고 있는 개념으로, 다른 요소들을 담는 데 사용됩니다. 주로 데이터 구조, 클래스, 또는 관련된 기능들을 하나로 묶는 데 활용됩니다. 예를 들어, 컨테이너는 배열, 리스트, 맵, 스택 등과 같은 자료구조를 지칭할 수 있습니다.

또한, 컨테이너는 컨테이너화 기술의 컨텍스트에서도 사용됩니다. 이는 애플리케이션을 실행할 때 필요한 모든 것(코드, 라이브러리, 환경 설정 등)을 패키지로 묶어 독립적으로 실행할 수 있게 해주는 기술을 의미합니다. 가령, Docker와 같은 컨테이너 기반 가상화 기술이 이에 해당합니다.
    
### Wrapper
래퍼는 다른 것을 감싸거나 덮는 데 사용되는 개념입니다. 주로 코드나 함수를 감싸거나, 인터페이스를 더 편리하게 사용할 수 있도록 하는 데 활용됩니다. 예를 들어, 함수 래퍼는 기존 함수를 감싸서 그 함수가 호출될 때 추가적인 로직을 수행하도록 할 수 있습니다.

또한, 프로그래밍에서는 객체나 자료구조를 감싸서 해당 요소들을 다른 방식으로 사용하거나 조작할 수 있는 방법을 제공하는 데 사용될 수 있습니다.

## Log
### Level
로그 레벨은 소프트웨어 개발 및 운영에서 로그 메시지의 중요도를 분류하기 위해 표준화된 방식으로 사용됩니다.

1. **TRACE**: 가장 세부적인 로그로, 프로그램의 실행 흐름을 상세히 기록합니다. 매우 세부적인 디버깅이 필요할 때 사용합니다.
2. **DEBUG**: 디버깅 목적으로 사용되며, 개발 중에 주로 활성화합니다. 개발 중에 시스템의 동작을 확인할 때 사용합니다.
3. **INFO**: 시스템의 정상적인 동작과 관련된 주요 이벤트를 기록합니다. 시스템 상태를 모니터링할 때 사용합니다.
4. **WARN**: 문제를 일으킬 가능성이 있는 상황을 나타냅니다. 비정상적이지만 치명적이지 않은 문제를 기록할 때 사용합니다.
5. **ERROR**: 심각한 문제를 나타내며, 예외 상황을 기록합니다. 복구가 필요한 치명적인 문제를 기록할 때 사용합니다.
6. **FATAL** : 치명적인 오류를 기록하며, 프로그램이 종료될 수 있는 상황을 나타냅니다.

## SSH
`SSH(Secure Shell)`는 네트워크 상에서 두 컴퓨터 간에 안전하게 통신할 수 있도록 해주는 **보안 프로토콜**입니다. 주로 원격 서버에 접속하여 명령을 실행하거나 파일을 전송할 때 사용되며, 암호화를 통해 데이터를 안전하게 보호합니다. SSH는 서버 관리와 유지보수에 중요한 역할을 하며, 서버에 대한 원격 접속을 가능하게 해줍니다.

- **원격 로그인**: 로컬 컴퓨터에서 원격 서버로 안전하게 접속해 명령어를 실행할 수 있습니다. 예를 들어, 웹 서버나 데이터베이스 서버의 설정을 수정할 때 사용됩니다.
- **파일 전송**: SSH를 사용해 파일을 안전하게 전송할 수 있습니다. 이때 많이 사용되는 도구로는 `scp` (secure copy)나 `rsync`가 있습니다.
- **포트 포워딩**: SSH를 통해 특정 포트를 터널링하여 외부 네트워크와의 안전한 통신을 할 수 있습니다. 이를 **SSH 터널링**이라고 부르며, 보안이 필요한 상황에서 많이 사용됩니다.
- **암호화된 통신**: SSH는 암호화를 사용해 데이터가 중간에 도청당하거나 변조되지 않도록 보호합니다. 대칭 키와 비대칭 키 암호화를 결합하여 통신을 안전하게 유지합니다.
- **키 기반 인증**: SSH는 암호 대신 공개 키 기반의 인증 방식을 제공합니다. 이는 비밀번호보다 보안성이 높으며, 공개 키와 개인 키 쌍을 사용해 사용자를 인증합니다.

## UUID 
UUID (Universally Unique Identifier)는 전 세계에서 고유한 값을 생성하기 위한 표준 형식입니다. UUID는 주로 데이터베이스, 분산 시스템, 네트워크, 파일 시스템 등에서 고유한 식별자가 필요할 때 사용됩니다. UUID는 128비트 크기를 가지며, 이를 16진수로 표현한 32개의 문자로 구성됩니다.

1. **고유성 (Uniqueness)**: UUID는 매우 높은 확률로 고유한 값을 생성합니다. 이를 통해 다른 시스템 간에 충돌 없이 고유한 식별자를 생성할 수 있습니다.
2. **전 세계적으로 고유**: UUID는 시간, 머신 정보, 랜덤 값 등을 기반으로 생성되기 때문에, 서로 다른 시스템에서 생성된 UUID도 충돌하지 않습니다.
3. **표준화**: UUID는 RFC 4122에 의해 정의된 표준 형식으로, 다양한 언어나 시스템에서 동일한 방식으로 생성됩니다.

UUID는 일반적으로 32개의 16진수 숫자와 4개의 하이픈으로 구분된 5개의 부분으로 이루어져 있습니다:

```
123e4567-e89b-12d3-a456-426614174000
```

**사용 사례**:
1. **데이터베이스의 기본 키**: UUID는 고유한 식별자가 필요할 때, 특히 분산 시스템에서 유용합니다.
2. **세션 식별자**: 웹 애플리케이션에서 사용자 세션을 추적할 때 UUID를 사용하여 고유한 세션 ID를 생성합니다.
3. **파일 식별자**: 파일 시스템에서 파일 이름을 고유하게 생성하거나, 분산 파일 시스템에서 파일을 식별하는 데 사용됩니다.
4. **API 키 및 토큰**: 인증 및 권한 부여 시스템에서 고유한 API 키나 인증 토큰을 생성할 때 UUID를 사용합니다.

## 환경 변수
환경 변수는 **운영 체제에서 실행 중인 프로세스가 사용할 수 있는 동적인 값**입니다. 시스템 설정, 애플리케이션 구성, 또는 실행 환경에 대한 정보를 저장하는 데 사용됩니다.

환경 변수는 키-값(Key-Value) 쌍으로 구성되며, 운영 체제에서 전역적으로 접근하거나 특정 프로세스에서만 사용할 수 있습니다.

1. **전역 접근 가능**: 환경 변수는 시스템 전역적으로 설정되며, 해당 값을 모든 프로세스에서 사용할 수 있습니다.
2. **키-값 쌍**: 각 환경 변수는 고유한 이름(키)과 값으로 구성됩니다.
3. **동적 변경 가능**: 시스템 실행 중에도 값을 변경하거나 추가할 수 있습니다.
4. **보안**: 민감한 정보를 코드 대신 환경 변수에 저장하여 보안을 강화할 수 있습니다.

**환경 변수의 주요 용도**
1. **시스템 구성**:
    - 운영 체제에서 사용하는 기본 디렉토리, 실행 경로, 언어 설정 등을 정의.
    - 예: `PATH`, `HOME`, `TEMP`.
2. **애플리케이션 설정**:
    - 데이터베이스 URL, API 키, 포트 번호와 같은 설정 정보를 저장.
    - 예: `DB_URL`, `API_KEY`, `PORT`.
3. **환경 분리**:
    - 개발, 테스트, 프로덕션 환경에서 다른 설정 값을 사용할 수 있도록 지원.
    - 예: `ENV=development` 또는 `ENV=production`.
4. **비밀 정보 관리**:
    - 비밀번호, 토큰, 인증 키와 같은 민감한 정보를 코드에서 분리.

## 서버 렌더링
**서버 렌더링(Server-Side Rendering, SSR)**은 웹 애플리케이션에서 HTML 콘텐츠를 서버에서 생성하여 클라이언트(브라우저)로 전송하는 방식을 말합니다. 서버가 요청을 받으면 필요한 데이터를 기반으로 HTML 페이지를 완성하고, 브라우저는 이를 받아 사용자에게 표시합니다.

서버 렌더링은 **SEO 최적화**와 **빠른 초기 로드**가 중요한 프로젝트에 적합하며, 클라이언트 렌더링과 함께 사용해 하이브리드 구조를 구현할 수도 있습니다.

1. **SEO(검색 엔진 최적화)**
    - 검색 엔진은 서버에서 생성된 HTML 콘텐츠를 쉽게 크롤링할 수 있습니다.
    - 클라이언트 렌더링보다 SEO에 유리합니다.
2. **빠른 초기 로드**
    - 브라우저가 완성된 HTML을 받아 즉시 렌더링할 수 있으므로 초기 로드 시간이 빠릅니다.
3. **간단한 구현**
    - JavaScript 프레임워크를 사용하지 않고도 서버에서 HTML을 생성할 수 있어 구현이 간단합니다.
4. **일관된 데이터 처리**
    -   서버에서 모든 데이터를 처리하므로 보안이 강화되고, 클라이언트에서의 데이터 누락 가능성이 줄어듭니다.

**과정**
1. **클라이언트 요청**
    -   사용자가 브라우저에서 URL에 접근하거나 특정 요청을 보냅니다.
2. **서버 처리**
    -   서버는 요청을 받아 필요한 데이터를 데이터베이스나 외부 API에서 가져옵니다.
    -   데이터를 템플릿 엔진(예: Thymeleaf, JSP, Handlebars)을 사용해 HTML 페이지에 삽입합니다.
3. **완성된 HTML 반환**
    - 서버는 완성된 HTML을 클라이언트로 전송합니다.
4. **클라이언트 표시**
    - 브라우저는 받은 HTML을 렌더링하여 사용자에게 페이지를 보여줍니다.

서버 렌더링(Server-Side Rendering, SSR)은 전통적으로 **백엔드의 영역**에 속하지만, 프론트엔드와 밀접하게 관련된 작업입니다. SSR이 브라우저에서 렌더링될 HTML을 생성하고, 사용자가 보는 UI를 결정하기 때문입니다. **어떤 기술 스택을 사용하는지**에 따라 프론트엔드와 백엔드 중 누가 더 많은 책임을 가지는지가 달라집니다.
- 전통적인 서버 렌더링(Java + Thymeleaf, Django 등): 백엔드 주도.
- 현대적인 SSR(Next.js, Nuxt.js 등): 프론트엔드 개발자가 주도.

## 더티 쓰기
**더티 쓰기(Dirty Write)**는 데이터베이스나 객체 관계 매핑(ORM)에서 **변경된 데이터가 저장되었을 때, 실제로 변경된 내용만 반영하는 것이 아니라 불필요한 데이터까지 저장되는 현상**을 의미합니다. 즉, 객체의 상태가 변경되면 그 객체가 연결된 데이터베이스 테이블의 모든 필드가 업데이트되는 방식입니다. 더티 쓰기는 **ORM의 편리함을 제공하지만, 성능에 영향을 미칠 수 있습니다**.

1. **객체의 상태 변경 추적**:
    - ORM은 객체를 데이터베이스 테이블과 매핑하여 객체의 상태를 추적합니다. 객체의 상태가 변경되면, ORM은 해당 객체를 "더티(Dirty)" 상태로 표시하고, 이를 저장할 때 모든 변경된 필드를 데이터베이스에 반영합니다.
2. **불필요한 업데이트**:
    - 객체의 일부 필드만 변경되었더라도, ORM은 객체 전체를 저장하려고 할 수 있습니다. 예를 들어, 객체의 일부 필드만 수정되었는데, ORM은 해당 객체의 모든 필드를 업데이트하려고 할 수 있습니다.
3. **자동으로 처리되는 경우**:
    - JPA와 같은 ORM에서는 객체의 상태가 변경되면 이를 자동으로 추적하고, `save()`, `flush()` 등을 호출하면 변경된 내용을 자동으로 데이터베이스에 반영합니다. 이때 객체의 상태가 "더티"로 표시되며, 해당 객체의 모든 변경 사항이 데이터베이스에 반영됩니다.

예를 들어, `User` 객체가 있고 이 객체의 `name`과 `email` 필드가 있습니다. 만약 `name`만 수정되었다면, `email`은 변경되지 않았지만 ORM은 객체를 저장할 때 `name`과 `email` 모두를 업데이트하려고 할 수 있습니다. 이렇게 되면 `email` 필드는 실제로 변경되지 않았음에도 불구하고 불필요하게 데이터베이스에 저장됩니다. 이 현상이 바로 **더티 쓰기**입니다.

**더티 쓰기의 장점**:
- **간편함**: ORM이 객체의 상태를 자동으로 추적하고, 변경된 내용을 데이터베이스에 반영하므로 개발자가 일일이 SQL을 작성할 필요가 없습니다.
- **자동화**: 객체의 상태가 변경되면 ORM이 이를 자동으로 반영하므로 개발자가 수동으로 업데이트 쿼리를 작성할 필요가 없습니다.

**더티 쓰기의 단점**:
- **불필요한 업데이트**: 객체의 일부 필드만 변경되었는데, 전체 객체가 업데이트되므로 불필요한 데이터베이스 쓰기 작업이 발생할 수 있습니다. 이는 성능 저하를 초래할 수 있습니다.
- **성능 문제**: 객체가 매우 크거나, 많은 필드를 가지고 있는 경우, 불필요한 필드까지 업데이트되면 성능에 부정적인 영향을 미칠 수 있습니다.
